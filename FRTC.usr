c- Spatially evolving turbidity currents, both in periodic channels or canyon-fan transitions 
c- Simulation parameters -----------------------------------------------------------
#define RITAU uparam(1)                         /* Ri_tau */
#define RITAU2 uparam(2)                        /* Ri_tau2 (downstream from the break in slope). The mesh is not deformed is if it's equal to Ri_tau */
#define V_SETTLING uparam(3)                    /* Settling velocity (positive)*/
#define DIAM uparam(4)                          /* Nondimensional particle diameter */ 
#define UTARGET uparam(5)                       /* u_target for top PML, positive */ 
#define BC_FLAG_TEMP uparam(6)                  /*0-> Depositional grad(T) dot n=0, 1-> Bypass mode: (1/Pe)*grad(T) dot n = -|Vs*T| dot n  2-> Parker erosion: (1/Pe)*grad(T) dot n = |Vs*Es| dot n */
#define time_inflow uparam(7)                   /* Duration of inflow flow */   

#define RE_TAU (1/param(2))                     /* Re_tau */
#define PACKING_FR 0.6
#define RE_P ((RE_TAU*DIAM*V_SETTLING*18.0)**0.5)                /*Particle Reynolds number*/
#define Cv RE_TAU*DIAM**2/(18*V_SETTLING*sin(atan(1/RITAU)))     /*Volume mean concentration*/

c- Increased viscosity outflow parameters ----------------------------------
#define VISCFAC 10.0
#define VISCFAC_SIDE 10.0
#define ZBUFF (ZLEN-3.0*PI)
#define YBUFF (YLEN-8.)

c- Exner equation parameters -----------------------------------------------
#define THRESHOLD 0.001                        /*concentration integration threshold */
#define EPS_EXNER 0.010                        /*epsilon for numerical diffusion in Exner equation*/
#define STD_EXNER_QX 3.5                       /*Gaussian filter standard deviation for div q, as a fraction of the elements size*/
#define STD_EXNER_QZ 3.5                       /*Gaussian filter standard deviation for div q, as a fraction of the elements size*/
#define MV_STEP 10                             /*Mesh eigenvalues will be updated every MV_STEP steps*/
#define IN_ZL 10.0                             /*Inlet zone for Exner equation*/
#define OUT_ZL 40.0                            /*Outlet zone for Exner equation*/

c- I/O parameters -----------------------------------------------------------
#define restart_inflow uparam(11)                 /* whether to read inflow2d.ini (2d) for restasting */
#define restart_bed uparam(12)                    /* whether to read bedform.ini for restasting */
#define restart_means abs(uparam(13))/uparam(13)  /* whether to read means.ini for means restasting (>0)*/
#define iostep_2d_avg_time  abs(uparam(13))       /* output frequency for spanwise-time-averaged statistics */
#define mean_time_start abs(uparam(14))           /* start time for means accumulation */
#define iostep_2d_notime uparam(15)               /* output frequency for spanwise-averaged statistics*/
#define iostep_bed abs(uparam(16))                /* output frequency for bedform file, if uparam(16) lt 0, bedform calculations are skipped*/

c - mesh and buffer zones dimensions
#define PI (4.*atan(1.))
#define nelsides ((lelx-nelxin)/2)       
#define YLEN uparam(8)
#define ZLEN (uparam(9)*PI)
#define NUMBER_ELEMENTS_X lelx
#define NUMBER_ELEMENTS_Y lely
#define NUMBER_ELEMENTS_Z lelz



#define ratiozh 3.0        /*fraction of domain before the break*/
#define nhighz 0           /*number of high resolution elements near the break*/
#define ratio_top_uy 1.0   /*ratio of the velocity at the top of the domain between zones, if a preset velocity is used*/
#define nelyint 13         /*number of elements in the higher resolution zone*/
#define hint 6             /*height of heigher resolution zone*/

c - Iflow dimensions
#define nelxin 8              /*number of elements of inflow array */
#define nelyin 4
#define nelzin 14
#define xlen_inflow (8.0*PI/3.0) /* width of inflow domain*/
#define zlen_inflow (8.*PI)      /*lenght of inflow domain*/
#define hf 2.0                   /*height of inflow domain*/

c - flags    -----------------------------------------------------------
#define MESH_SLOPE RITAU .ne. RITAU2      /*Whether the mesh is deformed to include a break*/    
#define set_IC_flag .FALSE.               /*Whether the inflow is copied at the bottom for the IC */
#define IF_FAN lelx .ne. nelxin           /*Whether the simulation corresponds to a fan */
#define IF_BED uparam(16).gt.0.0          /*Whether bedform calculations are done (uparam(6) greater than 0) */
#define IF_SHCR_VAR .TRUE.                /*Whether the critical Shields number depends on the bed angle */
#define IF_ALL_BED .TRUE.                 /*Whether all the bedform stats are saved or only the heights */
#define IF_GEO_REST .FALSE.               /*Whether geometry will be restored after loading the IC*/
#define IF_MVMESH .FALSE.                  /*Whether the mesh at the bottom will be deformed by the bedform.*/
#define IF_DIVQ .TRUE.                    /*Whether to include sediment flux (-div q) in Exner equation.*/    
#define IF_EROS .TRUE.                    /*Whether to include sediment entrainment (-E_s) in Exner equation.*/    
#define IF_DEPO .TRUE.                    /*Whether to include sediment deposition (C_b) in Exner equation.*/    
#define IF_HIS .FALSE.                     /*Whether to save history points*/
#define IF_SEM .TRUE.                      /*Whether to generate inflow conditions using SEM*/
#define IF_SMAG .FALSE.                     /*Whether to use dynamic smagorinsky model*/



      subroutine uservp (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

c     TURBULENT OUTFLOW
c     Sets low Re number in range [zout;lenz]
      real zout,zdiff
      real xdiff, xout, xlen

      real ,parameter :: buffRe=2.d3
      common /cdsmag/ ediff(lx1,ly1,lz1,lelv)

      ie    = gllel(ieg)
      if(ediff(ix,iy,iz,ie).lt.0)then
         print*,'negative udiff',ediff(ix,iy,iz,ie)
         ediff(ix,iy,iz,ie)=1.d0/buffRe
      endif
      udiff = ediff(ix,iy,iz,ie)
      utrans= 1.
      if(ifield.eq.2) then
         udiff  = param(8)/param(2)*ediff(ix,iy,iz,ie)
         utrans = 1.
      endif
       
      zout = ZBUFF                             
      zdiff=ZLEN-zout
      if(ifield.eq.1)then                          ! momentum equation
         utrans= param(1)
         udiff = param(2)
         if (z.ge.zout)then
               udiff =((param(2)*VISCFAC-param(2))/zdiff)
     $            *(z-zout) + param(2)
         endif
      else if(ifield.eq.2)then                     ! temperature eqn
        utrans= param(7)
        udiff = param(8)
        if (z.ge.zout) then
          udiff =((param(8)*VISCFAC - param(8))/zdiff)
     $           *(z-zout) + param(8)
        endif
      endif

      xdiff=1.0*PI
      xlen=xlen_inflow*(2.0*nelsides/(1.0*nelxin)+1)
      xout =xlen-xdiff

      if(IF_FAN) then
      if(ifield.eq.1)then                          ! momentum equation
         utrans= param(1)
         udiff = param(2)
         if (x.ge.xout)then
               udiff =((param(2)*VISCFAC_SIDE-param(2))/xdiff)
     $            *(x-xout) + param(2)
         elseif(x.lt.xdiff) then
          udiff =-1.0*((param(2)*VISCFAC_SIDE - param(2))/xdiff)
     $           *x + param(2)*VISCFAC_SIDE
         endif
      else if(ifield.eq.2)then                     ! temperature eqn
        utrans= param(7)
        udiff = param(8)
        if (x.ge.xout) then
          udiff =((param(8)*VISCFAC_SIDE - param(8))/xdiff)
     $           *(x-xout) + param(8)
        elseif(x.lt.xdiff) then
          udiff =-1.0*((param(8)*VISCFAC_SIDE - param(8))/xdiff)
     $           *x + param(8)*VISCFAC_SIDE
        endif
      endif
      endif !IF_FAN


      return
      end
c-----------------------------------------------------------------------
      subroutine userf  (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      include 'ZPER'  ! for nelx,nely,nelz


      real*8 egrav(3)
C     HYDROSTATIC PRESSURE VARIABLES
      common /TBAR/ tempbar(ly1,lz1,lely,lelz), tempbar_2(ly1,lely)
C 
      integer ex,ey,ez

c     BUFFER ZONE VARIABLES
      real*8 sigma2(3),sigmam1(3),sigmam2(3),beta  !changed sigma to sigma2
     $        ,umean1(3),umean2(3),yy,zz,m,vzout,zz2
      
      common /pml/ ewcalc, if_pml
      common /outflow_pl/ vzout_pl(lx1,ly1,lelx,lely)


c     MESH VARIABLES 
      egrav(1) = 0.0                         !x: Spanwise direction
      if (MESH_SLOPE) then
       egrav(2) = -1.0*sqrt(1+RITAU**2)       !y: Wall-normal direction
       egrav(3) = 0.0                         !z: Streamwise direction
      else
       egrav(2) = -1.0*RITAU
       egrav(3) = 1.0                         !z: Streamwise direction
      endif

c     Note: this is an acceleration term, NOT a force!
c     Thus, ffx will subsequently be multiplied by rho(x,t).
      call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
      ffx = temp*egrav(1)
      if (MESH_SLOPE) then
        ffy = (temp - tempbar(iy,iz,ey,ez))*egrav(2)
      else
        ffy = (temp - tempbar_2(iy,ey))*egrav(2)
      endif
      ffz = temp*egrav(3)
c     ############################################################
c     ############################################################

c     ############################################################
c     ############################################################
      if (if_pml.eq.1)then
C         if(istep.eq.1 .and. nid.eq.0) write(*,*) '****Using PML*****'
c     Buffer zones
        sigmam1(1) = 0.0                          !<-----------------CHANGE!
        sigmam1(2) = 1.0                          !<-----------------CHANGE!
        sigmam1(3) = 0.0                          !<-----------------CHANGE!

        sigmam2(1) = 0.0                          !<-----------------CHANGE!
        sigmam2(2) = 0.0                          !<-----------------CHANGE!
        sigmam2(3) = 0.0                          !<-----------------CHANGE!

        beta = 2.0                                !<-----------------CHANGE!

        umean1(1) = 0.0                           !<-----------------CHANGE! 
        umean1(2) =-UTARGET                       
        umean1(3) = 0.0                           !<-----------------CHANGE! 
        
        umean2(1) = 0.0                           !<-----------------CHANGE! 
        umean2(2) = 0.0                           !<-----------------CHANGE! 
        umean2(3) = 0.0                           !<-----------------CHANGE! 

        m=(YLEN-YBUFF)/
     &   (ZLEN
     &    -ZBUFF)
        zz = (y-YBUFF)/m 
     & + ZBUFF
        yy = m * (z-ZBUFF)
     & + YBUFF

c     ###############
c     Top buffer zone
        sigma2(1) = 0.0
        sigma2(2) = 0.0
        sigma2(3) = 0.0
        if (y.ge.YBUFF.and.z.le.zz) then
          sigma2(1) = sigmam1(1)*((y - YBUFF)/
     &      (YLEN-YBUFF))**(beta)
          sigma2(2) = sigmam1(2)*((y - YBUFF)/
     &       (YLEN-YBUFF))**(beta)
          sigma2(3) = sigmam1(3)*((y - YBUFF)/
     &       (YLEN-YBUFF))**(beta)

          ffx = ffx - sigma2(1) * (ux - umean1(1))
          ffy = ffy - sigma2(2) * (uy - umean1(2)) 
          ffz = ffz - sigma2(3) * (uz - umean1(3))
        endif
      endif !if_pml.eq.1
c     ###################
c     Outflow buffer zone
      if(.false.) then
          sigma2(1) = 0.0
          sigma2(2) = 0.0
          sigma2(3) = 0.0

          sigmam2(1) = 0.0                          !<-----------------CHANGE!
          sigmam2(2) = 0.0                          !<-----------------CHANGE!
          sigmam2(3) = 100.0                        !<-----------------CHANGE!

          umean2(1) = 0.0                           !<-----------------CHANGE! 
          umean2(2) = 0.0                           !<-----------------CHANGE! 
          umean2(3) = 0.0                           !<-----------------CHANGE!

          beta = 2.0

          zz2=(z-ZBUFF)/
     &      (ZLEN
     &      -ZBUFF)
          m=(YLEN-YBUFF)/
     &   (ZLEN
     &    -ZBUFF)
          yy = m * (z-ZBUFF)
     & + YBUFF

          call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
          vzout = vzout_pl(ix,iy,ex,ey)
C           if (z.ge.ZBUFF
C      &      .and.y.lt.yy.and.vzout.lt.0.0) then
          if (z.ge.ZBUFF
     &      .and.vzout.lt.0.0) then
            sigma2(1) = sigmam2(1)*(zz2)**(beta)
            sigma2(2) = sigmam2(2)*(zz2)**(beta)
            sigma2(3) = sigmam2(3)*(zz2)**(beta)

            ffx = ffx - sigma2(1) * (ux - umean2(1))
            ffy = ffy - sigma2(2) * (uy - umean2(2))
            ffz = ffz - sigma2(3) * (uz - umean2(3))
          endif
      endif
c     ################# 


      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      common /VS_GRADT/ vsgradt(lx1,ly1,lz1,lelt)
      integer e,f,eg

      e = gllel(eg)

      if (V_SETTLING.ne.0) then
          qvol   = -1.0*vsgradt(ix,iy,iz,e)
      else
          qvol=0.0
      endif
      source = 0.0

      return
      end

c-----------------------------------------------------------------------

      subroutine userchk
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'  ! for nelx,nely,nelz

c     ############################################################
      integer nelin,nel_slab,nin
      real rlenz,z_inflow,dz_inflow
      real dtimestep

      parameter(nelin=nelxin*nelyin*nelzin)
      parameter(nel_slab=nelxin*nelyin)
      parameter(nin = nelin*lx1*ly1*lz1)

      integer if_mean_2d
      save if_mean_2d

      integer counter_inflow
      save counter_inflow

      real vxin(lx1,ly1,lz1,nelin)
     $    ,vyin(lx1,ly1,lz1,nelin)
     $    ,vzin(lx1,ly1,lz1,nelin)
     $    ,tin(lx1,ly1,lz1,nelin)

      common /inflow_pl/ vxin_pl(lx1,ly1,nel_slab)
     $                  ,vyin_pl(lx1,ly1,nel_slab)
     $                  ,vzin_pl(lx1,ly1,nel_slab)
     $                  ,tin_pl(lx1,ly1,nel_slab)
      save z_inflow
      real theta

c     spanwise-averaged arrays
      real    yavgx(ny1,nz1,lely,lelz)
     $    ,   zavgx(ny1,nz1,lely,lelz)

      common /avgstats/
     &  rumm(lx1,ly1,lz1,lelt,4)
     & , ru2m(lx1,ly1,lz1,lelt,4)
     & , ruvm(lx1,ly1,lz1,lelt,6)
     & , ruxm(lx1,ly1,lz1,lelt,12)
     & , rux2(lx1,ly1,lz1,lelt,12)
     & , ru3m(lx1,ly1,lz1,lelt,4)
     & , rv2u(lx1,ly1,lz1,lelt,6)
     & , rpmm(lx1,ly1,lz1,lelt,4)
     & , summ(lx1,ly1,lz1,lelt,4)
     & , su2m(lx1,ly1,lz1,lelt,4)
     & , suvm(lx1,ly1,lz1,lelt,6)
     & , suxm(lx1,ly1,lz1,lelt,12)
     & , sux2(lx1,ly1,lz1,lelt,12)
     & , su3m(lx1,ly1,lz1,lelt,4)
     & , sv2u(lx1,ly1,lz1,lelt,6)
     & , spmm(lx1,ly1,lz1,lelt,4)
     & , summ_2d(ly1,lz1,lely,lelz,4)
     & , su2m_2d(ly1,lz1,lely,lelz,4)
     & , suvm_2d(ly1,lz1,lely,lelz,6)
     & , suxm_2d(ly1,lz1,lely,lelz,12)
     & , sux2_2d(ly1,lz1,lely,lelz,12)
     & , su3m_2d(ly1,lz1,lely,lelz,4)
     & , sv2u_2d(ly1,lz1,lely,lelz,6)
     & , spmm_2d(ly1,lz1,lely,lelz,4)


      common /avgstats_old/
     &  summ_2d_o(ly1,lz1,lely,lelz,4)
     & , su2m_2d_o(ly1,lz1,lely,lelz,4)
     & , suvm_2d_o(ly1,lz1,lely,lelz,6)
     & , suxm_2d_o(ly1,lz1,lely,lelz,12)
     & , sux2_2d_o(ly1,lz1,lely,lelz,12)
     & , su3m_2d_o(lx1,ly1,lely,lelz,4)
     & , sv2u_2d_o(lx1,ly1,lely,lelz,6)
     & , spmm_2d_o(lx1,ly1,lely,lelz,4)
     & ,timem,atimem,timelm,dtimem,t_tot

      integer counter1

      integer if_write_means, if_write_meansnt
      integer counter_mean
      save counter_mean
      data    counter_mean /0/
      integer counter_meansnt
      save counter_meansnt
      data    counter_meansnt /0/

      logical ifverbose
      real wo1(lx1,ly1,lz1,lelv)
     &      ,  wo2(lx1,ly1,lz1,lelv)
     &      ,  wo3(lx1,ly1,lz1,lelv)
     &      ,  wo4(lx1,ly1,lz1,lelv)
     &      ,  wo5(lx1,ly1,lz1,lelv)
     &      ,  wo6(lx1,ly1,lz1,lelv)


      real             w1(ly1,lz1,lely,lelz)
     &              ,  w2(ly1,lz1,lely,lelz)
     &              ,  w3(ly1,lz1,lely,lelz)
     &              ,  w4(ly1,lz1,lely,lelz)
     &              ,  wy1(ly1,nely)
     &              ,  wy2(ly1,nely)
      save igs_x, igs_z, igs_y

      integer e,ex,ey,ez,eg

      common /pml/ ewcalc, if_pml
      real yheight(lx1,ly1,lz1,lelv)
      save yheight
      real dumwo(lx1,lz1,lelx,lelz)

c     2d spanwise-averaged arrays 
      real v2d(ly1,lz1,lely,lelz),w2d(ly1,lz1,lely,lelz),
     &     y2d(ly1,lz1,lely,lelz),z2d(ly1,lz1,lely,lelz),
     &     tt2d(ly1,lz1,lely,lelz)


c     depth-averaged arrays
      real zavgxy(nz1,lelz)

c     dWh/dz (from cons. of mass dUh/dz=we)
      real    dzwavgxy(nz1,lelz),
     $        dzwavgxy_fltr(nz1,lelz)
c
c     Interface position array (intr) and threshold delta
      real intr(nz1,lelz)

c     average in time variables
      integer icalled
      save    icalled
      data    icalled /0/

      real atime,timel
      save atime,timel
      real alpha,beta
      integer n,nt

      integer icnt_time
      save    icnt_time
      data    icnt_time /0/

      integer icnt
      save    icnt
      data    icnt /0/
c
      character*32 istepc,outfile

      character*80 icfile
c
c     Gradient arrays for shear velocity, 
c     tke production and dissipation computation
      real vxx(lx1,ly1,lz1,lelv),
     $     vxy(lx1,ly1,lz1,lelv),
     $     vxz(lx1,ly1,lz1,lelv),
     $     vyx(lx1,ly1,lz1,lelv),
     $     vyy(lx1,ly1,lz1,lelv),
     $     vyz(lx1,ly1,lz1,lelv),
     $     vzx(lx1,ly1,lz1,lelv),
     $     vzy(lx1,ly1,lz1,lelv),
     $     vzz(lx1,ly1,lz1,lelv),
     $     tx(lx1,ly1,lz1,lelv),
     $     ty(lx1,ly1,lz1,lelv),
     $     tz(lx1,ly1,lz1,lelv)

c     ############################################################
C       parameter(INTP_NMAX=ly1*lz1*lely*lelz)
      parameter(mz=lz1*lelz*3)
      parameter(myint=ly1*lely*3)
      parameter(INTP_NMAX=mz*myint)

      real    rwk(INTP_NMAX,ldim+1) ! r, s, t, dist2
      integer iwk(INTP_NMAX,3)      ! code, proc, el 
      save    rwk, iwk

      integer nint, intp_h, intp_h2
      save    nint, intp_h, intp_h2

      logical iffpts
      save iffpts

      real xint(INTP_NMAX),yint(INTP_NMAX),zint(INTP_NMAX)
      save xint, yint, zint
      real wintr(INTP_NMAX)
      save wintr
      real ymm(ly1,lz1,lely,lelz)
      save ymm
      real deltaz ,zdum
      save deltaz,zdum
      real  wintr3(myint), wintr2(myint)
      save wintr3,wintr2
      real y_inter(myint), tline(myint)
      save y_inter,tline
c     ############################################################
c     HYDROSTATIC PRESSURE VARIABLES
      common /TBAR/ tempbar(ly1,lz1,lely,lelz),tempbar_2(ly1,lely)
      real w1t(ly1,lely),w2t(ly1,lely)
      
      common /VS_GRADT/ vsgradt(lx1,ly1,lz1,lelt)
      common /VS_VEC/ vs(3)
      
      common /outflow_pl/ vzout_pl(lx1,ly1,lelx,lely)
      real vzout_pldum(lx1,ly1,lelx,lely)

      parameter (llt=lx1*ly1*lz1*lelt)
      common /cmygeom/ xmo(llt),ymo(llt),zmo(llt)

      parameter (n_slab=ly1*nelyin)
      real wslab(n_slab)
      common /inflow_interp/ y_slab(n_slab)

      common /v_filter/ vx_f(lx1,ly1,lz1,lelv),vy_f(lx1,ly1,lz1,lelv),
     &                  vz_f(lx1,ly1,lz1,lelv),t_f(lx1,ly1,lz1,lelv)
c      Exner variables
      real wxz1(lx1,lz1,lelx,lelz),wxz2(lx1,lz1,lelx,lelz), !working arrays
     &     wxz3(lx1,lz1,lelx,lelz),
     &     btt(lx1,lz1,lelx,lelz),  !bottom concentration
     &     btuy(lx1,lz1,lelx,lelz),  !bottom dvx/dy
     &     btwy(lx1,lz1,lelx,lelz),  !bottom dvz/dy
     &     btvy(lx1,lz1,lelx,lelz),  !bottom dvy/dy
     &     sh_x(lx1,lz1,lelx,lelz),  !Shields number
     &     sh_z(lx1,lz1,lelx,lelz),  !Shields number
     &     sh_cr(lx1,lz1,lelx,lelz),  !Critical Shields number
     &     qbx(lx1,lz1,lelx,lelz),   !Bottom sediment flux
     &     qbz(lx1,lz1,lelx,lelz),  !Bottom sediment flux
     &     int_t(lx1,lz1,lelx,lelz),
     &     qbxx(lx1,lz1,lelx,lelz),
     &     qbzz(lx1,lz1,lelx,lelz),
     &     theta_bedx(lx1,lz1,lelx,lelz),
     &     theta_bedz(lx1,lz1,lelx,lelz),
     &     B_eta(lx1,lz1,lelx,lelz),
     &     lap_eta(lx1,lz1,lelx,lelz),
     &     bed_normal(lx1,lz1,lelx,lelz,3),
     &     bed_wk(lx1,lz1,lelx,lelz,3),
     &     sn(3)


      real normdum
      integer nxz

      common /erosion/ E_s(lx1,lz1,lelx,lelz) 

      common /heights/ eta(lx1,lz1,lelx,lelz),
     &               eta_e(lx1,lz1,lelx,lelz),
     &               eta_d(lx1,lz1,lelx,lelz),
     &               eta_q(lx1,lz1,lelx,lelz)

      common /eta_mvbc/ umeshx(lx1,ly1,lz1,lelv)
     &              , umeshy(lx1,ly1,lz1,lelv)
     &              , umeshz(lx1,ly1,lz1,lelv)
     &              , rhs(lx1,lz1,lelx,lelz)
      real dtprev
      save dtprev

      real zbmm(lx1,lz1,lelx,lelz), xbmm(lx1,lz1,lelx,lelz) !mesh at the bottom
      save xbmm, zbmm

      real in_dns(600,15)
      real in_bulk,in_npoints,si_eddies
      save in_bulk,in_npoints,si_eddies
C       integer in_npoints
      real yline(n_slab)
      real in_dns_interp(lx1,ly1,nel_slab,14)
      save in_dns_interp
      integer n_eddies
      save n_eddies
      real yinlet(lx1,ly1,nel_slab),xinlet(lx1,ly1,nel_slab)
      save yinlet,xinlet
      real w_inlet(lx1,ly1,nel_slab)

c     LES parameters-----------------------------------
      common /cdsmag/ ediff(lx1,ly1,lz1,lelv)
      real sijdum(lx1*ly1*lz1,ldim,ldim)
      save sijdum

      real ,parameter :: par_eddy_thd=0.95d0
      real ,parameter :: par_eddy_Reb=2.d3
      real ,parameter :: par_eddy_k1 =0.25d0
      real ,parameter :: par_eddy_b1 =5.d0
      real ,parameter :: par_eddy_k2 =0.25d0
      real ,parameter :: par_eddy_b2 =10.d0

      real  tem_eddy_re,tem_eddy_nub,tem_eddy_rr
      real  tem_eddy_r1,tem_eddy_r2,tem_eddy_r0,tem_eddy_rs


      real  var_eddy_nubuff(lx1,ly1,lz1,lelv)
      real  var_eddy_comp(lx1,ly1,lz1,lelv)
      save  var_eddy_nubuff,var_eddy_comp

      real  lan_msij(lx1,ly1,lz1,lelt)
      real  lan_cs2s(lx1,ly1,lz1,lelt)


c     ############################################################


      nelx  = NUMBER_ELEMENTS_X
      nely  = NUMBER_ELEMENTS_Y
      nelz  = NUMBER_ELEMENTS_Z
      n=nx1*ny1*nz1*nelv  
      nt=nx1*ny1*nz1*nelt
      m=ny1*nz1*nely*nelz
      nxz=nx1*nz1*nelx*nelz
c     Restore geometry after loading the IC 
      if (istep.eq.0 .and. IF_GEO_REST) then      
       call opcopy(xm1,ym1,zm1,xmo,ymo,zmo)  ! Restore my geometry
       call geom_reset(1)                    ! Force regen. of Jacobians 
      endif
c     ############################################################
      if(nid.eq.0 .and. istep.eq.0) then
        write(*,*)'*************SIMULATION PARAMETERS******************'
        write(*,*)'+Mesh parameters:'
        write(*,*)'xlen = ',xlen_inflow*(2.0*nelsides/(1.0*nelxin)+1)
     &           ,'ylen = ',YLEN,'zlen = ',ZLEN
        write(*,*)'lelx = ',lelx,'lely = ',lely,'lelz = ',lelz,
     &            'N = ',lx1-1
        write(*,*)'+Boundary Conditions:'
        if (BC_FLAG_TEMP.eq.0) then
          write(*,*)'Bottom BC : dc/dn = 0'
        elseif (BC_FLAG_TEMP.eq.1) then
          write(*,*)'Bottom BC : (1/Pe) dc/dn = -|V_s.C_b|'
        else
          write(*,*)'Bottom BC : (1/Pe) dc/dn = -|V_s.E_s|'
        endif
        if (UTARGET.gt.0.0) then
          write(*,*)'Top BC : Perfectly Matched Layer with u_target = ',
     &    UTARGET
        elseif (UTARGET.lt.0.0) then
          write(*,*)'Top BC : Fixed inflow velocity u_top = ',
     &   -1.0*UTARGET   
        else
          write(*,*)'Top BC : Inflow velocity equal to mean',
     &     ' entrainment velocity.'
        endif
        write(*,*)'+Input parameters:'
        write(*,*)'Re_tau = ',RE_TAU
        write(*,*)'Ri_tau 1 = ',RITAU
        write(*,*)'Ri_tau 2 = ',RITAU2
        write(*,*)'d = ',DIAM
        write(*,*)'V_settling = ',V_SETTLING
        write(*,*)'Schmidt = ',param(8)/param(2)
        write(*,*)'Packing fraction = ',PACKING_FR
        write(*,*)'Duration of inflow flow = ', time_inflow 
        write(*,*)'+Derived parameters:'         
        write(*,*)'theta 1 (degrees)= ',180*atan(1/RITAU)/PI
        write(*,*)'c^v = ',Cv
        write(*,*)'Re_p = ',RE_P
      endif



c
c     ############################################################
c     Settling velocity of sediment (absolute value)
c     COMPUTE VS*GRAD(TEMP) (STORED IN VSGRADT)
c
c     Settling velocity
      vs(1) = 0.0
      vs(2) = (-1.0)*V_SETTLING
      vs(3) = 0.0

c     Compute grad(t)
      call gradm1(tx,ty,tz,t(1,1,1,1,1))
c     compute gradients
      call gradm1(vxx,vxy,vxz,vx)
      call gradm1(vyx,vyy,vyz,vy)
      call gradm1(vzx,vzy,vzz,vz)

      if (V_SETTLING.ne.0) then
c     Compute vs*grad(t)
      do e=1,nelt
        do i=1,lx1*ly1*lz1
          vsgradt(i,1,1,e) =  vs(1) * tx(i,1,1,e) +
     $                        vs(2) * ty(i,1,1,e) +
     $                        vs(3) * tz(i,1,1,e)
        enddo
      enddo
      endif

c     ############################################################

c     ############################################################
c
c     INTERPOLATE EXTERNAL INFLOW FILE AND SETS INFLOW PLANE
c
c     This code is made for a mesh composed of only one box.
c     Computes the inlet boundary condition for the next time step
c     interpolating the solution for a TC with fixed mean 
c     streamwise velocity and concentration
      if (istep.eq.0) then
            call yslab(y_slab,ym1,wslab,n_slab,nelyin)
      endif

      theta=0.0
      if (MESH_SLOPE) theta=atan(1/RITAU)
      if (.not. IF_SEM) then
c     READ INFLOW
      if (istep.eq.0) then
        call read_inflow(vxin,vyin,vzin,tin,nelin,nin)
        counter_inflow=0
        if (set_IC_flag) then
          call set_IC(vxin,vyin,vzin,tin,nelin,nelxin,nelyin,nelzin
     $               ,nel_slab,theta)
        endif
        call interpolateinflow(vxin,vyin,vzin,tin
     $           ,vxin_pl,vyin_pl,vzin_pl,tin_pl
     $           ,nelin,nel_slab,nelzin,z_inflow
     $          ,zlen_inflow,dtimestep,int(restart_inflow)) !in the first step is only to obtain v.in_pl arrays
      endif

      
      if (param(15).eq.0) then   !ie. writeControl=runTime is being used
        if (param(14)*aint(time/param(14)).ge.counter_inflow*param(14)) 
     &     then
          call output_inflow_pl(vxin_pl,vyin_pl,vzin_pl,tin_pl,nel_slab
     $                       ,z_inflow,counter_inflow)
          counter_inflow=counter_inflow+1
        endif
        call interpolateinflow(vxin,vyin,vzin,tin
     $           ,vxin_pl,vyin_pl,vzin_pl,tin_pl
     $           ,nelin,nel_slab,nelzin,z_inflow
     $          ,zlen_inflow,dtimestep,int(restart_inflow))  !if runtime control is used, interpolation should be done after saving the inflow plane. If not, it's the other way around.
      else
        call interpolateinflow(vxin,vyin,vzin,tin
     $           ,vxin_pl,vyin_pl,vzin_pl,tin_pl
     $           ,nelin,nel_slab,nelzin,z_inflow
     $          ,zlen_inflow,dtimestep,int(restart_inflow))
        if (mod(istep,int(param(15))).eq.0) then
          call output_inflow_pl(vxin_pl,vyin_pl,vzin_pl,tin_pl,nel_slab
     $                       ,z_inflow,counter_inflow)
        endif
      endif
      endif

      dtimestep = abs(dt)
c     ############################################################
c
c     INTERPOLATE INLET DATA AND SET INFLOW CONDITION USING
C     THE SYNTHETIC EDDY METHOD (Jarrin 2006)
c
      if (IF_SEM) then
      if (istep.eq.0) then
        call inlet_plane(yinlet,ym1,w_inlet)
        call inlet_plane(xinlet,xm1,w_inlet)
        call yslab(y_slab,ym1,wslab,n_slab,nelyin)
        call read_inflow_sem(in_dns,in_npoints,in_bulk)
        if (nid.eq.0) write(*,*) 'Inflow points=',int(in_npoints),
     &                         ', bulk velocity=',in_bulk
C       call y_line(yline,ym1,w1t,w2t)
         call interp_inflow_sem(in_dns,int(in_npoints)
     &  ,y_slab,in_dns_interp,n_eddies,si_eddies,yinlet)
      endif
      
      call gen_inflow_sem(vxin_pl,vyin_pl,vzin_pl,tin_pl
     &           ,n_eddies,si_eddies,in_bulk,in_dns_interp,
     &            dtimestep,xinlet,yinlet)

      endif



c     ############################################################
c     OUTPUT INITIAL CONDITION
      if (istep.eq.0) then
        ifxyo = .true.
        call prepost(.true.,'   ' )
        if (.not. IF_MVMESH) ifxyo = .false.
        call print_yz_mesh
        call print_xz_mesh
      endif 


c     ############################################################
      if (istep.eq.0) then 
        call x_slice(ymm,ym1,w1,w2)
        call y_slice(zbmm,zm1,wxz1)
        call y_slice(xbmm,xm1,wxz1)
        call rzero(eta,size(eta))
        call rzero(eta_q,size(eta_q))
        call rzero(eta_e,size(eta_e))
        call rzero(eta_d,size(eta_d))
      endif
      if(icalled.eq.0) then
        call rzero(rumm,size(rumm))
        call rzero(ru2m,size(ru2m))
        call rzero(ruvm,size(ruvm))
        call rzero(ruxm,size(ruxm))
        call rzero(rux2,size(rux2))
        call rzero(ru3m,size(rux2))
        call rzero(rv2u,size(rux2))
        call rzero(rpmm,size(rux2))
        call gtpp_gs_setup(igs_x,nelx,nely,  nelz,1) ! x-avx
        call gtpp_gs_setup(igs_z,nelx*nely,1,nelz,3) ! z-avx
        call gtpp_gs_setup(igs_y,nelx,nely,  nelz,2) ! y-avx
        call interp_setup(intp_h,0.0,0,nelt)
        if (nid.eq.0) then
          nint = INTP_NMAX
          call cfill(xint,1.0,size(xint))
        endif
        do i=1,INTP_NMAX
            j=i-int((i-1)/myint)*myint
            yint(i)=(j-1.)*1./(myint-1)
            yint(i)=tanh(2.5*(yint(i)-1.))/tanh(2.5)+1.
            yint(i)=yint(i)*YLEN
            if (i.le.myint) y_inter(i)=yint(i)
            j=int((i-1)/myint)+1
            zint(i)=(j-1.)*(ZLEN)/(mz-1)
        enddo
        deltaz=zint(myint+1)-zint(1)
        iffpts = .true. ! dummy call to find points
         call interp_nfld(wintr,wo1,1,xint,yint,zint,nint,
     $                   iwk,rwk,INTP_NMAX,iffpts,intp_h)
        iffpts = .false.
        atime = 0.
        timel = time
        icalled = 1
      endif !(icalled.eq.0)

c     ############################################################

      if (param(15).ne.0) then !write control -> numsteps
        if (mod(istep,int(iostep_2d_notime)).eq.0) then 
          if_write_meansnt = 1
        else
          if_write_meansnt = 0
        endif
      else  !write control -> time
       if (iostep_2d_notime*aint(time/iostep_2d_notime).ge.
     &  counter_meansnt*iostep_2d_notime)  then 
          if_write_meansnt = 1
          counter_meansnt = counter_meansnt +1 
        else
          if_write_meansnt = 0
       endif
      endif

c     write 2d spanwise-averaged files 
      if(if_write_meansnt) then

          call planar_avg(wo1,vx,igs_x) 
          call x_slice2(wo1,w1)
          if (nid.eq.0) call x_slice3(summ_2d(1,1,1,1,1))

          call planar_avg(wo1,vy,igs_x) 
          call x_slice2(wo1,w1)
          if (nid.eq.0) call x_slice3(summ_2d(1,1,1,1,2))

          call planar_avg(wo1,vz,igs_x) 
          call x_slice2(wo1,w1)
          if (nid.eq.0) call x_slice3(summ_2d(1,1,1,1,3))

          call planar_avg(wo1,t(1,1,1,1,1),igs_x) 
          call x_slice2(wo1,w1)
          if (nid.eq.0) call x_slice3(summ_2d(1,1,1,1,4))

          call col3(wo2,vx,vx,n)
          call planar_avg(wo1,wo2,igs_x) 
          call x_slice2(wo1,w1)
          if (nid.eq.0) call x_slice3(su2m_2d(1,1,1,1,1))

          call col3(wo2,vy,vy,n)
          call planar_avg(wo1,wo2,igs_x) 
          call x_slice2(wo1,w1)
          if (nid.eq.0) call x_slice3(su2m_2d(1,1,1,1,2))

          call col3(wo2,vz,vz,n)
          call planar_avg(wo1,wo2,igs_x) 
          call x_slice2(wo1,w1)
          if (nid.eq.0) call x_slice3(su2m_2d(1,1,1,1,3))

          call col3(wo2,t(1,1,1,1,1),t(1,1,1,1,1),n)
          call planar_avg(wo1,wo2,igs_x) 
          call x_slice2(wo1,w1)
          if (nid.eq.0) call x_slice3(su2m_2d(1,1,1,1,4))

          call col3(wo2,vx,vy,n)
          call planar_avg(wo1,wo2,igs_x) 
          call x_slice2(wo1,w1)
          if (nid.eq.0) call x_slice3(suvm_2d(1,1,1,1,1))

          call col3(wo2,vx,vz,n)
          call planar_avg(wo1,wo2,igs_x) 
          call x_slice2(wo1,w1)
          if (nid.eq.0) call x_slice3(suvm_2d(1,1,1,1,2))

          call col3(wo2,vx,t(1,1,1,1,1),n)
          call planar_avg(wo1,wo2,igs_x) 
          call x_slice2(wo1,w1)
          if (nid.eq.0) call x_slice3(suvm_2d(1,1,1,1,3))

          call col3(wo2,vy,vz,n)
          call planar_avg(wo1,wo2,igs_x) 
          call x_slice2(wo1,w1)
          if (nid.eq.0) call x_slice3(suvm_2d(1,1,1,1,4))

          call col3(wo2,vy,t(1,1,1,1,1),n)
          call planar_avg(wo1,wo2,igs_x) 
          call x_slice2(wo1,w1)
          if (nid.eq.0) call x_slice3(suvm_2d(1,1,1,1,5))

          call col3(wo2,vz,t(1,1,1,1,1),n)
          call planar_avg(wo1,wo2,igs_x) 
          call x_slice2(wo1,w1)
          if (nid.eq.0) call x_slice3(suvm_2d(1,1,1,1,6))
          call nekgsync()

          if (param(15).ne.0) then !write control -> numsteps
            call output_2d(time,w4,istep)
          else
            call output_2d(time,w4,counter_meansnt)
          endif
          if (nid.eq.0) write(*,*)'Writing spanwise-averaged file......'
      endif


c     ############################################################
c     COMPUTE HYDROSTATIC PRESSURE (AVERAGE OF TEMP(y))
c     FOR REFERENCE ON THIS TERM SEE CANTERO 2009 JGR
      if (MESH_SLOPE) then
        call rzero(tempbar,m) !wo1,2(lx1,ly1,lz1,lelv)
        call cfill(wintr,151413121110987654321.,size(wintr))
        call rzero(tline,myint)
        call planar_avg(wo1,t(1,1,1,1,1),igs_x)  !wo1,2(lx1,ly1,lz1,lelv)

        call interp_nfld(wintr,wo1,1,xint,yint,zint,INTP_NMAX,
     &                       iwk,rwk,INTP_NMAX,iffpts,intp_h)
        if(nid.eq.0) then
          do i=1,myint
            zdum=0.0
            do j=1,mz
                k=i+(j-1)*myint
                if (wintr(k).ne.151413121110987654321.) then
                  tline(i)=tline(i)+wintr(k)*deltaz
                  zdum=zdum+deltaz
                endif
              enddo
            tline(i)=tline(i)/zdum
          enddo
          call spline(y_inter,tline,myint,wintr2,wintr3)
          do i=1,m
            call splint(y_inter,tline,wintr2,myint,ymm(i,1,1,1),
     &         tempbar(i,1,1,1))
          enddo
        endif
        call rzero(w1,m)
        call gop(tempbar,w1,'+  ',m)
      else
        call planar_avg(wo1,t(1,1,1,1,1),igs_x)
        call planar_avg(wo2,wo1,igs_z)
        call y_line(tempbar_2,wo2,w1t,w2t)
      endif

c      ############################################################
c     Compute entrainment velocity to use at the top boundary condition.

      if (UTARGET.eq.0) then
        call rzero(wo1,size(wo1))
        do i=1,n
          if (t(i,1,1,1,1).gt.THRESHOLD) wo1(i,1,1,1)=vz(i,1,1,1) !Assumes that the main direction of the flow is z.
C      &                                                bm1(i,1,1,1) !Assumes that the main direction of the flow is z. Multiplies by the mass matrix (wo1 = vz dy)
        enddo
C         call fgslib_gs_op(igs_y,wo1,1,1,0) !add weighted values on y (wo1=int_0^ytop vz dy)
        call rzero(wo2,size(wo2))
        call planar_avg(wo2,wo1,igs_y)   ! wo2=(y_bot-y_top)^-1 * int_y_bot^ytop vz dy)
        
        if (istep.eq.0) then
          call rzero(yheight,size(yheight))
          call planar_avg(yheight,ym1,igs_y)
          do i=1,n
            yheight(i,1,1,1)=2.0*YLEN-2.0*yheight(i,1,1,1) !yheight= y_bot-y_top
          enddo
        endif
        call col2(wo2,yheight,n) ! wo2=int_y_bot^ytop vz dy)

        call gradm1(wo1,wo1,wo3,wo2)

        call rzero(wo2,size(wo2))
        call planar_avg(wo2,wo3,igs_z)
        call rzero(wo1,size(wo1))
        call planar_avg(wo1,wo2,igs_x)

        ewcalc=wo1(1,1,1,1)

        if (nid.eq.0) write(*,*) 'e_w: ', ewcalc
      endif

c      ############################################################
c     SAVE OUTFLOW PLANE

      call vz_outflow(vzout_pl,vzout_pldum)
      if(IF_HIS) call hpts()



c      ############################################################
c     Compute eddy viscosity using dynamic smagorinsky model
      if(istep.eq.0.and.IF_SMAG)then
         ifuservp  = .true.
         ifexplvis = .true.
         param(30) = 1
      endif

      if(ifuservp.and.IF_SMAG) then
c        if(nid.eq.0) print*,'Calculating eddy viscosity'
C          call gradm1(vxx,vxy,vxz,vx)
C          call gradm1(vyx,vyy,vyz,vy)
C          call gradm1(vzx,vzy,vzz,vz)
C          call smooth_fld(vxx,1)
C          call smooth_fld(vxy,2)
C          call smooth_fld(vxz,3)
C          call smooth_fld(vyx,1)
C          call smooth_fld(vyy,2)
C          call smooth_fld(vyz,3)
C          call smooth_fld(vzx,1)
C          call smooth_fld(vzy,2)
C          call smooth_fld(vzz,3)

        do e=1,lelv
           do i=1,lx1*ly1*lz1
           sijdum(i,1,1)=vxx(i,1,1,e)
           sijdum(i,2,2)=vyy(i,1,1,e)
           sijdum(i,3,3)=vzz(i,1,1,e)
           sijdum(i,1,2)=5.d-1*(vxy(i,1,1,e)+vyx(i,1,1,e))
           sijdum(i,2,3)=5.d-1*(vyz(i,1,1,e)+vzy(i,1,1,e))
           sijdum(i,3,1)=5.d-1*(vxz(i,1,1,e)+vzx(i,1,1,e))
           sijdum(i,2,1)=sijdum(i,1,2)
           sijdum(i,3,2)=sijdum(i,2,3)
           sijdum(i,1,3)=sijdum(i,3,1)
           enddo
           call eddy_visc(ediff,e,sijdum,lan_msij)
        enddo
        call eddy_visc_01(ediff,var_eddy_comp,wo1,igs_x)
      endif


c     ############################################################
c     Exner equation calculations
c     All this could and should be done only by nid.eq.0, I should fix that eventually, but I highly doubt that this is a performance issue.
c     --------------------------
      if (IF_BED) then
C         call copy(t_f,t(1,1,1,1,1),n)
C         call gradm1(wo1,wo2,wo3,vx_f)
C         call gradm1(wo4,wo5,wo6,vz_f)
        if (restart_bed.ne.0) call read_bed(eta) !rewrite!!!!!!!!!!!!!
C          if (istep.eq.0) then
C C            call y_slice(eta,ym1,wxz1)
C          endif

        if (IF_MVMESH) then
          call bed_angle(eta,theta_bedx,theta_bedz,lap_eta,
     &               wo1,wo2,wo3,wo4,wxz1,wxz2,xbmm,zbmm) !computes bed angle and lap(eta)

          call copy(vx_f,vx,n)
          call copy(vy_f,vy,n)
          call copy(vz_f,vz,n)
          call stress_normal(btuy,btwy,wxz1,
     &                        theta_bedx,theta_bedz)

        else
          call gradm1(vxx,vxy,vxz,vx)
          call gradm1(vzx,vzy,vzz,vz)

          call y_slice(btuy,vxy,wxz1)  !btuy -> dux/dy at y=0
          call y_slice(btwy,vzy,wxz1)  !btwy -> duz/dy at y=0

        endif !if_mvmsh

        call bed_filter(btuy, zbmm, xbmm,0)
        call bed_filter(btwy, zbmm, xbmm,0)

        call parker_erosion(btuy,btwy)  !Compute Parker erosion model. In a common block because of userbc
        call y_slice(btt,t(1,1,1,1,1),wxz1)      !bottom concentration

        call temp_threshold(t(1,1,1,1,1),wo1)
        call col2(wo1,t(1,1,1,1,1),n)
        call planar_avg(wo2,wo1,igs_y)
        call y_slice(int_t,wo2,wxz1)  !integral of concentration in wall-normal direction
        call bedform_calcs(btwy,btuy,btt,xbmm,zbmm,wo1,wo2,wo3,wo4,
     &                  igs_x,igs_y,igs_z,
     &                     wxz1,wxz2,wxz3,sh_x,sh_z,sh_cr,qbx,qbz,int_t,
     &               qbxx,qbzz,theta_bedx,theta_bedz,B_eta, lap_eta)

         if (IF_MVMESH)  then
           call eta_mvmesh()
           if (mod(istep,int(MV_STEP)).eq.0) then
            if_mvmine = .true.   !check line 280 of drive1.f, I added this flag
            if (nid.eq.0) write(*,*) 'Updating eigenvalues...........'
           else
            if_mvmine =.false.
           endif
         endif   
      endif !if_bed

c     ##################################################################
c      Time and spanwise averaging
c     ##################################################################
        if (time.lt.mean_time_start 
     &     .and.restart_means.gt.0)  return

      dtime = time - timel - mean_time_start
      atime = atime + dtime

      if (param(15).ne.0) then !write control -> numsteps
        if (mod(istep,int(iostep_2d_avg_time)).eq.0) then 
          if_write_means = 1
        else
          if_write_means = 0
        endif
      else  !write control -> time
       if (iostep_2d_avg_time*aint((time-mean_time_start)/
     &  iostep_2d_avg_time).ge.
     &  counter_mean*iostep_2d_avg_time)  then 
          if_write_means = 1
          counter_mean = counter_mean +1 
        else
          if_write_means = 0
       endif
      endif

      if (istep.eq.1 .and. restart_means.lt.0) then
        call input_means()

        do i=1,4
          call spanwise_copy(summ_2d_o(1,1,1,1,i),rumm(1,1,1,1,i))
        enddo
        do i=1,4
          call spanwise_copy(su2m_2d_o(1,1,1,1,i),ru2m(1,1,1,1,i))
        enddo
        do i=1,6
            call spanwise_copy(suvm_2d_o(1,1,1,1,i),ruvm(1,1,1,1,i))
        enddo
        do i=1,12
            call spanwise_copy(suxm_2d_o(1,1,1,1,i),ruxm(1,1,1,1,i))
        enddo
        do i=1,12
            call spanwise_copy(sux2_2d_o(1,1,1,1,i),rux2(1,1,1,1,i))
        enddo
        do i=1,4
            call spanwise_copy(su3m_2d_o(1,1,1,1,i),ru3m(1,1,1,1,i))
        enddo
        do i=1,6
            call spanwise_copy(sv2u_2d_o(1,1,1,1,i),rv2u(1,1,1,1,i))
        enddo
        do i=1,4
            call spanwise_copy(spmm_2d_o(1,1,1,1,i),rpmm(1,1,1,1,i))
        enddo

        atime = atimem

      endif

c     call gradm1(tx,ty,tz,t(1,1,1,1,1)) !this is already computed in the settling velocity part

c     averaging over time
      if (atime.ne.0 .and. dtime.ne.0 .and. istep.ne.0 ) then
        beta      = dtime / atime
        if (uparam(14).lt.0) beta = 1.0   !means will not be accumulated on time. Not the most elegant solution, I know.
        alpha     = 1. - beta

        ifverbose = .false.
c       Compute time-average of u,v,w and t       
        call avg1(rumm(1,1,1,1,1),vx,alpha,beta,n,'uavg',ifverbose)
        call avg1(rumm(1,1,1,1,2),vy,alpha,beta,n,'vavg',ifverbose) 
        call avg1(rumm(1,1,1,1,3),vz,alpha,beta,n,'wavg',ifverbose) 
        call avg1(rumm(1,1,1,1,4),t, alpha,beta,n,'tavg',ifverbose)
c       Compute time-average of u^2,v^2,w^2 and t^2     
        call avg2(ru2m(1,1,1,1,1),vx,alpha,beta,n,'u2mm',ifverbose)
        call avg2(ru2m(1,1,1,1,2),vy,alpha,beta,n,'v2mm',ifverbose) 
        call avg2(ru2m(1,1,1,1,3),vz,alpha,beta,n,'w2mm',ifverbose) 
        call avg2(ru2m(1,1,1,1,4),t ,alpha,beta,n,'t2mm',ifverbose)

c       Compute time-average of cross products
        call avg3(ruvm(1,1,1,1,1),vx,vy,alpha,beta,n,'uvmm',ifverbose)
        call avg3(ruvm(1,1,1,1,2),vx,vz,alpha,beta,n,'uwmm',ifverbose)
        call avg3(ruvm(1,1,1,1,3),vx, t,alpha,beta,n,'utmm',ifverbose)
        call avg3(ruvm(1,1,1,1,4),vy,vz,alpha,beta,n,'vwmm',ifverbose)
        call avg3(ruvm(1,1,1,1,5),vy, t,alpha,beta,n,'vtmm',ifverbose)
        call avg3(ruvm(1,1,1,1,6),vz, t,alpha,beta,n,'wtmm',ifverbose)
c       Compute time-average of gradients     
        call avg1(ruxm(1,1,1,1,1),vxx,alpha,beta,n,'uxmm',ifverbose)
        call avg1(ruxm(1,1,1,1,2),vxy,alpha,beta,n,'uymm',ifverbose)
        call avg1(ruxm(1,1,1,1,3),vxz,alpha,beta,n,'uzmm',ifverbose)

        call avg1(ruxm(1,1,1,1,4),vyx,alpha,beta,n,'vxmm',ifverbose)
        call avg1(ruxm(1,1,1,1,5),vyy,alpha,beta,n,'vymm',ifverbose)
        call avg1(ruxm(1,1,1,1,6),vyz,alpha,beta,n,'vzmm',ifverbose)

        call avg1(ruxm(1,1,1,1,7),vzx,alpha,beta,n,'wxmm',ifverbose)
        call avg1(ruxm(1,1,1,1,8),vzy,alpha,beta,n,'wymm',ifverbose)
        call avg1(ruxm(1,1,1,1,9),vzz,alpha,beta,n,'wzmm',ifverbose)

        call avg1(ruxm(1,1,1,1,10),tx ,alpha,beta,n,'txmm',ifverbose)
        call avg1(ruxm(1,1,1,1,11),ty ,alpha,beta,n,'tymm',ifverbose)
        call avg1(ruxm(1,1,1,1,12),tz ,alpha,beta,n,'tzmm',ifverbose)
c       Compute time-average of squared gradients
        call avg2(rux2(1,1,1,1,1),vxx,alpha,beta,n,'ux2m',ifverbose)
        call avg2(rux2(1,1,1,1,2),vxy,alpha,beta,n,'uy2m',ifverbose)
        call avg2(rux2(1,1,1,1,3),vxz,alpha,beta,n,'uz2m',ifverbose)

        call avg2(rux2(1,1,1,1,4),vyx,alpha,beta,n,'vx2m',ifverbose)
        call avg2(rux2(1,1,1,1,5),vyy,alpha,beta,n,'vy2m',ifverbose)
        call avg2(rux2(1,1,1,1,6),vyz,alpha,beta,n,'vz2m',ifverbose)

        call avg2(rux2(1,1,1,1,7),vzx,alpha,beta,n,'wx2m',ifverbose)
        call avg2(rux2(1,1,1,1,8),vzy,alpha,beta,n,'wy2m',ifverbose)
        call avg2(rux2(1,1,1,1,9),vzz,alpha,beta,n,'wz2m',ifverbose)

        call avg2(rux2(1,1,1,1,10),tx ,alpha,beta,n,'tx2m',ifverbose)
        call avg2(rux2(1,1,1,1,11),ty ,alpha,beta,n,'ty2m',ifverbose)
        call avg2(rux2(1,1,1,1,12),tz ,alpha,beta,n,'tz2m',ifverbose)
c        Compute time average of u^3, v^3, w^3, t^3
        call avg3(ru3m(1,1,1,1,1),ru2m(1,1,1,1,1),vx, alpha,beta,n,
     &                                            'u3mm',ifverbose)
        call avg3(ru3m(1,1,1,1,2),ru2m(1,1,1,1,2),vy, alpha,beta,n,
     &                                            'v3mm',ifverbose)
        call avg3(ru3m(1,1,1,1,3),ru2m(1,1,1,1,3),vz, alpha,beta,n,
     &                                            'w3mm',ifverbose)
        call avg3(ru3m(1,1,1,1,4),ru2m(1,1,1,1,4),t, alpha,beta,n,
     &                                            't3mm',ifverbose)
c        Compute uv^2,uw^2, etc
        call avg3(rv2u(1,1,1,1,1),ru2m(1,1,1,1,1),vy, alpha,beta,n,
     &                                            'vu2m',ifverbose)
        call avg3(rv2u(1,1,1,1,2),ru2m(1,1,1,1,1),vz, alpha,beta,n,
     &                                            'wu2m',ifverbose)
        call avg3(rv2u(1,1,1,1,3),ru2m(1,1,1,1,2),vx, alpha,beta,n,
     &                                            'uv2m',ifverbose)
        call avg3(rv2u(1,1,1,1,4),ru2m(1,1,1,1,2),vz, alpha,beta,n,
     &                                            'wv2m',ifverbose)
        call avg3(rv2u(1,1,1,1,5),ru2m(1,1,1,1,3),vx, alpha,beta,n,
     &                                            'uw2m',ifverbose)
        call avg3(rv2u(1,1,1,1,6),ru2m(1,1,1,1,3),vy, alpha,beta,n,
     &                                            'vw2m',ifverbose)
c        Compute p, up, vp, wp
        call avg1(rpmm(1,1,1,1,1),pr,alpha,beta,n,'pavg',ifverbose)
        call avg3(rpmm(1,1,1,1,2),pr,vx, alpha,beta,n,'upmm',ifverbose)
        call avg3(rpmm(1,1,1,1,3),pr,vy, alpha,beta,n,'vpmm',ifverbose)
        call avg3(rpmm(1,1,1,1,4),pr,vz, alpha,beta,n,'wpmm',ifverbose)
      endif ! (atime.ne.0 .and. dtime.ne.0 .and. istep.ne.0 )
      timel = time  - mean_time_start

c     ############################################################
C       if (istep.ne.0 .and. 
C      &    mod(istep,int(iostep_2d_avg_time)).eq.0) then
      if (istep.ne.0 .and. if_write_means.eq.1) then
c     spanwise averaging
        do i =1,12
          call planar_avg(suxm(1,1,1,1,i),ruxm(1,1,1,1,i),igs_x) !x averaging
          call x_slice2(suxm(1,1,1,1,i),w1)     !x_slice2 and 3 take an slice on the yz plane. They are both needed to avoid unnnecessary memory declarations on all procceses
          if (nid.eq.0) call x_slice3(suxm_2d(1,1,1,1,i))
          call planar_avg(sux2(1,1,1,1,i),rux2(1,1,1,1,i),igs_x) !x averaging
          call x_slice2(sux2(1,1,1,1,i),w1)
          if (nid.eq.0) call x_slice3(sux2_2d(1,1,1,1,i))
        enddo
        do i =1,6
          call planar_avg(suvm(1,1,1,1,i),ruvm(1,1,1,1,i),igs_x) !x averaging
          call x_slice2(suvm(1,1,1,1,i),w1)
          if (nid.eq.0)  call x_slice3(suvm_2d(1,1,1,1,i))
          call planar_avg(sv2u(1,1,1,1,i),rv2u(1,1,1,1,i),igs_x) !x averaging
          call x_slice2(sv2u(1,1,1,1,i),w1)
          if (nid.eq.0)   call x_slice3(sv2u_2d(1,1,1,1,i))
        enddo
        do i =1,4
          call planar_avg(summ(1,1,1,1,i),rumm(1,1,1,1,i),igs_x) !x averaging
          call x_slice2(summ(1,1,1,1,i),w1)
          if (nid.eq.0)call x_slice3(summ_2d(1,1,1,1,i))
          call planar_avg(su2m(1,1,1,1,i),ru2m(1,1,1,1,i),igs_x) !x averaging
          call x_slice2(su2m(1,1,1,1,i),w1)
          if (nid.eq.0)call x_slice3(su2m_2d(1,1,1,1,i))
          call planar_avg(su3m(1,1,1,1,i),ru3m(1,1,1,1,i),igs_x) !x averaging
          call x_slice2(su3m(1,1,1,1,i),w1)
          if (nid.eq.0)call x_slice3(su3m_2d(1,1,1,1,i))
          call planar_avg(spmm(1,1,1,1,i),rpmm(1,1,1,1,i),igs_x) !x averaging
          call x_slice2(spmm(1,1,1,1,i),w1)
          if (nid.eq.0)call x_slice3(spmm_2d(1,1,1,1,i))
        enddo
        call nekgsync()
          if (param(15).ne.0) then !write control -> numsteps
            call output_means(atime,timel,dtime,w4,istep)
          else
            call output_means(atime,timel,dtime,w4,counter_mean)
          endif
      endif !(istep.gt.0 .and. mod(istep,int(iostep_2d_avg_time)).eq.0)


      return
      end

c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)

      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      include 'NEKNEK'

c     ############################################################
c     INFLOW FROM INTERPOLATED EXTERNAL FILE
      parameter(nel_slab = nelxin*nelyin)

      common /inflow_pl/ vxin_pl(lx1,ly1,nel_slab)
     $                  ,vyin_pl(lx1,ly1,nel_slab)
     $                  ,vzin_pl(lx1,ly1,nel_slab)
     $                  ,tin_pl(lx1,ly1,nel_slab)

      common /pml/ ewcalc, if_pml

      real ewfac
      integer e,mixy, itmul
      real theta1,chr,shr,zh1,z_real, x_tan, xlen,dumm,tdumm,tmul
      integer ex,ey,ez


c     VS*GRAD(TEMP) BC VARIABLES
      real sn(3)
      common /VS_VEC/ vs(3)

      common /erosion/ E_s(lx1,lz1,lelx,lelz)

      common /eta_mvbc/ umeshx(lx1,ly1,lz1,lelv)
     &              , umeshy(lx1,ly1,lz1,lelv)
     &              , umeshz(lx1,ly1,lz1,lelv)
     &              , rhs(lx1,lz1,lelx,lelz)

      e = gllel(ieg)

      call get_exyz(ex,ey,ez,ieg,lelx,lely,lelz)

      ux   = 0.
      uy   = 0.
      uz   = 0.
      temp = 0.
      if (if_pml.eq.0) then
        ewfac = -1.0*UTARGET        
      elseif (if_pml.eq.2) then
        ewfac = ewcalc          
      endif
      itmul=int(time/8.0)
      tdumm=time-itmul*8.0
      tmul=1.0
      if (time.gt.time_inflow) tmul=0.0
C       if (tdumm.gt.4.0) then
C        tdumm=tdumm-4.0
C        tmul=0.0
C        if (tdumm.lt.0.5) tmul= 1.0-2.0*tdumm
C       endif

c     ############################################################
c     STABILIZED OUTFLOW Dong et all JCP
C       if (cbu.eq.'o  ') then
C          U0 = 1.0                  ! characteristic velocity
C          delta = 0.1               ! small positive constant
C          pa = dongOutflow(ix,iy,iz,e,iside,U0,delta)
C       endif

c     ############################################################
c     INFLOW FROM INTERPOLATED EXTERNAL FILE
      theta1=0.0
      if (MESH_SLOPE) theta1=atan(1.0/RITAU)
      chr=cos(theta1)
      shr=sin(theta1)

      zh1=aint(NUMBER_ELEMENTS_Z/ratiozh)*ZLEN/NUMBER_ELEMENTS_Z !break

      x_tan=1.0
      if (IF_FAN) then
        xlen=xlen_inflow*(2.0*nelsides/(1.0*nelxin)+1)
        dumm=(xlen-xlen_inflow)/2.0
        dumm=x-dumm
        xlen=xlen_inflow/2.0
        if (dumm.le.xlen) dumm=xlen_inflow-dumm
        x_tan=tanh(4.0*dumm)
      endif

      if (if_pml.eq.1) then
        if (ifield .eq. 1) then               ! velocity
          if(ieg.le.nel_slab.and.iside.eq.5) then
            ux  = vxin_pl(ix,iy,ieg)
            uy  = vyin_pl(ix,iy,ieg)*chr-vzin_pl(ix,iy,ieg)*shr
            uz  = vzin_pl(ix,iy,ieg)*chr+vyin_pl(ix,iy,ieg)*shr
          endif
        elseif (ifield .eq. 2) then     !temperature
          temp = 0.0
          if (ieg.le.nel_slab.and.iside.eq.5) then  
            temp  = tin_pl(ix,iy,ieg)
          endif
        endif
      else
        zstart = 0                    !<----------------------CHANGE
        zstart1 = zstart + 1.         !<----------------------CHANGE
        zendbr = zh1 +10
        zendbr1 =zendbr +10
        zend = ZLEN
        zend1 = zend - 1.             !<----------------------CHANGE
        z_real =(AINT(z*100.0)/100.0)

        if (ifield .eq. 1) then               ! velocity
          if (iside.eq.3) then
              ux = 0.0
c           This coflow is only for the top wall of the domain
              if (z_real.ge.zstart.and.z_real.le.zstart1) then
                uy= ((z-zstart-1.)**8 - 1.)*ewfac
              elseif (z_real.ge.zstart1.and.z_real.le.zendbr) then
                uy= (-1)*ewfac
              elseif(z_real.ge.zendbr.and.z_real.le.zendbr1) then
                uy=(((z-zendbr1)/(zendbr1-zendbr)+1.)**1 - 1.)*
     &             ewfac*(1.-1.0/ratio_top_uy)
     &             -(ewfac/ratio_top_uy)
              elseif (z_real.ge.zendbr1.and.z_real.le.zend1) then
                uy= (-1)*(ewfac/ratio_top_uy)
              elseif (z_real.ge.zend1.and.z_real.le.zend) then
                uy= ((z-zend+1.)**8 - 1.)*(ewfac/ratio_top_uy)
              endif
              uz = 0.0
          elseif(ey.le.nelyin.and.ex.gt.nelsides
     &      .and.ex.le.(nelsides+nelxin).and.iside.eq.5) then
            if (.true.) then
              mixy=(ey-1)*nelxin+ex-nelsides
              ux  = tmul*x_tan*vxin_pl(ix,iy,mixy)
              uy  = tmul*x_tan*(vyin_pl(ix,iy,mixy)*chr-
     &                     vzin_pl(ix,iy,mixy)*shr)
              uz  = tmul*x_tan*(vzin_pl(ix,iy,mixy)*chr+
     &                     vyin_pl(ix,iy,mixy)*shr)
            else 
              ux=0.0
              uy=0.0
              uz=0.0
            endif
          endif

        elseif (ifield .eq. 2) then     !temperature
          temp = 0.0
          if(ey.le.nelyin.and.ex.gt.nelsides
     &      .and.ex.le.(nelsides+nelxin).and.iside.eq.5) then
            if (.true.) then
              mixy=(ey-1)*nelxin+ex-nelsides
            temp  = tmul*tin_pl(ix,iy,mixy)
            else
              temp=0.0
            endif
          endif
        endif
      endif
c     ############################################################
c     BOTTOM TEMP BC 
      if (V_SETTLING.ne.0 .and. BC_FLAG_TEMP.eq.1) then
        call getSnormal(sn,ix,iy,iz,iside,e)
c     Compute hc for Newton cooling BC, bypass mode BC
c     (1/Pe)*grad(T) dot n = (Vs*T) dot n
        hc = (-1)*(vs(1)*sn(1) + vs(2)*sn(2) + vs(3)*sn(3))
      endif
      if (V_SETTLING.ne.0 .and. BC_FLAG_TEMP.eq.2) then
        call getSnormal(sn,ix,iy,iz,iside,e)
c     Compute flux for flux BC, Erosion mode BC
c     (1/Pe)*grad(T) dot n = -|Vs*E_s| dot n
        flux=0.0
      if (z .lt. ZLEN-2*(ZLEN-ZBUFF) ) then  !things get messy near the increased viscosity outlet
        flux = (-1.0)*abs(E_s(ix,iz,ex,ez)*sn(1) +E_s(ix,iz,ex,ez)*sn(2)
     &   + E_s(ix,iz,ex,ez)*sn(3))
      endif
      endif
c     #########################################################
c     MOVING MESH
c     Bottom velocity BC
      if (cbc(iside,e,1).eq.'mv ') then
          ux = umeshx(ix,iy,iz,e)
          uy = umeshy(ix,iy,iz,e)
          uz = umeshz(ix,iy,iz,e)
      endif

      return
      end

      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      ux = 0.0
      uy = 0.0
      uz = 0.0
      temp = 0.0



      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
      include 'SIZE'
      include 'TOTAL'
      
      integer n,nelytot,mmnely
      real hfh,hfint,amp,delyi,rrleny,rrlenyint,y,z, sp
      real theta1, theta2, A1, A2, zh1, zh2, anint
      real deltz1, deltz0
      integer nz_break

      common /pml/ ewcalc, if_pml

      if (UTARGET .eq. 0.0)then
        if_pml=2
      elseif (UTARGET .gt. 0.0) then
        if_pml=1
      elseif (UTARGET .lt. 0.0) then
        if_pml=0
      endif

      theta1=atan(1/RITAU)
      theta2=atan(1/RITAU2)
      nz_break=aint(NUMBER_ELEMENTS_Z/ratiozh)
      zh1=aint(NUMBER_ELEMENTS_Z/ratiozh)*ZLEN/NUMBER_ELEMENTS_Z
      zh2=ZLEN-zh1
      A1=zh1/RITAU   !zh*tan(theta)
      A2=zh2/RITAU2
C       A1=0
C       A2=0
      n=8*nelt
c
      nelytot = NUMBER_ELEMENTS_Y

      delyi =hf/nelyin
      rrleny = nelytot*delyi 
      rrlenyint = nelyint*delyi
      hfh=hf/2.0
      hfint = rrlenyint
      amp=ASINH(((hint-hf)/hint)*SINH(-3.25))/((hf/rrlenyint-1.0)*3.25)
      sp=3.25


c     vertical grid spacing      
      do i=1,n
        yc(i,1)  = rrleny * yc(i,1) 
        y=yc(i,1)

        if ((AINT(y*100.0)/100.0).le.hfh) then
          yc(i,1) = (-1)*(1-SINH(sp*y)/SINH(sp))+1
        elseif ((AINT(y*100.0)/100.0).le.hf) then
          yc(i,1) = (1)*(1 - SINH(sp*(2-y))/SINH(sp))+1
        elseif ((AINT(y*100.0)/100.0).le.hfint) then
          y = y / rrlenyint
          yc(i,1)= (hint*SINH(3.25*amp*(hf/rrlenyint-y))/SINH(-3.25))+2
        elseif ((AINT(y*100.0)/100.0).gt.hfint) then
              yc(i,1)=(y-hfint)*(YLEN-hint)/(rrleny-hfint)+hint
C             y=(y-hfint)/(rrleny-hfint)
C             yc(i,1)=y*(YLEN-hfint)+hfint
        endif
        xc(i,1) =  xlen_inflow*(2.0*nelsides/(1.0*nelxin)+1) * xc(i,1)
        zc(i,1) = ZLEN * zc(i,1)
      enddo

      if (nhighz.ne.0) then
        deltz1=ZLEN/(1.0*NUMBER_ELEMENTS_Z-1.0*nhighz/2.0)
        deltz0=ZLEN/NUMBER_ELEMENTS_Z
        do i=1,n
          z=zc(i,1)
          if ((AINT(z*100.0)/100.0).le.(deltz0*(nz_break-nhighz/2)))then
            zc(i,1)=z*(zh1-nhighz/4*deltz1)/((nz_break-nhighz/2)*deltz0)
          elseif((AINT(z*100.0)/100.0).le.(deltz0*(nz_break+nhighz/2)))
     &          then
            zc(i,1)=0.5*(deltz1/deltz0)*(z-(nz_break-nhighz/2)
     &              *deltz0)+zh1-nhighz*deltz1/4
          else
            zc(i,1)=(ZLEN-zh1+nhighz*deltz0/4)/
     &              (ZLEN-(nhighz*deltz1/2))*
     &              (z-(nz_break+nhighz/2)*deltz0)
     &              +zh1+nhighz*deltz1/4
          endif
        enddo
      endif

c     sloping
      if (MESH_SLOPE) then
      if(nid.eq.0) write(*,*) 'Deforming mesh for sloping.....'
      if(nid.eq.0 .and.RITAU.ne.RITAU2) write(*,*) 'Slope break at ',zh1
      do i=1,n
        y=yc(i,1)
        z=zc(i,1)
        if((AINT(z*100.0)/100.0).lt.zh1) then
          if((AINT(y*100.0)/100.0).le.hint) then
            yc(i,1)=y+A1*((-1.0/zh1)*z+1)+A2
          else
            yc(i,1)=y+((-A1/(YLEN-hint))*(y-hint)+A1)*
     &                ((-1.0/zh1)*z+1)+
     &                ((-A2/(YLEN-hint))*(y-hint)+A2)
          endif !(y.le.hfint)
        else
          if((AINT(y*100.0)/100.0).le.hint) then
            yc(i,1)=y+A2*((-1.0/zh2)*(z-zh1)+1)
          else
            yc(i,1)=y+((-A2/(YLEN-hint))*
     &         (y-hint)+A2)*((-1.0/zh2)*
     &                (z-zh1)+1)
          endif !(y.le.hfint)
        endif !(z.lt.zh)
      enddo
      endif

      return
      end
      subroutine usrdat2
      include 'SIZE'
      include 'TOTAL'
      parameter (llt=lx1*ly1*lz1*lelt)
      common /cmygeom/ xmo(llt),ymo(llt),zmo(llt)

      param(59) = 1 

      if (UTARGET.le.0.)then  !change top BC from O to v
          ifc=3 !top face, if it was generated by genbox
          do iel=1,nelt
             if (cbc(ifc,iel,1) .eq. 'O  ') cbc(ifc,iel,1) = 'v  '
          enddo
      endif

      if (V_SETTLING.ne.0 .and. BC_FLAG_TEMP.eq.1) then !change bottom temp BC from I to c
          ifc=1 !bottom face, if it was generated by genbox
          do iel=1,nelt
             if (cbc(ifc,iel,2) .eq. 'I  ') cbc(ifc,iel,2) = 'c  '
          enddo
      endif
      if (V_SETTLING.ne.0 .and. BC_FLAG_TEMP.eq.2) then !change bottom temp BC from I to f
          ifc=1 !bottom face, if it was generated by genbox
          do iel=1,nelt
             if (cbc(ifc,iel,2) .eq. 'I  ') cbc(ifc,iel,2) = 'f  '
          enddo
      endif

      if (IF_FAN) then  !change spanwises BC's from P to O
          ifc=2 !left face, if it was generated by genbox
          do iel=1,nelt
             if (cbc(ifc,iel,1) .eq. 'P  ') cbc(ifc,iel,1) = 'O  '
          enddo
          ifc=4 !right face, if it was generated by genbox
          do iel=1,nelt
             if (cbc(ifc,iel,1) .eq. 'P  ') cbc(ifc,iel,1) = 'O  '
          enddo
      endif

      if (IF_MVMESH) then  !change bottom BC from W to mv
          ifc=1 !bottom face, if it was generated by genbox
          do iel=1,nelt
             if (cbc(ifc,iel,1) .eq. 'W  ') cbc(ifc,iel,1) = 'mv '
          enddo
          ifxyo     = .true.
          ifmvbd    = .true.  ! moving boundary
          ifusermv  = .true.  ! define our own mesh velocity
      endif

      call opcopy(xmo,ymo,zmo,xm1,ym1,zm1)  ! Preserve my geometry
c
      return
      end
      
c-----------------------------------------------------------------------
      subroutine usrdat3
      include 'SIZE'
      include 'TOTAL'
c
      parameter (llt=lx1*ly1*lz1*lelt)
      common /cmygeom/ xmo(llt),ymo(llt),zmo(llt)

      call opcopy(xm1,ym1,zm1,xmo,ymo,zmo)  ! Restore my geometry
      call geom_reset(1)                    ! Force regen. of Jacobians 
      call prinit
      return
      end

c-----------------------------------------------------------------------
      subroutine planar_inflow(ua,u,mnelin,w1)
c
c     Compute r-s planar average of quantity u()
c
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
c
      integer e,eg,mnelin,nxyin
      real u(nx1*ny1,mnelin),aindum(nx1*ny1,mnelin)
      real ain(nx1*ny1,mnelin),ua,uadum,w1,w1dum
      integer ex,ey,ez,ieg
c
c     As the numbering of elements in a single box
c     go in the order of r-s-t (first fill r, then 
c     s and then t) the ordering of the 2d elements 
c     in u (2d inlet) is the same as the first 
c     t-plane of elements in the 3d box. Hence,
c     face 5 of the first mnelin elements of the 
c     3dbox have the same area as the 2d inlet.

      nxyin = nx1*ny1*mnelin
      call rzero(ain,nxyin)
      call rzero(aindum,nxyin)
      if(nelsides.ne.0) then
        do e=1,nelt
c        l local gl global el element
           eg = lglel(e)
           call get_exyz(ex,ey,ez,eg,lelx,lely,lelz)
           if (ey.le.nelyin.and.ex.gt.nelsides
     &      .and.ex.le.(nelsides+nelxin)) then
             do i=1,nx1*ny1
                ieg=(ey-1)*nelxin+ex-nelsides
                aindum(i,ieg) = area(i,1,5,e)
             enddo
           endif
        enddo
        call gop(aindum,ain,'+  ',nxyin)
      else
        do e=1,nelt
c        l local gl global el element
           eg = lglel(e)
           if (eg.le.mnelin) then
             do i=1,nx1*ny1
                aindum(i,eg) = area(i,1,5,e)
             enddo
           endif
        enddo
        call gop(aindum,ain,'+  ',nxyin)
      endif

      ua=0.0
      uadum=0.0
      w1=0.0
      w1dum=0.0
      if (nid.eq.0) then
       do e=1,mnelin
          do i=1,nx1*ny1
            w1dum = w1dum + ain(i,e)
            uadum = uadum + ain(i,e)*u(i,e)
          enddo
       enddo
       uadum = uadum / w1dum ! Normalize

      endif
      call gop(uadum,ua,'+  ',1)      
      call gop(w1dum,w1,'+  ',1)      


      return
      end

c----------------------------------------------------------------
      subroutine interpolateinflow(vxin,vyin,vzin,tin
     $           ,vxin_pl,vyin_pl,vzin_pl,tin_pl
     $           ,nelin,nel_slab,nelzin1,z_inflow,rlenz
     $          ,dtimestep,restart_inflow1)

      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      integer step_inflow,nelzin1,nel_slab,nelin
      integer restart_inflow1
      real rlenz,z_inflow,dz_inflow
      real dtimestep

      real vxin(lx1,ly1,lz1,nelin)
     $    ,vyin(lx1,ly1,lz1,nelin)
     $    ,vzin(lx1,ly1,lz1,nelin)
     $    ,tin(lx1,ly1,lz1,nelin)

      real vxin_pl(lx1,ly1,nel_slab)
     $    ,vyin_pl(lx1,ly1,nel_slab)
     $    ,vzin_pl(lx1,ly1,nel_slab)
     $    ,tin_pl(lx1,ly1,nel_slab)



      real zz(nz1,nelz),w1(nz1,nelz),w2(nz1,nelz)
      real zzin(nz1,nelzin1)
      integer nzin,flagin,e,m

      real vzinavg,uadum,w1in,z_sup,z_inf
      integer k_sup,k_inf,ez_in,e_pl

      real vxin_pl_dum(lx1,ly1,nel_slab)
     $    ,vyin_pl_dum(lx1,ly1,nel_slab)
     $    ,vzin_pl_dum(lx1,ly1,nel_slab)
     $    ,tin_pl_dum(lx1,ly1,nel_slab)

      real z_inflow_dum

c     ---------------------------------------------------------
      m = nx1*ny1*nel_slab
      call planar_average_z(zz,zm1,w1,w2)
      nzin=nelzin1*nz1
      call copy(zzin,zz,nzin)
      if (istep.eq.0.and.restart_inflow1.eq.0) then
c        This part could be done only by nid.eq.0 
c        but I'm tired of coding (JS)
         z_inflow = rlenz
         do e=1,nel_slab
          e_pl = nel_slab*(nelzin1-1) + e
          do j=1,ny1
            do i=1,nx1
              vxin_pl(i,j,e) = vxin(i,j,nz1,e_pl)
              vyin_pl(i,j,e) = vyin(i,j,nz1,e_pl)
              vzin_pl(i,j,e) = vzin(i,j,nz1,e_pl)
              tin_pl(i,j,e) = tin(i,j,nz1,e_pl)
            enddo
          enddo
         enddo

      elseif (istep.eq.0.and.restart_inflow1.eq.1) then
c       This part has to be done by only nid.eq.0
c       (could generate reading issues otherwise)
        z_inflow = 0.0
        z_inflow_dum = 0.0
        call rzero(vxin_pl,m)
        call rzero(vyin_pl,m)
        call rzero(vzin_pl,m)
        call rzero(tin_pl,m)
        call rzero(vxin_pl_dum,m)
        call rzero(vyin_pl_dum,m)
        call rzero(vzin_pl_dum,m)
        call rzero(tin_pl_dum,m)
        if (nid.eq.0) then
          write(*,*)'###### READING 2D INFLOW FILE FOR RESTART ####'
          open(unit=58,file='inflow2d.ini',access='stream',
     &       form='unformatted')
          read(58) z_inflow_dum
          read(58) vxin_pl_dum,vyin_pl_dum,vzin_pl_dum,tin_pl_dum
          close(58)
          write(*,*)'FILE: inflow2d.ini'
          write(*,*)'###### READING 2D INFLOW FILE FOR RESTART DONE ###'
        endif
        call gop(z_inflow_dum,z_inflow,'+  ',1)
        call gop(vxin_pl_dum,vxin_pl,'+  ',m)
        call gop(vyin_pl_dum,vyin_pl,'+  ',m)
        call gop(vzin_pl_dum,vzin_pl,'+  ',m)
        call gop(tin_pl_dum,tin_pl,'+  ',m)

      elseif (istep.gt.0) then
c        This part could be done only by nid.eq.0 
c        but I'm tired of coding 
        call planar_inflow(vzinavg,vzin_pl,nel_slab,w1in)

        dz_inflow = dtimestep * vzinavg
        if (z_inflow.lt.dz_inflow) then
          z_inflow = rlenz - (dz_inflow - z_inflow)
        else
          z_inflow = z_inflow - dz_inflow
        endif

        flagin=0
        do e=nelzin1,1,-1
          do k=nz1,1,-1
            if (z_inflow.gt.zzin(k,e).and.flagin.eq.0) then
              z_sup = zzin(k+1,e)
              z_inf = zzin(k,e)
              k_sup = k+1
              k_inf = k
              ez_in = e
              flagin=1
            endif
          enddo
        enddo

        do e=1,nel_slab
          e_pl = nel_slab*(ez_in-1) + e
          do j=1,ny1
            do i=1,nx1
              vxin_pl(i,j,e)=((vxin(i,j,k_sup,e_pl)-
     $                       vxin(i,j,k_inf,e_pl))/
     $                       (z_sup-z_inf))*
     $                       (z_inflow - z_inf) +
     $                       vxin(i,j,k_inf,e_pl)

              vyin_pl(i,j,e)=((vyin(i,j,k_sup,e_pl)-
     $                       vyin(i,j,k_inf,e_pl))/
     $                       (z_sup-z_inf))*
     $                       (z_inflow - z_inf) +
     $                       vyin(i,j,k_inf,e_pl)

              vzin_pl(i,j,e)=((vzin(i,j,k_sup,e_pl)-
     $                       vzin(i,j,k_inf,e_pl))/
     $                       (z_sup-z_inf))*
     $                       (z_inflow - z_inf) +
     $                       vzin(i,j,k_inf,e_pl)

              tin_pl(i,j,e) =((tin(i,j,k_sup,e_pl)-
     $                       tin(i,j,k_inf,e_pl))/
     $                       (z_sup-z_inf))*
     $                       (z_inflow - z_inf) +
     $                       tin(i,j,k_inf,e_pl)
            enddo
          enddo
        enddo

      endif

      return
      end

c-----------------------------------------------------------------------

      subroutine x_slice (ua,u,w1,w2)
c
c     Extract a x slice of quantity u() - assumes global tens.prod.
c
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
c
      real ua(ny1,nz1,nely,nelz),u(nx1,ny1,nz1,nelt),
     $     w1(ny1,nz1,nely,nelz),w2(ny1,nz1,nely,nelz)
      integer e,eg,ex,ey,ez
      real dy2
c
      myz = nely*nelz*ny1*nz1
      call rzero(ua,myz)
c
      do e=1,nelt
c
         eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)

         i = 1
         if (ex.eq.1) then
            do k=1,nz1
            do j=1,ny1
               ua(j,k,ey,ez) = u(i,j,k,e)
            enddo
            enddo
         endif
      enddo

      call gop(ua,w2,'+  ',myz)

      return
      end

      subroutine x_slice2 (u,w1)
c
c     Extract a x slice of quantity u() - assumes global tens.prod.
c     It doesn't return the result. 
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
c
      real u(nx1,ny1,nz1,nelt),
     $     w1(ny1,nz1,nely,nelz)
      integer nst,ist
      integer e,eg,ex,ey,ez
      real dy2
C       real ua(ny1,nz1,nely,nelz)
      common /xslice2/
     &   ua(ly1,lz1,lely,lelz)
c
      myz = nely*nelz*ny1*nz1
      call rzero(ua,myz)
c
      do e=1,nelt
c
         eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)

         i = 1
         if (ex.eq.1) then
            do k=1,nz1
            do j=1,ny1
               ua(j,k,ey,ez) = u(i,j,k,e)
            enddo
            enddo
         endif
      enddo

      call gop(ua,w1,'+  ',myz)

      return
      end

      subroutine x_slice3 (ua2)
c
c     Extract a x slice of quantity u() - assumes global tens.prod.
c     It must be called RIGHT AFTER x_slice2
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
c
      real ua2(ny1,nz1,nely,nelz)
      integer e,eg,ex,ey,ez
      real dy2
      common /xslice2/
     &   ua(ly1,lz1,lely,lelz)

c
      myz = nely*nelz*ny1*nz1
      call rzero(ua2,myz)

      call copy(ua2,ua,myz)
      return
      end
c---------------------------------------------------------------------      
      subroutine y_line (ua,u,w1,w2)
c
c     Extract a y line of quantity u() - assumes global tens.prod.
c
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
c
      real ua(ny1,nely),u(nx1,ny1,nz1,nelv)
     $    ,w1(ny1,nely),w2(ny1,nely)
      integer e,eg,ex,ey,ez
      real dy2
c
      my = nely*ny1
      call rzero(ua,my)
c
      do e=1,nelt
c
         eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
         i = 1
         k = 1
         if (ex.eq.1 .and. ez.eq.1) then
            do j=1,ny1
               ua(j,ey) = u(i,j,k,e)
            enddo
         endif
      enddo
      call gop(ua,w2,'+  ',my)

      return
      end
c--------------------------------------------------------------------- 
      subroutine yslab (ua,u,w1,nslab,nely_in)
c
c     Extract a y line of quantity u() - assumes global tens.prod.
c
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
c
      real ua(nslab),u(nx1,ny1,nz1,nelv)
     $    ,w1(nslab)
      integer e,eg,ex,ey,ez
      real dy2
c
C       my = nely*ny1
      call rzero(ua,nslab)
c
      do e=1,nelt
c
         eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
         i = 1
         k = 1
         if (ex.eq.1 .and. ez.eq.1.and. ey.le.nely_in) then
            do j=1,ny1
               ua(j+ey*ny1-ny1) = u(i,j,k,e)-u(1,1,1,1)
            enddo
         endif
      enddo
      call gop(ua,w1,'+  ',nslab)

      return
      end     
    
      subroutine y_slice (ua,u,w1)
c
c     Extract the bottom y slice of quantity u() - assumes global tens.prod.
c
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
c
      real ua(nx1,nz1,nelx,nelz),u(nx1,ny1,nz1,nelt),
     $     w1(nx1,nz1,nelx,nelz)
      integer e,eg,ex,ey,ez, mxz
      real dy2
c
      mxz = nelx*nelz*nx1*nz1
      call rzero(ua,mxz)
      call rzero(w1,mxz)
c
      do e=1,nelt
c
         eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)

         j = 1
         if (ey.eq.1) then
            do k=1,nz1
            do i=1,nx1
               ua(i,k,ex,ez) = u(i,j,k,e)
            enddo
            enddo
         endif
      enddo

      call gop(ua,w1,'+  ',mxz)

      return
      end


c     ############################################################
      subroutine output_inflow_pl(vxin_pl,vyin_pl,vzin_pl,tin_pl
     $                           ,nel_slab,z_inflow,counter)
c
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real z_inflow
      integer nel_slab,counter

      real vxin_pl(lx1,ly1,nel_slab)
     $    ,vyin_pl(lx1,ly1,nel_slab)
     $    ,vzin_pl(lx1,ly1,nel_slab)
     $    ,tin_pl(lx1,ly1,nel_slab)

      character*80 istepc_inflow,icfile_inflow
c    ----------------------------------------------------------
      if (nid.eq.0) then
        if(param(15).ne.0) then 
          write(istepc_inflow,'(i32)') istep
        else
          write(istepc_inflow,'(i32)') counter
        endif
        istepc_inflow=adjustl(istepc_inflow)
        icfile_inflow=trim('inflow2d'//'.'//trim(istepc_inflow))
        open(unit=58,file=icfile_inflow,access='stream',
     &     form='unformatted')
        write(58) z_inflow
        write(58) vxin_pl,vyin_pl,vzin_pl,tin_pl
        close(58)
      endif

      return
      end
c----------------------------------------------------------------------

      subroutine read_inflow(vxin,vyin,vzin,tin,nelin,nin)

      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      integer nelin,nin

      real vxin(lx1,ly1,lz1,nelin)
     $    ,vyin(lx1,ly1,lz1,nelin)
     $    ,vzin(lx1,ly1,lz1,nelin)
     $    ,tin(lx1,ly1,lz1,nelin)


      real dum(nx1,ny1,nz1,nelin)
      character*80 icfile
c     -----------------------------------------------------

      call rzero(vxin,nin)
      call rzero(vyin,nin)
      call rzero(vzin,nin)
      call rzero(tin,nin)

c      Zero all dummy arrays
       call rzero(dum,nin)
       call rzero(vxin,nin)
       call rzero(vyin,nin)
       call rzero(vzin,nin)
       call rzero(tin,nin)
c      Read IC file
      if (nid.eq.0) then
         icfile=trim('vx_inflow.ini')
         write(*,*)'*****READING INFLOW FILE: ',icfile
         open(unit=58,file=icfile,access='stream',form='unformatted')
         read(58) vxin
         close(58)
         icfile=trim('vy_inflow.ini')
         write(*,*)'*****READING INFLOW FILE: ',icfile
         open(unit=58,file=icfile,access='stream',form='unformatted')
         read(58) vyin
         close(58)
         icfile=trim('vz_inflow.ini')
         write(*,*)'*****READING INFLOW FILE: ',icfile
         open(unit=58,file=icfile,access='stream',form='unformatted')
         read(58) vzin
         close(58)
         icfile=trim('temp_inflow.ini')
         write(*,*)'*****READING INFLOW FILE: ',icfile
         open(unit=58,file=icfile,access='stream',form='unformatted')
         read(58) tin
         close(58)
      endif
c     Add through all processors  
      call gop(vxin,dum,'+  ',nin)
      call gop(vyin,dum,'+  ',nin)
      call gop(vzin,dum,'+  ',nin)
      call gop(tin,dum,'+  ',nin)

      return
      end

c-----------------------------------------------------------------------
      subroutine planar_average_z(ua,u,w1,w2)
c
c     Compute r-s planar average of quantity u() USED IN INTERPOLATE INFLOW
c
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
c
      real ua(nz1,nelz),u(nx1*ny1,nz1,nelv),w1(nz1,nelz),w2(nz1,nelz)
      integer e,eg,ez
c
      melxy = nelx*nely
c
      nz = nz1*nelz
      call rzero(ua,nz)
      call rzero(w1,nz)
c
      do e=1,nelt
c
         eg = lglel(e)
         ez = 1 + (eg-1)/melxy
c
         do k=1,nz1
         do i=1,nx1*ny1
            zz = (1.-zgm1(k,3))/2.  ! = 1 for k=1, = 0 for k=nz1
            aa = zz*area(i,1,5,e) + (1-zz)*area(i,1,6,e)  ! wgtd jacobian
            w1(k,ez) = w1(k,ez) + aa
            ua(k,ez) = ua(k,ez) + aa*u(i,k,e)
         enddo
         enddo
      enddo
c
      call gop(ua,w2,'+  ',nz)
      call gop(w1,w2,'+  ',nz)
c
      do i=1,nz
         ua(i,1) = ua(i,1) / w1(i,1)   ! Normalize
      enddo
c
      return
      end

       subroutine output_means(atime,timel,dtime,w4,name)

       include 'SIZE'
       include 'TOTAL'
       include 'ZPER'

       real atime,timel,dtime
       character*80 icfile,istepc
       real w4(ly1,lz1,lely,lelz)
       integer name

      common /avgstats/
     &  rumm(lx1,ly1,lz1,lelt,4)
     & , ru2m(lx1,ly1,lz1,lelt,4)
     & , ruvm(lx1,ly1,lz1,lelt,6)
     & , ruxm(lx1,ly1,lz1,lelt,12)
     & , rux2(lx1,ly1,lz1,lelt,12)
     & , ru3m(lx1,ly1,lz1,lelt,4)
     & , rv2u(lx1,ly1,lz1,lelt,6)
     & , rpmm(lx1,ly1,lz1,lelt,4)
     & , summ(lx1,ly1,lz1,lelt,4)
     & , su2m(lx1,ly1,lz1,lelt,4)
     & , suvm(lx1,ly1,lz1,lelt,6)
     & , suxm(lx1,ly1,lz1,lelt,12)
     & , sux2(lx1,ly1,lz1,lelt,12)
     & , su3m(lx1,ly1,lz1,lelt,4)
     & , sv2u(lx1,ly1,lz1,lelt,6)
     & , spmm(lx1,ly1,lz1,lelt,4)
     & , summ_2d(ly1,lz1,lely,lelz,4)
     & , su2m_2d(ly1,lz1,lely,lelz,4)
     & , suvm_2d(ly1,lz1,lely,lelz,6)
     & , suxm_2d(ly1,lz1,lely,lelz,12)
     & , sux2_2d(ly1,lz1,lely,lelz,12)
     & , su3m_2d(ly1,lz1,lely,lelz,4)
     & , sv2u_2d(ly1,lz1,lely,lelz,6)
     & , spmm_2d(ly1,lz1,lely,lelz,4)


       m=ny1*nz1*lely*lelz
       if(nid.eq.0) then
          write(*,*)'*********Writing statistics.......*********'
          write(istepc,'(i32)') name
          istepc=adjustl(istepc)
          icfile=trim('means.'//trim(istepc))
          open(unit=58,file=icfile,access='stream',form='unformatted')
          write(58) (time-mean_time_start),atime,timel,dtime
          write(58) int(nx1),int(lelx),int(lely),int(lelz)
          do i=1,4
            call copy(w4,summ_2d(1,1,1,1,i),m)
            write(58) w4
          enddo
          do i=1,4
            call copy(w4,su2m_2d(1,1,1,1,i),m)
            write(58) w4
         enddo
          do i=1,6
            call copy(w4,suvm_2d(1,1,1,1,i),m)
            write(58) w4
          enddo
          do i=1,12
            call copy(w4,suxm_2d(1,1,1,1,i),m)
            write(58) w4
          enddo
          do i=1,12
            call copy(w4,sux2_2d(1,1,1,1,i),m)
            write(58) w4
          enddo
          do i=1,4
            call copy(w4,su3m_2d(1,1,1,1,i),m)
            write(58) w4
         enddo
         do i=1,6
            call copy(w4,sv2u_2d(1,1,1,1,i),m)
            write(58) w4
         enddo
         do i=1,4
            call copy(w4,spmm_2d(1,1,1,1,i),m)
            write(58) w4
         enddo
          close(58)
       endif
       return
       end


      subroutine input_means()
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real w4(ly1,lz1,lely,lelz)
      integer dumm
      real dumr

      common /avgstats_old/
     &  summ_2d_o(ly1,lz1,lely,lelz,4)
     & , su2m_2d_o(ly1,lz1,lely,lelz,4)
     & , suvm_2d_o(ly1,lz1,lely,lelz,6)
     & , suxm_2d_o(ly1,lz1,lely,lelz,12)
     & , sux2_2d_o(ly1,lz1,lely,lelz,12)
     & , su3m_2d_o(lx1,ly1,lely,lelz,4)
     & , sv2u_2d_o(lx1,ly1,lely,lelz,6)
     & , spmm_2d_o(lx1,ly1,lely,lelz,4)
     & ,timem,atimem,timelm,dtimem,t_tot

      m=ny1*nz1*lely*lelz

      call rzero(summ_2d_o,size(summ_2d_o))
      call rzero(su2m_2d_o,size(su2m_2d_o))
      call rzero(suvm_2d_o,size(suvm_2d_o))
      call rzero(suxm_2d_o,size(suxm_2d_o))
      call rzero(sux2_2d_o,size(sux2_2d_o))
      call rzero(su3m_2d_o,size(su3m_2d_o))
      call rzero(sv2u_2d_o,size(sv2u_2d_o))
      call rzero(spmm_2d_o,size(spmm_2d_o))

      if (nid.eq.0) then
         write(*,*)'*********Reading means file: means.ini....*********'
         open(unit=58,file='means.ini',access='stream',
     &     form='unformatted')
         read(58) timem,atimem,timelm,dtimem
         read(58) dumm,dumm,dumm,dumm
         do i=1,4
          read(58) w4
          call copy(summ_2d_o(1,1,1,1,i),w4,m)
         enddo
         do i=1,4
          read(58) w4
          call copy(su2m_2d_o(1,1,1,1,i),w4,m)
         enddo
         do i=1,6
          read(58) w4
          call copy(suvm_2d_o(1,1,1,1,i),w4,m)
         enddo
         do i=1,12
          read(58) w4
          call copy(suxm_2d_o(1,1,1,1,i),w4,m)
         enddo
         do i=1,12
          read(58) w4
          call copy(sux2_2d_o(1,1,1,1,i),w4,m)
         enddo
         do i=1,4
            read(58) w4
            call copy(su3m_2d_o(1,1,1,1,i),w4,m)
         enddo
         do i=1,6
            read(58) w4
            call copy(sv2u_2d_o(1,1,1,1,i),w4,m)
         enddo
         do i=1,4
            read(58) w4
            call copy(spmm_2d_o(1,1,1,1,i),w4,m)
         enddo
         close(58)
       endif
      do i=1,4
          call gop(summ_2d_o(1,1,1,1,i),w4,'+  ',m)
      enddo
      do i=1,4
          call gop(su2m_2d_o(1,1,1,1,i),w4,'+  ',m)
      enddo
      do i=1,6
          call gop(suvm_2d_o(1,1,1,1,i),w4,'+  ',m)
      enddo
      do i=1,12
          call gop(suxm_2d_o(1,1,1,1,i),w4,'+  ',m)
      enddo
      do i=1,12
          call gop(sux2_2d_o(1,1,1,1,i),w4,'+  ',m)
      enddo
      do i=1,4
          call gop(su3m_2d_o(1,1,1,1,i),w4,'+  ',m)
      enddo
      do i=1,6
          call gop(sv2u_2d_o(1,1,1,1,i),w4,'+  ',m)
      enddo
      do i=1,4
          call gop(spmm_2d_o(1,1,1,1,i),w4,'+  ',m)
      enddo
      call gop(atimem,dumr,'+  ',1)
      return
      end

      subroutine print_yz_mesh

      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'


      real ymm(ly1,lz1,lely,lelz),zmm(ly1,lz1,lely,lelz)

c     xmm --> yz slice; ymm --> xz slice; zmm --> xy slice  

      real w1(ly1,lz1,lely,lelz),w2(ly1,lz1,lely,lelz)


      call x_slice(ymm,ym1,w1,w2)
      call x_slice(zmm,zm1,w1,w2)

      if(nid.eq.0) then
          write(*,*)'*********Writing y-z plane mesh.......*********'
          write(istepc,'(i32)') istep
          open(unit=58,file='yzmesh.dat',
     &       access='stream',form='unformatted')
          write(58)ly1,lz1,lely,lelz
          write(58)ymm,zmm
          close(58)
      endif
      return
      end
c-----------------------------------------------------------------------

      subroutine print_xz_mesh

      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'


      real zmm(lx1,lz1,lelx,lelz),xmm(lx1,lz1,lelx,lelz)

c     xmm --> yz slice; ymm --> xz slice; zmm --> xy slice  

      real w1(lx1,lz1,lelx,lelz)


      call y_slice(zmm,zm1,w1)
      call y_slice(xmm,xm1,w1)

      if(nid.eq.0) then
          write(*,*)'*********Writing x-z plane mesh.......*********'
          write(istepc,'(i32)') istep
          open(unit=58,file='xzmesh.dat',
     &       access='stream',form='unformatted')
          write(58)lx1,lz1,lelx,lelz
          write(58)xmm,zmm
          close(58)
      endif
      return
      end

c-----------------------------------------------------------------------
      subroutine outfld2d_yz(z,y,w,v,tt,ny,nz,nly,nlz,name,ifld)

      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real z(ny,nz,nly,nlz)
      real y(ny,nz,nly,nlz)
      real v(ny,nz,nly,nlz)
      real w(ny,nz,nly,nlz)
      real tt(ny,nz,nly,nlz)
      character*3 name

      character*2  excode(15)
      character*12 fm
      character*20 outfile

c     if (istep.le.10) write(6,*) nid,' in out2d:',iz

      call blank(excode,30)
c
      excode(1) = 'X '
      excode(2) = 'Y '
      excode(3) = 'U '
c     excode(4) = 'V '
c     excode(5) = 'P '
c     excode(6) = 'T '
c
      excode(4) = '  '
      excode(5) = 'T '
C       excode(6) = 'T '
      nthings   =  6

      ierr = 0 
      if (nid.eq.0) then
         write(*,*)'******Writing spanwise-averaged fld file....*******'
         call blank(outfile,20)
         if (ifld.lt.100) then
            write(outfile,2) name,ifld
    2       format(a3,'2d.fld',i2.2)
         elseif (ifld.lt.1000) then
            write(outfile,3) name,ifld
    3       format(a3,'2d.fld',i3)
         elseif (ifld.lt.10000) then
            write(outfile,4) name,ifld
    4       format(a3,'2d.fld',i4)
         elseif (ifld.lt.100000) then
            write(outfile,5) name,ifld
    5       format(a3,'2d.fld',i5)
         elseif (ifld.lt.1000000) then
            write(outfile,6) name,ifld
    6       format(a3,'2d.fld',i6)
         endif
         open(unit=24,file=outfile,status='unknown')
         call dump_header2d(excode,ny,nz,nly,nlz,ierr)

         n = ny*nz*nly*nlz
c        write(6,*) fm
c        call exitt
C          write(24,fm) (z(i),y(i),u(i),v(i),w(i),t(i),i=1,n)

          do l=1,nlz
             do k=1,nly
                 do j=1,nz
                   do i=1,ny
                     write(24,'(1p5e14.6)') z(i,j,k,l),y(i,j,k,l),
     &                   w(i,j,k,l),v(i,j,k,l),tt(i,j,k,l)
                   enddo
                 enddo
              enddo
          enddo
c  10    format('''(1p',i1,'e15.7)''')
c  10    format(1p7e15.7)
c
         close(24)
      endif
      call err_chk(ierr,'Error using byte_write,outfld2d. Abort.$')

      return
      end

      subroutine spline(x,y,n,y2,u)
C       parameter (nmax=10000000)
C       dimension x(n),y(n),y2(n),u(n)
      real x(n),y(n),y2(n),u(n)
C       if (n.gt.nmax) then
C          write(6,11) n,nmax
C    11    FORMAT(2X,'ERROR:  Attempt to fit a spline with',I5
C      $            ,'greater than',I4,' points.'
C      $       ,/,2X,'Recompile routine SPLINE.')
C          call exitti('routine spline fail$',n)
C       endif
      y2(1)=0.0
      u(1) =0.0
      do i=2,n-1
         ir=i+1
         il=i-1
         sig=(x(i)-x(il))/(x(ir)-x(il))
         p=sig*y2(il)+2.
         y2(i)=(sig-1.)/p
         u(i)= ( 6.*
     $     ( (y(ir)-y(i))/(x(ir)-x(i))-(y(i)-y(il))/ (x(i)-x(il) ) )
     $            / (x(ir)-x(il))
     $    - sig*u(il) )/p
      enddo
      qn=0.0
      un=0.0
      y2(n)=(un-qn*u(n-1))/(qn*y2(n-1)+1.)
      do k=n-1,1,-1
         y2(k)=y2(k)*y2(k+1)+u(k)
      enddo
      return
      end

      subroutine splint(xa,ya,y2a,n,x,y)
c     p. 88-89, numerical recipes
      real xa(n),ya(n),y2a(n)
      klo=1
      khi=n
    1   if ((khi-klo).gt.1) then
           k=(khi+klo)/2
           if (xa(k).gt.x) then
              khi=k
           else
              klo=k
           endif
           goto 1
        endif
      h=xa(khi)-xa(klo)
      if (h.eq.0) then
C          write(6,*) xa(khi), 'splint failure',khi
          y=0.0
         return
      endif
      a=(xa(khi)-x)/h
      b=(x-xa(klo))/h
      y=a*ya(klo)+b*ya(khi)+
     $  ((a**3-a)*y2a(klo)+(b**3-b)*y2a(khi))*(h**2)/6.
      return
      end

      subroutine set_IC(vxin,vyin,vzin,tin,nelin,nelx_in,nely_in,nelz_in
     $                 ,nel_slab,theta)

      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      integer nelx_in,nel_slab,nelin,nely_in,ex,ey,ez,eg,e,nxyz,egchnl
      integer nchnlon,nelz_in,ez1
      real vxin(lx1,ly1,lz1,nelin)
     $    ,vyin(lx1,ly1,lz1,nelin)
     $    ,vzin(lx1,ly1,lz1,nelin)
     $    ,tin(lx1,ly1,lz1,nelin)
      real theta
      character*80 icfile,istepc
      real tmpz,tmpy
c     -----------------------------------------------------
      nxyz = nx1*ny1*nz1
      do i=1,lx1*ly1*lz1*nelin
        tmpz=vzin(i,1,1,1)*cos(theta)+vyin(i,1,1,1)*sin(theta)
        tmpy=vyin(i,1,1,1)*cos(theta)-vzin(i,1,1,1)*sin(theta)
        vzin(i,1,1,1)=tmpz
        vyin(i,1,1,1)=tmpy
      enddo


      do e=1,nelv
        eg = lglel(e)
        call  get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
        if (ey.le.nely_in) then
          if (mod(ez,nelz_in).eq.0) then
            nchnlon = int(ez/nelz_in)
          else
            nchnlon = int(ez/nelz_in)+1
          endif
          ez1 = ez - (nchnlon-1)*nelz_in
          egchnl = nel_slab*(ez1-1)+nelx_in*(ey-1)+ex !Global element number
          call copy(vx(1,1,1,e),vxin(1,1,1,egchnl),nxyz)
          call copy(vy(1,1,1,e),vyin(1,1,1,egchnl),nxyz)
          call copy(vz(1,1,1,e),vzin(1,1,1,egchnl),nxyz)
        endif
      enddo

      do e=1,nelt
        eg = lglel(e)
        call  get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
        if (ey.le.nely_in) then
          if (mod(ez,nelz_in).eq.0) then
            nchnlon = int(ez/nelz_in)
          else
            nchnlon = int(ez/nelz_in)+1
          endif
          ez1 = ez - (nchnlon-1)*nelz_in
          egchnl = nel_slab*(ez1-1)+nelx_in*(ey-1)+ex !Global element number
          call copy(t(1,1,1,e,1),tin(1,1,1,egchnl),nxyz)
        endif
      enddo
      return
      end

      subroutine output_2d(timel,w4,name)

       include 'SIZE'
       include 'TOTAL'
       include 'ZPER'

       real timel
       real w4(ly1,lz1,lely,lelz)
       integer name
       character*80 icfile,istepc
      common /avgstats/
     &  rumm(lx1,ly1,lz1,lelt,4)
     & , ru2m(lx1,ly1,lz1,lelt,4)
     & , ruvm(lx1,ly1,lz1,lelt,6)
     & , ruxm(lx1,ly1,lz1,lelt,12)
     & , rux2(lx1,ly1,lz1,lelt,12)
     & , ru3m(lx1,ly1,lz1,lelt,4)
     & , rv2u(lx1,ly1,lz1,lelt,6)
     & , rpmm(lx1,ly1,lz1,lelt,4)
     & , summ(lx1,ly1,lz1,lelt,4)
     & , su2m(lx1,ly1,lz1,lelt,4)
     & , suvm(lx1,ly1,lz1,lelt,6)
     & , suxm(lx1,ly1,lz1,lelt,12)
     & , sux2(lx1,ly1,lz1,lelt,12)
     & , su3m(lx1,ly1,lz1,lelt,4)
     & , sv2u(lx1,ly1,lz1,lelt,6)
     & , spmm(lx1,ly1,lz1,lelt,4)
     & , summ_2d(ly1,lz1,lely,lelz,4)
     & , su2m_2d(ly1,lz1,lely,lelz,4)
     & , suvm_2d(ly1,lz1,lely,lelz,6)
     & , suxm_2d(ly1,lz1,lely,lelz,12)
     & , sux2_2d(ly1,lz1,lely,lelz,12)
     & , su3m_2d(ly1,lz1,lely,lelz,4)
     & , sv2u_2d(ly1,lz1,lely,lelz,6)
     & , spmm_2d(ly1,lz1,lely,lelz,4)


       m=ny1*nz1*lely*lelz
       if(nid.eq.0) then
          write(istepc,'(i32)') name
          istepc=adjustl(istepc)
          icfile=trim('2dmeans.'//trim(istepc))
          open(unit=58,file=icfile,access='stream',form='unformatted')
          write(58) time
          write(58) int(nx1),int(lelx),int(lely),int(lelz)
          do i=1,4
            call copy(w4,summ_2d(1,1,1,1,i),m)
            write(58) w4
          enddo
          do i=1,4
            call copy(w4,su2m_2d(1,1,1,1,i),m)
            write(58) w4
          enddo
          do i=1,6
            call copy(w4,suvm_2d(1,1,1,1,i),m)
            write(58) w4
          enddo
          close(58)
       endif
       return
       end

      function dongOutflow(ix,iy,iz,iel,iside,u0,delta)

      include 'SIZE'
      include 'SOLN'
      include 'GEOM'

      real sn(3)

      ux = vx(ix,iy,iz,iel)
      uy = vy(ix,iy,iz,iel)
      uz = vz(ix,iy,iz,iel)

      call getSnormal(sn,ix,iy,iz,iside,iel)
      vn = ux*sn(1) + uy*sn(2) + uz*sn(3) 
      S0 = 0.5*(1.0 - tanh(vn/u0/delta))

      dongOutflow = -0.5*(ux*ux+uy*uy+uz*uz)*S0

      return
      end
C-----------------------------------------------------------------------
      subroutine vz_outflow(vzout,w)

      include 'SIZE'
      include 'SOLN'
      include 'GEOM'
      include 'ZPER'
      include 'PARALLEL'
      include 'WZ'

      real vzout(lx1,ly1,lelx,lely),w(lx1,ly1,lelx,lely)
      integer e,eg,ex,ey,ez, m

      m=lx1*ly1*lelx*lely
      call rzero(vzout,m)
      call rzero(w,m)
      do e=1,nelv
        eg = lglel(e)
        call get_exyz(ex,ey,ez,eg,lelx,lely,lelz)
        if (ez.eq.lelz) then
          do j=1,ny1
            do i=1,nx1  
              w(i,j,ex,ey)= vz(i,j,lz1,e)
            enddo
          enddo
        endif
      enddo
      call gop(w,vzout,'+  ',m)

      return 
      end

      subroutine shields(sh_x,sh_z,sh_cr,btuy,btwy,th_x,th_z,repd,cvd)
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real btuy(lx1,lz1,lelx,lelz),btwy(lx1,lz1,lelx,lelz)
      real sh_x(lx1,lz1,lelx,lelz),sh_z(lx1,lz1,lelx,lelz),
     &     sh_cr(lx1,lz1,lelx,lelz) 
      real th_x(lx1,lz1,lelx,lelz),th_z(lx1,lz1,lelx,lelz)
      real repd,cvd
      real dum,sh_cr0,gamma,beta,tan_cr, diamd
      integer n,i
      n=lx1*lz1*lelx*lelz
      call rzero(sh_x,n)
      call rzero(sh_z,n)
      call rzero(sh_cr,n)

      if (V_SETTLING.ne.0.0) then
        diamd=DIAM
      else
        dum=sin(atan(1.0/RITAU))*cvd
        diamd=(dum/((RE_TAU/repd)**2))**(1.0/3.0)
        if (nid.eq.0 .and. istep.eq.0) write(*,*)'Rep=',repd,'d=',diamd
      endif

      do i=1,n
        sh_x(i,1,1,1)=(diamd**2*RE_TAU/repd**2)*btuy(i,1,1,1)
        sh_z(i,1,1,1)=(diamd**2*RE_TAU/repd**2)*btwy(i,1,1,1)
      enddo

      sh_cr0=(0.22*repd**(-0.6)+0.06*exp(-17.77*repd**(-0.6)))*0.5
      
      if(IF_SHCR_VAR) then
      tan_cr=tan(PI/6.0)
        do i=1,n
          gamma=atan2(btwy(i,1,1,1),btuy(i,1,1,1))
          beta=th_z(i,1,1,1)*cos(gamma)+th_x(i,1,1,1)*sin(gamma)
          sh_cr(i,1,1,1)=sh_cr0*abs(cos(beta)*(1+(tan(beta)/tan_cr)))
        enddo
      else
        do i=1,n
          sh_cr(i,1,1,1)=sh_cr0
        enddo
      endif

      return
      end

      subroutine sediment_flux(sh_x,sh_z,sh_cr,qbx,qbz,repd)
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real sh_x(lx1,lz1,lelx,lelz),sh_z(lx1,lz1,lelx,lelz),
     &     sh_cr(lx1,lz1,lelx,lelz)  
      real qbx(lx1,lz1,lelx,lelz),qbz(lx1,lz1,lelx,lelz)
      real w1(lx1,lz1,lelx,lelz) 
      real repd
      real dum, dumx, dumz, dumrp
      integer n,i

      n=lx1*lz1*lelx*lelz

      call rzero(w1,n)
      call rzero(qbx,n)
      call rzero(qbz,n)

      do i=1,n
        dum=(sh_x(i,1,1,1)**2+sh_z(i,1,1,1)**2)**0.5
        if (dum.ge.sh_cr(i,1,1,1)) then
        dumx=sh_x(i,1,1,1)/dum
        dumz=sh_z(i,1,1,1)/dum
        qbx(i,1,1,1)=(repd/RE_TAU)*4.93*dumx*(dum-sh_cr(i,1,1,1))**1.6 !Wong & Parker MPM
        qbz(i,1,1,1)=(repd/RE_TAU)*4.93*dumz*(dum-sh_cr(i,1,1,1))**1.6
        endif
      enddo 

C       call gop(qbx,w1,'+  ',n)
C       call rzero(w1,n)
C       call gop(qbz,w1,'+  ',n)
      return
      end     


      subroutine parker_erosion(btuy,btwy)
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real btuy(lx1,lz1,lelx,lelz),btwy(lx1,lz1,lelx,lelz)
      real dum,zp,A,repd,cvd
      integer n,i

      common /erosion/ E_s(lx1,lz1,lelx,lelz)

      n=lx1*lz1*lelx*lelz
      if (V_SETTLING.ne.0.0) then
        cvd=Cv
        repd=RE_P
      else
        cvd=0.0
        repd=0.3
      endif

      call rzero(E_s,n)

      A=1.3E-7
      do i=1,n
        zp=18.0*(repd**-1.4)*DIAM*(RE_TAU*(btuy(i,1,1,1)**2+
     &              btwy(i,1,1,1)**2)**0.5)**0.5
        E_s(i,1,1,1)=(A*zp**5)/(1.0+10.0*A*zp**5)
      enddo
C       call gop(E_s,w1,'+  ',n)
      return
      end

      subroutine bottom_copy(u,wo1)
c     This copies a 2d x-z array at the bottom of a 3d v-mesh, to allow the use of gradm1
      include 'SIZE'
      include 'GEOM'
      include 'ZPER'
      include 'PARALLEL'
      include 'WZ'


      real u(lx1,lz1,lelx,lelz)
      real wo1(lx1,ly1,lz1,lelv)
      integer e,eg,ex,ey,ez


      nxz=lx1*lz1*lelx*lelz
      nxyz=lx1*lz1*ly1*lelt
      call rzero(wo1,nxyz)

      do e=1,nelt
         eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
          do k=1,nz1
            do j=1,ny1
              do i=1,nx1
                wo1(i,j,k,e) = u(i,k,ex,ez)
              enddo
            enddo
          enddo
      enddo
      return
      end

      subroutine temp_threshold(tem,thr)
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real tem(lx1,ly1,lz1,lelv),thr(lx1,ly1,lz1,lelv)

      call rzero(thr,lx1*ly1*lz1*lelv)
      do i=1,lx1*ly1*lz1*lelv
        if (tem(i,1,1,1).gt.THRESHOLD) then
        thr(i,1,1,1)= 1.0
        endif
      enddo
      return
      end

      subroutine bed_angle(eta,th_x,th_z,lap_e,w1,w2,w3,w4,wxz1,wxz2,
     &  x,z)
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real eta(lx1,lz1,lelx,lelz)
      real th_z(lx1,lz1,lelx,lelz),th_x(lx1,lz1,lelx,lelz),
     &     lap_e(lx1,lz1,lelx,lelz)
      real wxz1(lx1,lz1,lelx,lelz),wxz2(lx1,lz1,lelx,lelz)
      real w1(lx1,ly1,lz1,lelv),w2(lx1,ly1,lz1,lelv),
     &     w3(lx1,ly1,lz1,lelv),w4(lx1,ly1,lz1,lelv)
      real x(lx1,lz1,lelx,lelz),z(lx1,lz1,lelx,lelz)
      real wxz3(lx1,lz1,lelx,lelz)


      integer i,nxz,nt,ex

      nxz=lx1*lz1*lelx*lelz
      nt=lx1*ly1*lz1*lelv

      call bottom_copy(eta,w4)
      call gradm1(w1,w2,w3,w4)

      call y_slice(th_x,w1,wxz1)        ! tan(theta_x)
      call y_slice(th_z,w3,wxz1)        ! tan(theta_z)

      call bed_filter(th_x,z,x,0)
      call bed_filter(th_z,z,x,0)

      call bottom_copy(th_z,w4)
      call gradm1(w1,w2,w3,w4)   !d2eta/dzz
      call y_slice(lap_e,w3,wxz1)

      call bottom_copy(th_x,w4)
      call gradm1(w1,w2,w3,w4)   !d2eta/dxx
      call y_slice(wxz3,w1,wxz1)
      call add2(lap_e,wxz3,nxz)      


      do i =1,nxz
        th_x(i,1,1,1)=atan(th_x(i,1,1,1))
        th_z(i,1,1,1)=atan(th_z(i,1,1,1))
      enddo

      call bed_filter(lap_e,z,x,0)
      return
      end

      subroutine B_eta_s(B,th_x,th_z)
c      Proporcionality constant between concentration and sediment height
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real B(lx1,lz1,lelx,lelz),
     &     th_x(lx1,lz1,lelx,lelz),th_z(lx1,lz1,lelx,lelz)
      real cvd
      integer n,i

      n=lx1*lz1*lelx*lelz
      cvd=Cv

      do i=1,n
        B(i,1,1,1)=dcos(th_x(i,1,1,1))*dcos(th_z(i,1,1,1))*cvd
      enddo
      return
      end

      subroutine q_integral_s(q_int,qbz,qbx,w1,w2,igs_x,igs_z)

      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real q_int
      real qbx(lx1,lz1,lelx,lelz),qbz(lx1,lz1,lelx,lelz)
      real q_thr(lx1,lz1,lelx,lelz)
      real w1(lx1,ly1,lz1,lelv),w2(lx1,ly1,lz1,lelv)
      integer igs_z,igs_x
      real q_mod,wght,dum, thres
      integer e,eg,ex,ey,ez,i

      q_int=0.0
      wght=0.0
      thres=0.000001
      nxz=lx1*lz1*lelx*lelz
      call rzero(q_thr,nxz)

      do i=1,nxz
        q_mod=(qbx(i,1,1,1)**2+qbz(i,1,1,1)**2)**0.5
        if (q_mod.ge.thres) q_thr(i,1,1,1)=q_mod 
      enddo
      call bottom_copy(q_thr,w1)
      call planar_avg(w2,w1,igs_z)
      call rzero(w1,size(w1))
      call planar_avg(w1,w2,igs_x)
      q_int=w1(1,1,1,1)

      
      return
      end

      subroutine read_bed(wxz)
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real wxz(lx1,lz1,lelx,lelz)
      real rdum
      integer idum, type, nxz

      common /heights/ eta(lx1,lz1,lelx,lelz),
     &               eta_e(lx1,lz1,lelx,lelz),
     &               eta_d(lx1,lz1,lelx,lelz),
     &               eta_q(lx1,lz1,lelx,lelz)

      nxz=lx1*lz1*lelx*lelz
      call rzero(eta,nxz)
      call rzero(eta_q,nxz)
      call rzero(eta_q2,nxz)
      call rzero(eta_q3,nxz)
      call rzero(eta_cb,nxz)
      call rzero(eta_qcb,nxz)
      call rzero(eta_es,nxz)


      if (nid.eq.0) then
          write(*,*)'###### Reading bedform file for restart ####'
          open(unit=58,file='bedform.ini',access='stream',
     &       form='unformatted')
          read(58) idum,idum,idum,idum
          read(58) type
          write(*,*) 'File contents type:', type
          read(58) rdum
          read(58) w2, w2, w2 !Es int_t btt
          read(58) eta_q
          read(58) w2, w2
          if (type .eq. 1 .or. type.eq.-1) read(58) w2, w2, w2, w2, w2
          if (type .eq. -1) read(58) eta_q2, w2, w2, w2, w2, w2
          if (type .eq. -1) read(58) eta_q3, w2, w2, w2, w2, w2
          read(58) eta
          if (type .eq. 1) read(58) w2, w2, w2, w2, w2
          read(58) eta_escb
          if (type .eq. 1) read(58) w2, w2
          read(58) eta_qcb
          if (type .eq. 1) read(58) w2, w2, w2, w2, w2
          read(58) eta_es
          read(58) eta_cb
          if (type .eq. 1) read(58) w2, w2
          close(58)
          write(*,*)'FILE: bedform.ini'
          write(*,*)'###### Reading bedform file for restart done ###'
        endif
      call rzero(wxz,nxz)
      call gop(eta,wxz,'+  ',nxz)
      call rzero(wxz,nxz)
      call gop(eta_q,wxz,'+  ',nxz)
      call rzero(wxz,nxz)
      call gop(eta_q2,wxz,'+  ',nxz)
      call rzero(wxz,nxz)
      call gop(eta_q3,wxz,'+  ',nxz)
      call rzero(wxz,nxz)
      call gop(eta_cb,wxz,'+  ',nxz)
      call rzero(wxz,nxz)
      call gop(eta_escb,wxz,'+  ',nxz)
      call rzero(wxz,nxz)
      call gop(eta_qcb,wxz,'+  ',nxz)
      call rzero(wxz,nxz)
      call gop(eta_es,wxz,'+  ',nxz)
      return
      end


      subroutine bed_filter(h, z, x,type)
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'


      real h(lx1,lz1,lelx,lelz)
      real z(lx1,lz1,lelx,lelz),x(lx1,lz1,lelx,lelz)
C       real w1(lx1,lz1,lelx,lelz)
      integer type
      real x_s(5),z_s(5),y_s(2)
      real xl,xm,xp,xr,zl,zm,zp,zr,z0,x0
      real dumm,xlen
      integer i,j,ex,ez
      integer per_x, per_z
      !type=1 replace lx-1,lx1,1,2
      !type=0 replace lx1,1
      per_x=1
      if (IF_FAN) per_x=0


      if (type.eq.1) then
        zl=z(1,lz1-2,1,1)-z(1,lz1,1,1)
        zm=z(1,lz1-1,1,1)-z(1,lz1,1,1)
        z0=0.0
        zp=z(1,2,1,1)
        zr=z(1,3,1,1)

        xl=x(lx1-2,1,1,1)-x(lx1,1,1,1)
        xm=x(lx1-1,1,1,1)-x(lx1,1,1,1)
        x0=0.0
        xp=x(2,1,1,1)
        xr=x(3,1,1,1)
      else
        zl=z(1,lz1-2,1,1)-z(1,lz1,1,1)
        z0=0.0
        zr=z(1,2,1,1)

        xl=x(lx1-1,1,1,1)-x(lx1,1,1,1)
        x0=0.0
        xr=x(2,1,1,1)
      endif  

      do ez=1,lelz-1
        do ex=1,lelx
C           first on z
          do i=1,lz1         !could be done up to lx1-1
            if (type.eq.1) then
              y_s(1)=h(i,lz1-2,ex,ez  )
              y_s(2)=h(i,3,    ex,ez+1)
            else
              y_s(1)=h(i,lz1-1,ex,ez  )
              y_s(2)=h(i,2,    ex,ez+1)
            endif
            dumm=y_s(1)*(zr-z0)+y_s(2)*(z0-zl)
            h(i,lz1,ex,ez)=dumm/(zr-zl)
            h(i,1,ex,ez+1)=dumm/(zr-zl)
            if (type.eq.1) then
              dumm=y_s(1)*(zr-zm)+y_s(2)*(zm-zl)
              h(i,lz1-1,ex,ez)=dumm/(zr-zl)
              dumm=y_s(1)*(zr-zp)+y_s(2)*(zp-zl)
              h(i,2,ex,ez+1)=dumm/(zr-zl)
            endif
          enddo
        enddo
      enddo

      do ez=1,lelz
        do ex=1,lelx-1
C           now x
          do j=1,lx1         !could be done up to lx1-1
            if (type.eq.1) then
              y_s(1)=h(lz1-2,j,ex,ez  )
              y_s(2)=h(3,j,    ex+1,ez)
            else
              y_s(1)=h(lz1-1,j,ex,ez  )
              y_s(2)=h(2,    j,ex+1,ez)
            endif
            dumm=y_s(1)*(xr-x0)+y_s(2)*(x0-xl)
            h(lx1,j,ex,ez)=dumm/(xr-xl)
            h(1,j,ex+1,ez)=dumm/(xr-xl)
            if (type.eq.1) then
              dumm=y_s(1)*(xr-xm)+y_s(2)*(xm-xl)
              h(lx1-1,j,ex,ez)=dumm/(xr-xl)
              dumm=y_s(1)*(xr-xp)+y_s(2)*(xp-xl)
              h(2,j,ex+1,ez)=dumm/(xr-xl)
            endif
          enddo
        enddo
      enddo
     
      if (per_x.eq.1) then
        do ez=1,lelz
          do j=1,lx1         !could be done up to lx1-1
            if (type.eq.1) then
              y_s(1)=h(lz1-2,j,lelx,ez  )
              y_s(2)=h(3,j,    1,ez)
            else
              y_s(1)=h(lz1-1,j,lelx,ez  )
              y_s(2)=h(2,    j,1,ez)
            endif
            dumm=y_s(1)*(xr-x0)+y_s(2)*(x0-xl)
            h(lz1,j,lelx,ez)=dumm/(xr-xl)
            h(1,j,1,ez)=dumm/(xr-xl)
            if (type.eq.1) then
              dumm=y_s(1)*(xr-xm)+y_s(2)*(xm-xl)
              h(lz1-1,j,lelx,ez)=dumm/(xr-xl)
              dumm=y_s(1)*(xr-xp)+y_s(2)*(xp-xl)
              h(2,j,1,ez)=dumm/(xr-xl)
            endif
          enddo
        enddo
      endif

      return
      end
      

      subroutine y_ipn(yi,xi,xs,ys)
        real yi,xi
        real xs(4), ys(4)
        real q(4)
        integer i,k

        do i=1,4
          q(i)=ys(i)
        enddo

        do i=2,4
          do k=4,i,-1
            q(k)=((xi-xs(k))*q(k-1)-(xi-xs(k-i))*q(k))/(xs(k-i)-xs(k))
          enddo
        enddo

        yi = q(4)
      return
      end



      subroutine bedform_calcs(btwy,btuy,btt,xbmm,zbmm,wo1,wo2,wo3,wo4,
     &                        igs_x,igs_y,igs_z,
     &                     wxz1,wxz2,wxz3,sh_x,sh_z,sh_cr,qbx,qbz,int_t,
     &               qbxx,qbzz,theta_bedx,theta_bedz,B_eta, lap_eta)

      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real btwy(lx1,lz1,lelx,lelz),btuy(lx1,lz1,lelx,lelz),
     &     btt(lx1,lz1,lelx,lelz),
     &     zbmm(lx1,lz1,lelx,lelz),xbmm(lx1,lz1,lelx,lelz)

      real wo1(lx1,ly1,lz1,lelv)
     &      ,  wo2(lx1,ly1,lz1,lelv)
     &      ,  wo3(lx1,ly1,lz1,lelv)
     &      ,  wo4(lx1,ly1,lz1,lelv)     

      integer igs_x, igs_y, igs_z

      common /heights/ eta(lx1,lz1,lelx,lelz),
     &               eta_e(lx1,lz1,lelx,lelz),
     &               eta_d(lx1,lz1,lelx,lelz),
     &               eta_q(lx1,lz1,lelx,lelz)


      common /erosion/ E_s(lx1,lz1,lelx,lelz) 
      common /ab2/ femm(lx1,lz1,lelx,lelz),
     &    fem(lx1,lz1,lelx,lelz), base_eta1(lx1,lz1,lelx,lelz),
     &    femm_e(lx1,lz1,lelx,lelz), fem_e(lx1,lz1,lelx,lelz), 
     &    femm_d(lx1,lz1,lelx,lelz), fem_d(lx1,lz1,lelx,lelz), 
     &    femm_q(lx1,lz1,lelx,lelz), fem_q(lx1,lz1,lelx,lelz),
     &    base_eta2(lx1,lz1,lelx,lelz)
      common /ab2_2/ dtmm, dtm, izb1, ezb1, izb2, ezb2


      common /eta_mvbc/ umeshx(lx1,ly1,lz1,lelv)
     &              , umeshy(lx1,ly1,lz1,lelv)
     &              , umeshz(lx1,ly1,lz1,lelv)
     &              , rhs(lx1,lz1,lelx,lelz)

      real wxz1(lx1,lz1,lelx,lelz),wxz2(lx1,lz1,lelx,lelz), 
     &     wxz3(lx1,lz1,lelx,lelz),!working arrays
     &     sh_x(lx1,lz1,lelx,lelz),  !Shields number
     &     sh_z(lx1,lz1,lelx,lelz),  !Shields number
     &     sh_cr(lx1,lz1,lelx,lelz),  !Critical Shields number
     &     qbx(lx1,lz1,lelx,lelz),   !Bottom sediment flux
     &     qbz(lx1,lz1,lelx,lelz),  !Bottom sediment flux
     &     int_t(lx1,lz1,lelx,lelz),
     &     qbxx(lx1,lz1,lelx,lelz),
     &     qbzz(lx1,lz1,lelx,lelz),
     &     theta_bedx(lx1,lz1,lelx,lelz),
     &     theta_bedz(lx1,lz1,lelx,lelz),
     &     B_eta(lx1,lz1,lelx,lelz),
     &     lap_eta(lx1,lz1,lelx,lelz)
     

      real q_integral, dtimestep,cvd,repd(3),eps(3),zbu(2),rhsm_in,dumm
      integer e,ex,ez,ey,eg
      real vol_in
      save vol_in

      parameter (lx1tp=2*lx1+1)
      real kernelx_q(lx1,lx1tp), kernelz_q(lx1,lx1tp)
      save kernelx_q,kernelz_q
      integer mask_gf(lx1,lx1tp,2)
      save mask_gf

      character*32 istepc,outfile
      character*80 icfile
      integer nxz,i, if_write, mvs,j,k,n
      integer counter_bed
      save counter_bed


      dtimestep = abs(dt)
      nxz=lx1*lz1*lelx*lelz
      n=lx1*ly1*lz1*lelv

      if (V_SETTLING.ne.0.0) then
        cvd=Cv
        repd(1)=RE_P
        mvs=1
      else
        cvd=0.005
        repd(1)=0.3
        repd(2)=1.8
        repd(3)=3.0
        mvs=3
      endif

      if (istep.eq.0) then
      call rzero(rhs,size(rhs))
        zbu(1) = IN_ZL
        zbu(2) = OUT_ZL
      do i=1,nxz
       base_eta1(i,1,1,1)=1.0
       base_eta2(i,1,1,1)=1.0
       if (zbmm(i,1,1,1).le.zbu(1)) then 
        base_eta1(i,1,1,1)=zbmm(i,1,1,1)/zbu(1)
        base_eta1(i,1,1,1)=base_eta1(i,1,1,1)**2.0
       endif
       if (zbmm(i,1,1,1).gt.(ZLEN-zbu(2))) then
        base_eta2(i,1,1,1)=(-1.0/zbu(2))*(zbmm(i,1,1,1)-ZLEN
     &                   +zbu(2))+1.0
        base_eta2(i,1,1,1)=base_eta2(i,1,1,1)**2.0
       endif
      enddo
      vol_in=0.0
      dumm=0.0
      do e=1,nelv
       eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
          do k=1,nz1
            do j=1,ly1
                do i=1,nx1
                  if (zbmm(i,k,ex,ez).gt.IN_ZL .and. 
     &                zbmm(i,k,ex,ez) .lt. (IN_ZL*1.5)) then
                    vol_in=vol_in+bm1(i,j,k,e)
                  endif
                enddo
              enddo
           enddo
      enddo
      call gop(vol_in,dumm,'+  ',1)

      do ez=1,lelz
       do i=1,lz1
        izb2 = i
        ezb2 = ez
        if (zbmm(1,i,1,ez).gt.(ZLEN-zbu(2))) exit 
       enddo
      enddo
      do ez=1,lelz
       do i=1,lz1
        izb1 = i
        ezb1 = ez
        if (zbmm(1,i,1,ez).gt.(zbu(1))) exit 
       enddo
      enddo

      endif !istep.eq.0

      if (istep.eq.0) counter_bed=0
      if_write=0
      if (nid.eq.0) then
      if (param(15).ne.0) then !writeControl = numStep
        write(istepc,'(i32)') istep
        istepc=adjustl(istepc)
        icfile=trim('bed.'//trim(istepc))
        if (mod(istep,int(iostep_bed)).eq.0) then 
          if_write = 1
        else
          if_write = 0
        endif
      else !writeControl = runTime
        write(istepc,'(i32)') counter_bed
        istepc=adjustl(istepc)
        icfile=trim('bed.'//trim(istepc))

       if (iostep_bed*aint(time/iostep_bed).ge.counter_bed*iostep_bed)
     &    then 
          if_write = 1
          counter_bed = counter_bed +1 
        else
          if_write = 0
       endif
      endif
      endif
      do i=1,nxz
        if (btt(i,1,1,1).lt.0.0) btt(i,1,1,1)=0.0
      enddo

      q_integral = 0.0

      call bed_angle(eta,theta_bedx,theta_bedz,lap_eta,
     &               wo1,wo2,wo3,wo4,wxz1,wxz2,xbmm,zbmm) !compute bedform angles (in radians!) and eta laplacian.

C       if (istep.eq.0) call set_mean_filter(zbmm, xbmm, WDW_EXNER_RHS,1)
C       if (istep.eq.0) call set_mean_filter(zbmm, xbmm, WDW_EXNER_Q,2)
      if(IF_DIVQ) then
        if (istep.eq.0) call gaussian_filter_setup(zbmm,xbmm,
     &  zbmm(1,lx1,1,1)/STD_EXNER_QZ,xbmm(lx1,1,1,1)/STD_EXNER_QX,
     &  kernelz_q,kernelx_q,mask_gf) 

        call shields(sh_x,sh_z,sh_cr,btuy,btwy,theta_bedx,theta_bedz,
     &                                                     repd(1),cvd)       !compute Shields and Critical Shields number
        call bed_filter(sh_cr, zbmm, xbmm,0)
        call sediment_flux(sh_x,sh_z,sh_cr,qbx,qbz,repd(1)) !compute bottom sediment flux (Wong & Parker MPM)
C     Sediment flux gradient
        call bottom_copy(qbx,wo4)
        call gradm1(wo1,wo2,wo3,wo4)
        call y_slice(qbxx,wo1,wxz1)        ! dqbx/dx
        call bed_filter(qbxx, zbmm, xbmm,0)

        call bottom_copy(qbz,wo4)
        call gradm1(wo1,wo2,wo3,wo4)
        call y_slice(qbzz,wo3,wxz1)        ! dqbz/dz
        call bed_filter(qbzz, zbmm, xbmm,0)

C       call q_integral_s(q_integral,qbz,qbx,wo1,wo2,igs_x,igs_z)
        call add3(wxz1,qbxx,qbzz,nxz)      ! div dot q
        call gaussian_filter(wxz1,kernelz_q, kernelx_q,mask_gf)   !wxz1 -> div dot q
      else
        call rzero(wxz1,nxz) !wxz1 -> div dot q
      endif

      if(IF_DEPO) then 
        call B_eta_s(B_eta,theta_bedx,theta_bedz)   !Proportionality constant between concentration and sediment height
      else
        call rzero(B_eta,nxz)
      endif

      if (IF_EROS) then
        call copy(wxz3,E_s,nxz) !wxz3 -> erosion
      else
        call rzero(wxz3,nxz) !wxz3 -> erosion
      endif


      do i=1,nxz
        wxz2(i,1,1,1)= (EPS_EXNER*lap_eta(i,1,1,1) !lap eta
     &               -cvd*abs(V_SETTLING*wxz3(i,1,1,1))  !E_s
     &               +V_SETTLING*B_eta(i,1,1,1)*btt(i,1,1,1) !c_b
     &               -wxz1(i,1,1,1)) ! div.q
        wxz2(i,1,1,1)=wxz2(i,1,1,1)/PACKING_FR
      enddo

C     fix inlet
      do i=1,nxz
        wxz3(i,1,1,1)=0.0
        if (zbmm(i,1,1,1).gt.IN_ZL .and. zbmm(i,1,1,1).lt.(IN_ZL*1.5)) 
     &  wxz3(i,1,1,1)=wxz2(i,1,1,1)
      enddo
      call bottom_copy(wxz3,wo4)
      rhsm_in = glsc2(wo4,bm1,n)/vol_in
c     fix outlet
C       do ez=1,lelz
C       do ex=1,lelx
C       do k=1,lz1
C        do i=1,lx1
C         if (zbmm(i,k,ex,ez).gt.(ZLEN-OUT_ZL)) then
C          wxz2(i,k,ex,ez)=wxz2(i,izb2,ex,ezb2)*((-1.0/OUT_ZL)*
C      &   (zbmm(i,k,ex,ez)-ZLEN+OUT_ZL)+1.0)
C         endif 
C        enddo
C       enddo
C       enddo
C       enddo

      do i=1,nxz
       wxz2(i,1,1,1)=wxz2(i,1,1,1)*base_eta1(i,1,1,1)*base_eta2(i,1,1,1)
        if (.not. IF_FAN) then
        wxz2(i,1,1,1)=wxz2(i,1,1,1)+ (1.0-base_eta1(i,1,1,1))*rhsm_in
        endif
      enddo


C       if (WDW_EXNER_RHS .ne. 0.0) call mean_filter(rhs,1)

C       do i=1,nxz
C       wxz2(i,1,1,1)=wxz2(i,1,1,1)*base_eta1(i,1,1,1)*base_eta2(i,1,1,1)
C         if (.not. IF_FAN) then
C         wxz2(i,1,1,1)=wxz2(i,1,1,1)+ (1.0-base_eta1(i,1,1,1))*
C      &  wxz2(int(lx1/2),int(izb1),int(lelx/2),int(ezb1))+
C      &  (1.0-base_eta2(i,1,1,1))*
C      &  wxz2(int(lx1/2),int(izb2),int(lelx/2),int(ezb2))
C         endif
C       enddo


      call bed_filter(wxz2, zbmm, xbmm,1) !removes element boundaries

      do i=1,nxz
        rhs(i,1,1,1)=wxz2(i,1,1,1)
      enddo

      do i=1,nxz
       if (istep.ne.0) then
         femm(i,1,1,1)=fem(i,1,1,1)
         dtmm=dtm
       endif 
       fem(i,1,1,1)= wxz2(i,1,1,1)
       dtm=abs(dt)
       if (istep.eq.0) then
        fem(i,1,1,1)=(2.0/3.0)*fem(i,1,1,1)
        femm(i,1,1,1)=0.0
        dtmm=dtm
       endif
       if (IF_EROS) then
        if (istep.ne.0) then
         femm_e(i,1,1,1)=fem_e(i,1,1,1)
        endif 
        fem_e(i,1,1,1)=cvd*abs(V_SETTLING*E_s(i,1,1,1))/(PACKING_FR)
        fem_e(i,1,1,1)=fem_e(i,1,1,1)*base_eta1(i,1,1,1)
     &  *base_eta2(i,1,1,1)
        if (istep.eq.0) then
         fem_e(i,1,1,1)=(2.0/3.0)*fem_e(i,1,1,1)
         femm_e(i,1,1,1)=0.0
        endif
       endif !IF_EROS
       if (IF_DEPO) then
        if (istep.ne.0) then
         femm_d(i,1,1,1)=fem_d(i,1,1,1)
        endif 
        fem_d(i,1,1,1)=V_SETTLING*B_eta(i,1,1,1)*btt(i,1,1,1)/PACKING_FR
        fem_d(i,1,1,1)=fem_d(i,1,1,1)*base_eta1(i,1,1,1)*
     &  base_eta2(i,1,1,1)
        if (istep.eq.0) then
         fem_d(i,1,1,1)=(2.0/3.0)*fem_d(i,1,1,1)
         femm_d(i,1,1,1)=0.0
        endif
       endif !IF_DEPO
       if (IF_DIVQ) then
        if (istep.ne.0) then
         femm_q(i,1,1,1)=fem_q(i,1,1,1)
        endif 
        fem_q(i,1,1,1)=(wxz1(i,1,1,1))/PACKING_FR
        fem_q(i,1,1,1)=fem_q(i,1,1,1)*base_eta1(i,1,1,1)*
     &  base_eta2(i,1,1,1)
        if (istep.eq.0) then
         fem_q(i,1,1,1)=(2.0/3.0)*fem_q(i,1,1,1)
         femm_q(i,1,1,1)=0.0
        endif
       endif !IF_DIVQ
      enddo

      if (IF_DEPO) call A_Bashforth_2(eta_d,femm_d,fem_d,dtmm,dtm)
      if (IF_EROS) call A_Bashforth_2(eta_e,femm_e,fem_e,dtmm,dtm)
      if (IF_DIVQ) call A_Bashforth_2(eta_q,femm_q,fem_q,dtmm,dtm)
      if (IF_DEPO) call bed_filter(eta_d, zbmm, xbmm,0)
      if (IF_EROS) call bed_filter(eta_e, zbmm, xbmm,0)
      if (IF_DIVQ) call bed_filter(eta_q, zbmm, xbmm,0)


      call A_Bashforth_2(eta,femm,fem,dtmm,dtm)

      if (if_write.eq.1) then        
          open(unit=71,file=icfile,access='stream',form='unformatted')
          write(71) int(lx1),int(lelx),int(lely),int(lelz)
          if(IF_ALL_BED) then
            write(71) int(1)
          else
            write(71) int(0)
          endif
          write(71) time
          write(71) int_t
          write(71) btt
          write(71) eta
          write(71) eta_d
          write(71) eta_e
          write(71) eta_q
          if(IF_ALL_BED) then
            write(71) E_s
            write(71) sh_x
            write(71) sh_z
            write(71) sh_cr
            write(71) qbxx
            write(71) qbzz
            write(71) theta_bedx
            write(71) theta_bedz
          endif
          close(71)
      endif

      return
      end

      subroutine my_base_meshv(basev)
      include 'SIZE'
      include 'TOTAL'
      real basev(lx1,ly1,lz1,lelv)
      integer n,i
      
      n = nx1*ny1*nz1*nelv
      call rzero(basev ,n)  ! basev  = 0
      do i=1,n
         y=ym1(i,1,1,1)
         if (y.lt.hint) then
          basev(i,1,1,1)=1.0
         else 
          basev(i,1,1,1) = -1.0*(y-hint)/(YLEN-hint)+1.0
         endif
      enddo

      return
      end

      subroutine eta_mvmesh()

      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'
      parameter (lt=lx1*ly1*lz1*lelv)

      common /cmeshv/ basev(lt)   

      common /eta_mvbc/ umeshx(lx1,ly1,lz1,lelv)
     &              , umeshy(lx1,ly1,lz1,lelv)
     &              , umeshz(lx1,ly1,lz1,lelv)
     &              , rhs(lx1,lz1,lelx,lelz)

      integer i, nxz, n,j,k
      integer e,eg,ex,ey,ez

      nxz=lx1*lz1*lelx*lelz
      n = nx1*ny1*nz1*nelv

      if (istep.eq.0) call my_base_meshv(basev)

      call rzero(umeshy,n)
      call bottom_copy(rhs,umeshy)

      do i=1,n
        umeshy(i,1,1,1)=umeshy(i,1,1,1)*basev(i)
        wx(i,1,1,1)=0.0
        wy(i,1,1,1)=umeshy(i,1,1,1)
        wz(i,1,1,1)=0.0
        umeshx(i,1,1,1) = wx(i,1,1,1)
        umeshz(i,1,1,1) = wz(i,1,1,1)
      enddo

C         ifpo=.false.
C         ifto=.false.
C       if (mod(istep,10).eq.0) 
C      &  call outpost2(wy,umeshy,wx,pr,t,0,'tes')

C C         ifpo=.true.
C         ifto=.true.


      return
      end
      subroutine stress_normal(btuy,btwy,wxz1,
     &                        thx,thz)

      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'


      real btuy(lx1,lz1,lelx,lelz),btwy(lx1,lz1,lelx,lelz)
      real wxz1(lx1,lz1,lelx,lelz)
      real thx(lx1,lz1,lelx,lelz),thz(lx1,lz1,lelx,lelz)

      common /v_filter/ vx_f(lx1,ly1,lz1,lelv),vy_f(lx1,ly1,lz1,lelv),
     &                  vz_f(lx1,ly1,lz1,lelv),t_f(lx1,ly1,lz1,lelv)

      integer nxz,e,eg,ex,ey,ez,i,j,k
      real sn(3),normdum,dum
      real vxx(lx1,ly1,lz1,lelv),
     $     vxy(lx1,ly1,lz1,lelv),
     $     vxz(lx1,ly1,lz1,lelv),
     $     vzx(lx1,ly1,lz1,lelv),
     $     vzy(lx1,ly1,lz1,lelv),
     $     vzz(lx1,ly1,lz1,lelv)

      nxz=lx1*lz1*lelx*lelz
      call rzero(btuy,nxz)
      call rzero(btwy,nxz)

      do e=1,nelv
           eg = lglel(e)
           call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
            do k=1,nz1
              do j=1,ly1
                  do i=1,nx1
                   vx_f(i,j,k,e)=vx_f(i,j,k,e)*cos(thx(i,k,ex,ez))-
     &                           vy_f(i,j,k,e)*sin(thx(i,k,ex,ez))
                   vz_f(i,j,k,e)=vz_f(i,j,k,e)*cos(thz(i,k,ex,ez))-
     &                           vy_f(i,j,k,e)*sin(thz(i,k,ex,ez))
                  enddo
                enddo
             enddo
      enddo

c     compute gradients
      call gradm1(vxx,vxy,vxz,vx_f)
      call gradm1(vzx,vzy,vzz,vz_f)

      do e=1,nelv
           eg = lglel(e)
           call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
           if (ey.eq.1) then
            j=1
              do k=1,nz1
                  do i=1,nx1
                   sn(1)=sin(thx(i,k,ex,ez))*cos(thz(i,k,ex,ez))
                   sn(2)=cos(thx(i,k,ex,ez))*cos(thz(i,k,ex,ez))
                   sn(3)=cos(thx(i,k,ex,ez))*sin(thz(i,k,ex,ez))
                   normdum=(sn(1)**2+sn(2)**2+sn(3)**2)**0.5
                   sn(1)=sn(1)/normdum
                   sn(2)=sn(2)/normdum
                   sn(3)=sn(3)/normdum
                   btuy(i,k,ex,ez)= vxx(i,j,k,e)*sn(1)+
     &                  vxy(i,j,k,e)*sn(2)+vxz(i,j,k,e)*sn(3)
                   btwy(i,k,ex,ez)= vzx(i,j,k,e)*sn(1)+
     &                  vzy(i,j,k,e)*sn(2)+vzz(i,j,k,e)*sn(3)
                  enddo
                enddo
           endif
          enddo
      call rzero(wxz1,size(wxz1))
      call gop(btuy,wxz1,'+  ',nxz)
      call rzero(wxz1,size(wxz1))
      call gop(btwy,wxz1,'+  ',nxz)
      return 
      end


      subroutine A_Bashforth_2(q,femm,fem,dtmm,dtm)

      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real q(lx1,lz1,lelx,lelz),
     &     femm(lx1,lz1,lelx,lelz),
     &     fem(lx1,lz1,lelx,lelz)

     
      real dtmm, dtm
      integer n,i
      real dummy
      
C       Performs the time integration of quantity q, using a multistep
C       Adams-Basforth 2nd order scheme, with variable step size.
C       y_k=y_(k-1)+h_k*(f_(k-1)+0.5*(h_k/h_(k-1))*(f_(k-1)-f_(k-2))) 
C       femm <-- f_(k-2) ; fem <-- f_(k-1)
C       dtm <-- h_k=t_k-t_(k-1); dtmm <-- h_(k-1)=t_(k-1)-t_(k-2)

      n=lx1*lz1*lelx*lelz

      do i=1,n
       dummy=fem(i,1,1,1)+0.5*(dtm/dtmm)*(fem(i,1,1,1)-femm(i,1,1,1))
       dummy=dummy*dtm
       q(i,1,1,1)=q(i,1,1,1)+dummy
      enddo

      return
      end
      
      subroutine q_filter_mine(q,modes,wght)
      include 'SIZE'
      include 'TOTAL'

      real q(lx1,ly1,lz1,lelv)
      integer modes
      real wght

c
c
c     These are the dimensions that we interpolate onto for v and p:
      parameter(lxv=lx1-1)
      parameter(lxp=lx2-1)
c
      real intdv(lx1,lx1)
      real intuv(lx1,lx1)
      real intv(lx1,lx1)
c
      save intdv
      save intuv
      save intv

      common /ctmp0/ intw,intt
     $             , wk1,wk2
     $             , zgmv,wgtv,zgmp,wgtp,tmax(100),omax(103)

      real intw(lx1,lx1)
      real intt(lx1,lx1)
      real wk1  (lx1,lx1,lx1,lelt)
      real wk2  (lx1,lx1,lx1)
      real zgmv(lx1),wgtv(lx1),zgmp(lx1),wgtp(lx1)
c
c     outpost arrays
      parameter (lt=lx1*ly1*lz1*lelv)
      common /scruz/ w1(lt),w2(lt),w3(lt),wt(lt)

      character*18 sfmt

      integer icalld
      save    icalld
      data    icalld /0/

      logical if_fltv

      ncut = modes !+1

      imax = nid
      imax = iglmax(imax,1)
      jmax = iglmax(imax,1)

      if (modes.eq.0) return

      if (icalld.eq.0) then
         icalld = 1
         call build_new_filter(intv,zgm1,lx1,ncut,wght,nio)
      elseif (icalld.lt.0) then   ! old (std.) filter
         icalld = 1
         call zwgll(zgmv,wgtv,lxv)
         call igllm(intuv,intw,zgmv,zgm1,lxv,lx1,lxv,lx1)
         call igllm(intdv,intw,zgm1,zgmv,lx1,lxv,lx1,lxv)
c
c        Multiply up and down interpolation into single operator
c
         call mxm(intuv,lx1,intdv,lxv,intv,lx1)
c
c        Weight the filter to make it a smooth (as opposed to truncated)
c        decay in wave space

         w0 = 1.-wght
         call ident   (intuv,lx1)
         call add2sxy (intv ,wght,intuv,w0,lx1*lx1)

      endif

      ifldt  = ifield
      ifield = 1

      call filterq(q,intv,lx1,lz1,wk1,wk2,intt,if3d,qmax)

      mmax = 0
      if (ifflow) then
         mmax = ldim  !??????????
      endif
         

      ifield = ifldt   ! RESTORE ifield

      return
      end

      subroutine set_mean_filter(z, x, wr, hdl)
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'
C       Sets a median filter of handle hdl, with window size wr around
C       each node. Only works on uniform grids.

      real z(lx1,lz1,lelx,lelz),x(lx1,lz1,lelx,lelz)
      real wr
      integer hdl

      common /m_avg/ delx(lx1), delz(lz1), 
     & maskx_l(lx1,2*lx1,2,4),maskx_r(lx1,2*lx1,2,4),deltx(2*lx1,4),
     & maskz_l(lz1,2*lz1,2,4),maskz_r(lz1,2*lz1,2,4),deltz(2*lz1,4)

      integer i,j,ex,ez
      integer ip,ipp,k,elpp,elp, im,el
      real summ,del_l,del_r,wdw,del
      real kx(lx1),kz(lx1)


      integer icalld
      save    icalld
      data    icalld /0/

      wdw=0.5*wr*(x(8,1,1,1)-x(1,1,1,1)) !in x
      if (nid.eq.0)
     & write(*,*) 'Mean filter handle:',hdl,'Window size in x:',wdw*2.

      if (icalld.eq.0) then
         icalld = 1
          do i =1,lx1-1
            delx(i)=x(i+1,1,1,1)-x(i,1,1,1)
          enddo
          delx(lx1)=0.0

          do i =1,lz1-1
            delz(i)=z(1,i+1,1,1)-z(1,i,1,1)
          enddo
          delz(lz1)=0.0

          do i=1,lx1*2*lx1*2*4
            maskx_r(i,1,1,1)=0.0
            maskx_l(i,1,1,1)=0.0
            maskz_r(i,1,1,1)=0.0
            maskz_l(i,1,1,1)=0.0
          enddo
      endif
        

      do i=1,lx1
        k=2
        del=0.0
        maskx_r(i,1,1,hdl)=i
        maskx_r(i,2,1,hdl)=i
        del=delx(i)*2
        do
          ip=i+k-1
          el=0
          if (ip.gt.lx1) then
            ip=ip-lx1
            el=1
          endif
          del=del+delx(ip)
          kx(i)=k
          if (del.gt.wdw) exit
          deltx(i,hdl)=del
          maskx_r(i,k+1,1,hdl)=ip
          maskx_r(i,k+1,2,hdl)=el
          k=k+1
        enddo
        k=1
        del=0.0
        do
          ip=i-k
          el=0
          if (ip.lt.1) then
            ip=ip+lx1
            el=-1
          endif
          del=del+delx(ip)
          deltx(i,hdl)=deltx(i,hdl)+delx(ip)
          maskx_l(i,k,1,hdl)=ip
          maskx_l(i,k,2,hdl)=el
          kx(i)=kx(i)+1
          if (del.gt.wdw) exit
          k=k+1
        enddo
      enddo  

      wdw=0.5*wr*(z(1,8,1,1)-z(1,1,1,1)) !in z
      if (nid.eq.0)
     & write(*,*) 'Window size in z:',wdw*2.


      do i=1,lz1
        k=2
        del=0.0
        maskz_r(i,1,1,hdl)=i
        maskz_r(i,2,1,hdl)=i
        del=delz(i)*2
        do
          ip=i+k-1
          el=0
          if (ip.gt.lz1) then
            ip=ip-lz1
            el=1
          endif
          del=del+delz(ip)
          if (del.gt.wdw) exit
          deltz(i,hdl)=del
          maskz_r(i,k+1,1,hdl)=ip
          maskz_r(i,k+1,2,hdl)=el
          kz(i)=k
          k=k+1
        enddo
        k=1
        del=0.0
        do
          ip=i-k
          el=0
          if (ip.lt.1) then
            ip=ip+lz1
            el=-1
          endif
          del=del+delz(ip)
          deltz(i,hdl)=deltz(i,hdl)+delz(ip)
          maskz_l(i,k,1,hdl)=ip
          maskz_l(i,k,2,hdl)=el
          kz(i)=kz(i)+1
          if (del.gt.wdw) exit
          k=k+1
        enddo
      enddo  

      if (nid.eq.0) then
         write(6,6) 'window x',(deltx(k,hdl),k=1,lx1)
         write(6,6) 'nodes x',(kx(k),k=1,lx1)
         write(6,6) 'window z',(deltz(k,hdl),k=1,lx1)
         write(6,6) 'nodes z',(kz(k),k=1,lx1)
   6   format(a8,16f7.4,6(/,8x,16f7.4))
      endif
c

      return
      end

      subroutine mean_filter(q,hdl)
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'


      real q(lx1,lz1,lelx,lelz)
      integer hdl

      common /m_avg/ delx(lx1), delz(lz1),
     & maskx_l(lx1,2*lx1,2,4),maskx_r(lx1,2*lx1,2,4),deltx(2*lx1,4),
     & maskz_l(lz1,2*lz1,2,4),maskz_r(lz1,2*lz1,2,4),deltz(2*lz1,4)

      real wk1(lx1,lz1,lelx,lelz)
      integer i,j,ex,ez,k
      integer ip,im,elp,elm,nxz
      real summ,del_l,del_r,wdw,del

      nxz=lx1*lz1*lelx*lelz


      do ez=1,lelz
        do ex=1,lelx
          do j=1,lz1
            do i=1,lx1
              q(i,j,ex,ez)=q(i,j,ex,ez)*delx(i)
            enddo
          enddo
        enddo
      enddo
C     first x
      do ez=1,lelz
        do ex=1,lelx
          do j=1,lz1
            do i=1,lx1
              summ=0.0
              del=deltx(i,hdl)
              do k=1,2*lx1
               ip=int(maskx_r(i,k,1,hdl))
               if (ip.eq.0) exit
               elp=int(maskx_r(i,k,2,hdl))
               if (ex.eq.lelx .and. elp.ge.1 .and. IF_FAN) then
                summ=summ+0.0
                del=del-delx(ip)
              elseif (ex.eq.lelx .and. elp.ge.1 .and. .not. IF_FAN) then
                summ=summ+q(ip,j,elp,ez)
               else
                summ=summ+q(ip,j,ex+elp,ez)
               endif
              enddo
              do k=1,2*lx1
               ip=int(maskx_l(i,k,1,hdl))
               if (ip.eq.0) exit
               elp=int(maskx_l(i,k,2,hdl))
               if (ex.eq.1 .and. elp.lt.0 .and. IF_FAN) then
                summ=summ+0.0
                del=del-delx(ip)
               elseif (ex.eq.1 .and. elp.lt.0 .and. .not. IF_FAN) then
                summ=summ+q(ip,j,lelx,ez)
               else
                summ=summ+q(ip,j,ex+elp,ez)
               endif
              enddo
              wk1(i,j,ex,ez)=summ*delz(j)/del
            enddo
          enddo
        enddo
      enddo


C     now z
      do ez=1,lelz
        do ex=1,lelx
          do j=1,lz1
            do i=1,lx1
              summ=0.0
              del=deltz(j,hdl)
              do k=1,2*lz1
               ip=int(maskz_r(j,k,1,hdl))
               if (ip.eq.0) exit
               elp=int(maskz_r(j,k,2,hdl))
               if (ez.eq.lelz .and. elp.ge.1 ) then
                summ=summ+0
                del=del-delz(ip)
               else
               summ=summ+wk1(i,ip,ex,ez+elp)
               endif
              enddo
              do k=1,2*lz1
               ip=int(maskz_l(j,k,1,hdl))
               if (ip.eq.0) exit
               elp=int(maskz_l(j,k,2,hdl))
               if (ez.eq.1 .and. elp.lt.0) then
                summ=summ+0
                del=del-delz(ip)
               else
                summ=summ+wk1(i,ip,ex,ez+elp)
               endif
              enddo
              q(i,j,ex,ez)=summ/del
            enddo
          enddo
        enddo
      enddo

      return
      end


      subroutine gaussian_filter_setup(z,x,std_z,std_x,kernelz,
     & kernelx,mask_gf)

      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real z(lx1,lz1,lelx,lelz),x(lx1,lz1,lelx,lelz)
      real std_x,std_z

      parameter (lx1tp=2*lx1+1)
      real kernelx(lx1,lx1tp),
     & kernelz(lx1,lx1tp)
      integer mask_gf(lx1,lx1tp,2)
     

      real delx(lx1),delz(lx1), deltx(lx1,2*lx1+1), deltz(lx1,2*lx1+1)
      real ksx,ksz,dumm, del_x, del_z
      integer i,j,k,nxz
      integer ip, el
      nxz=lx1*lz1*lelx*lelz

      do i =1,lx1-1
        delx(i)=x(i+1,1,1,1)-x(i,1,1,1)
      enddo
      delx(lx1)=0.0
      do i =1,lz1-1
        delz(i)=z(1,i+1,1,1)-z(1,i,1,1)
      enddo

      if (nid.eq.0) then 
        write(*,*) 'Gaussian filter setup..................'
        write(*,*) 'Element size in x:',x(lx1,1,1,1), 'sigma_x:',std_x
        write(*,*) 'Element size in z:',z(1,lx1,1,1), 'sigma_z:',std_z
      endif

      do i=1,lx1
        deltx(i,lx1+1)=0.0
        deltz(i,lx1+1)=0.0
        mask_gf(i,lx1+1,1)=i
        mask_gf(i,lx1+1,2)=0

        del_x=0.0
        del_z=0.0
        do k=lx1+2,lx1tp
         ip=i+k-lx1-1
         el=0
         if (ip.gt.lx1) then
           ip=ip-lx1
           el=1
         endif
         del_x=del_x+delx(ip-1)
         deltx(i,k)=del_x
         del_z=del_z+delz(ip-1)
         deltz(i,k)=del_z
         mask_gf(i,k,1)=ip
         mask_gf(i,k,2)=el
        enddo
        del_x=0.0
        del_z=0.0
        do k=lx1,1,-1
          ip=i+k-lx1-1
          el=0
          if (ip.lt.1) then
           ip=ip+lx1
           el=-1
          endif
          del_x=del_x-delx(ip)
          deltx(i,k)=del_x
          del_z=del_z-delz(ip)
          deltz(i,k)=del_z
          mask_gf(i,k,1)=ip
          mask_gf(i,k,2)=el
        enddo
        ksx=0.0
        ksz=0.0
        do k=1,lx1tp
         dumm=-1.0*(deltx(i,k)**2)/(2.0*std_x**2)
         kernelx(i,k)=exp(dumm)
         if (mask_gf(i,k,1).eq.lx1) kernelx(i,k)=0.0
         ksx=ksx+kernelx(i,k)
         dumm=-1.0*(deltz(i,k)**2)/(2.0*std_z**2)
         kernelz(i,k)=exp(dumm)
         if (mask_gf(i,k,1).eq.lx1) kernelz(i,k)=0.0
         ksz=ksz+kernelz(i,k)
        enddo
        do k=1,lx1tp
          kernelx(i,k)=kernelx(i,k)/ksx
          kernelz(i,k)=kernelz(i,k)/ksz
        enddo
      enddo

      return
      end


      subroutine gaussian_filter(q,kernelz, kernelx,mask_gf)

      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'
C       Beware with edge boundaries, node lx1 = 0!!

      real q(lx1,lz1,lelx,lelz)
      parameter (lx1tp=2*lx1+1)
      real kernelx(lx1,lx1tp), kernelz(lx1,lx1tp)
      integer mask_gf(lx1,lx1tp,2)

      integer i,j,k,ex,ez,nxz, im,em
      real wq(lx1,lz1,lelx,lelz)
      real dumm1,dumm2
      nxz=lx1*lz1*lelx*lelz

      call rzero(wq,nxz)
C       first x
      do ez=1,lelz
        do ex=1,lelx
          do j=1,lz1
            do i=1,lx1
              dumm1=q(i,j,ex,ez)
              do k=1,lx1tp
               im=mask_gf(i,k,1)
               em=mask_gf(i,k,2)
               if (ex.eq.lelx .and. em.ge.1) then
                if (IF_FAN) then
                  cycle !I'm ignoring some bad edge behavior here, I'll fix it some day
                else
                  wq(im,j,em,ez)=wq(im,j,em,ez)+dumm1*kernelx(i,k)
                 endif
                elseif (ex.eq.1 .and. em.lt.0) then
                 if (IF_FAN) then
                   cycle
                 else
                   wq(im,j,lelx+1+em,ez)=wq(im,j,lelx+1+em,ez)  !if em=-1, ex=lelx
     &                                   +dumm1*kernelx(i,k)
                 endif
                else
                  wq(im,j,ex+em,ez)=wq(im,j,ex+em,ez)+dumm1*kernelx(i,k)
               endif
              enddo
            enddo
          enddo
        enddo
      enddo

C       now z
      call rzero(q,nxz)

      do ez=1,lelz
        do ex=1,lelx
          do j=1,lz1
            do i=1,lx1
              dumm1=wq(i,j,ex,ez)
              do k=1,lx1tp
               im=mask_gf(j,k,1)
               em=mask_gf(j,k,2)
               if (ez.eq.lelz .and. em.ge.1) then
                  cycle
               elseif (ez.eq.1 .and. em.lt.0) then
                  cycle
               else
                  q(i,im,ex,ez+em)=q(i,im,ex,ez+em)+dumm1*kernelz(j,k)
               endif
              enddo
            enddo
          enddo
        enddo
      enddo

      return
      end

      subroutine read_inflow_sem(in_dns,inpoints,in_bulk)
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'
C       include 'PARALLEL'

      real in_dns(600,15)
C       integer inpoints
      real in_bulk,inpoints
      integer i,j 
      real dum(600,15)
      real rdum

      if(nid.eq.0) then
        write(6,*) 'Reading inflow data.....'
        open(53,file='inflow.dat',status='old')
        read(53,*) inpoints
        read(53,*) in_bulk
c     y, u_m, v_m, w_m, t_m, a11, a21, a22, a31, a32, a33, a41, a42, a43, a44 
        do i=1,int(inpoints)
          read(53,*) (in_dns(i,j),j=1,15)
        enddo
        close(53)
      endif
      call rzero(dum,600*15)
      call gop(in_dns,dum,'+  ',600*15)
      rdum=0.0
      call gop(inpoints,rdum,'+  ',1)
C       call bcast(npoints,isize)
      rdum=0.0
      call gop(in_bulk,rdum,'+  ',1)

      return
      end


      subroutine interp_inflow_sem(in_dns,npoints,yline,in_dns_interp,
     &  n_eddies,si_eddies,yinlet)
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      parameter(ny=nelyin*lx1)
      parameter(nel_slab = nelxin*nelyin)
      parameter(nelin = nelxin*nelyin*lx1*ly1)

      real in_dns(600,15)
      real yline(ny)
      integer npoints,n_eddies
      real in_dns_interp(lx1,ly1,nel_slab,14)
      real si_eddies
      real yinlet(lx1,ly1,nel_slab)

    
      real w1t(ly1,lely),w2t(ly1,lely)
      real y_inflow(npoints),dum(npoints)
      real wintr3(npoints), wintr2(npoints)
      real dum2(ny,14)
      real dumr
      integer i,j,iel,k

      do i=1,npoints
        y_inflow(i)=in_dns(i,1)
      enddo
      
      if (.TRUE.) then
        do j=1,14
          do i=1,npoints
           dum(i)=in_dns(i,j+1)
          enddo
          do iel=1,nel_slab
            do k=1,ly1
              do i=1,lx1
            call interp1(y_inflow,dum,npoints,yinlet(i,k,iel),
     &        in_dns_interp(i,k,iel,j))
              enddo
            enddo
          enddo
        enddo
      endif

      dumr=0.0
      do i=2,ny
        if (yline(i)-yline(i-1).gt.dumr) dumr=yline(i)-yline(i-1)
      enddo
      si_eddies=dumr/0.5                    !<--------------------Change
      dumr=(xlen_inflow+2.0*si_eddies)*
     &      (hf+2.0*si_eddies)*2.0*si_eddies
      n_eddies=min(int(dumr/(si_eddies**3)),5000)

      if (nid.eq.0) write(*,*)'Eddy size=',si_eddies,
     &                ', number of eddies= ',n_eddies

      return
      end

      subroutine gen_inflow_sem(vxin_pl,vyin_pl,vzin_pl,tin_pl
     &           ,n_eddies,si_eddies,in_bulk,in_dns_interp,
     &           dtimestep,xinlet,yinlet)

      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      parameter(nel_slab = nelxin*nelyin)
      parameter(nelin = nelxin*nelyin*lx1*ly1)
      integer n_eddies
      real si_eddies,in_bulk,dtimestep

      real in_dns_interp(lx1,ly1,nel_slab,14)

      real vxin_pl(lx1,ly1,nel_slab)
     $    ,vyin_pl(lx1,ly1,nel_slab)
     $    ,vzin_pl(lx1,ly1,nel_slab)
     $    ,tin_pl(lx1,ly1,nel_slab)
     $    ,xinlet(lx1,ly1,nel_slab)
     $    ,yinlet(lx1,ly1,nel_slab)

      real perx(lx1,ly1,nel_slab) !it0s not needed to be an array, but let's leave it like that for now
     $    ,pery(lx1,ly1,nel_slab)
     $    ,perz(lx1,ly1,nel_slab)
     $    ,pert(lx1,ly1,nel_slab)

      integer proc(2)

      real Vb(3)
      real rdum,fx,fy,fz,fac,fs


      real in_eds(5000,7)
      save in_eds
      real dum1(5000,7)
      real dum2(lx1,ly1,nel_slab)

      integer icalld
      save icalld
      data icalld  /0/

      integer i,j,k, iy, ix, iel, idum


      idum=int(n_eddies/np)
      if (nid.lt.np-1)then
        proc(1)=nid*idum+1
        proc(2)=nid*idum+idum
      elseif (nid.eq.np-1) then
        proc(1)=nid*idum+1
        proc(2)=n_eddies
      else
        proc(1)=-1
        proc(2)=-1
      endif

      Vb(1)=xlen_inflow+2.0*si_eddies
      Vb(2)=hf+2.0*si_eddies
      Vb(3)=2.0*si_eddies


      fac=(Vb(1)*Vb(2)*Vb(3)*si_eddies**(-3.0))**0.5

      if (istep.eq.0) then
      if ( nid.eq.0) then !eddies placement
        do i=1,n_eddies
          call RANDOM_NUMBER(rdum)
          in_eds(i,1)=Vb(1)*rdum
          call RANDOM_NUMBER(rdum)
          in_eds(i,2)=Vb(2)*rdum
          call RANDOM_NUMBER(rdum)
          in_eds(i,3)=Vb(3)*rdum-si_eddies
          do j=1,4
            call RANDOM_NUMBER(rdum)
            in_eds(i,j+3)=int((10*rdum)/5)*2-1
          enddo
        enddo
       endif
      call rzero(dum1,5000*7)
      call gop(in_eds,dum1,'+  ',5000*7)
      endif

      if(istep.gt.0) then
      if (nid.eq.0) then
      do i=1,n_eddies  
        in_eds(i,3)=in_eds(i,3)+in_bulk*dtimestep !advect eddies
        if (in_eds(i,3).gt.si_eddies) then !if they get out of the box, regenerate them on the other side
          in_eds(i,3)=-si_eddies
          call RANDOM_NUMBER(rdum)
          in_eds(i,1)=Vb(1)*rdum
          call RANDOM_NUMBER(rdum)
          in_eds(i,2)=Vb(2)*rdum
          do j=1,4
            call RANDOM_NUMBER(rdum)
            in_eds(i,j+3)=int((10*rdum)/5)*2-1
          enddo
        endif
      enddo
      else
        call rzero(in_eds,5000*7)
      endif
      call rzero(dum1,5000*7)
      call gop(in_eds,dum1,'+  ',5000*7)
      endif


      call rzero(perx,nelin)
      call rzero(pery,nelin)
      call rzero(perz,nelin)
      call rzero(pert,nelin)


      do iel=1,nel_slab !generate perturbations
        do iy=1,ly1
          do ix=1,lx1
C             idum=iy*(int(iel/nelxin)+1)
            if (proc(1).gt.0)then
             do k=proc(1),proc(2)
                fx=0.0
                fy=0.0
                fz=0.0
                rdum=(xinlet(ix,iy,iel)-in_eds(k,1))/si_eddies
                if (abs(rdum).lt.1) fx=1.5**0.5*(1.0-abs(rdum))
                rdum=(yinlet(ix,iy,iel)-in_eds(k,2))/si_eddies
                if (abs(rdum).lt.1) fy=1.5**0.5*(1.0-abs(rdum))
                rdum=(0.0-in_eds(k,3))/si_eddies
                if (abs(rdum).lt.1) fz=1.5**0.5*(1.0-abs(rdum))
                fs=fac*fx*fy*fz

                perx(ix,iy,iel)=perx(ix,iy,iel)+fs*in_eds(k,4)
                pery(ix,iy,iel)=pery(ix,iy,iel)+fs*in_eds(k,5)
                perz(ix,iy,iel)=perz(ix,iy,iel)+fs*in_eds(k,6)
                pert(ix,iy,iel)=pert(ix,iy,iel)+fs*in_eds(k,7)
             enddo
           endif
          enddo
        enddo
      enddo

      call rzero(dum2,nelin)
      call gop(perx,dum2,'+  ',nelin)
      call rzero(dum2,nelin)
      call gop(pery,dum2,'+  ',nelin)
      call rzero(dum2,nelin)
      call gop(perz,dum2,'+  ',nelin)
      call rzero(dum2,nelin)
      call gop(pert,dum2,'+  ',nelin)


      do iel=1,nel_slab !multiply by Reynolds stress tensor cholesky decomposition and add to means.
        do iy=1,ly1
          do ix=1,lx1
             rdum=perx(ix,iy,iel)*in_dns_interp(ix,iy,iel,5)
             rdum=rdum*(1.0/n_eddies**0.5) 
             vxin_pl(ix,iy,iel)=in_dns_interp(ix,iy,iel,1)+rdum

             rdum=perx(ix,iy,iel)*in_dns_interp(ix,iy,iel,6)+
     &            pery(ix,iy,iel)*in_dns_interp(ix,iy,iel,7)
             rdum=rdum*(1.0/n_eddies**0.5) 
             vyin_pl(ix,iy,iel)=in_dns_interp(ix,iy,iel,2)+rdum

             rdum=perx(ix,iy,iel)*in_dns_interp(ix,iy,iel,8)+
     &            pery(ix,iy,iel)*in_dns_interp(ix,iy,iel,9)+
     &            perz(ix,iy,iel)*in_dns_interp(ix,iy,iel,10)
             rdum=rdum*(1.0/n_eddies**0.5) 
             vzin_pl(ix,iy,iel)=in_dns_interp(ix,iy,iel,3)+rdum

             rdum=perx(ix,iy,iel)*in_dns_interp(ix,iy,iel,11)+
     &            pery(ix,iy,iel)*in_dns_interp(ix,iy,iel,12)+
     &            perz(ix,iy,iel)*in_dns_interp(ix,iy,iel,13)+
     &            pert(ix,iy,iel)*in_dns_interp(ix,iy,iel,14)
             rdum=rdum*(1.0/n_eddies**0.5) 
             tin_pl(ix,iy,iel)=in_dns_interp(ix,iy,iel,4)+rdum
          enddo
        enddo
      enddo


      return
      end

      subroutine inlet_plane(ua,u,w1)
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
      parameter(nel_slab=nelxin*nelyin)

      real ua(nx1,ny1,nel_slab),u(nx1,ny1,nz1,nelt),w1(nx1,ny1,nel_slab)


      integer e,eg,ex,ey,ez, mxy ,elm

      mxy=nx1*ny1*nel_slab
      call rzero(ua,mxy)
      call rzero(w1,mxy)

      do e=1,nelt
c
         eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)

         k = 1
         if (ey.le.nelyin .and. ex.le.nelxin .and. ez.eq.1) then
            do j=1,ny1
            do i=1,nx1
              elm=(ey-1)*nelxin+ex
              ua(i,j,elm) = u(i,j,k,e)
            enddo
            enddo
         endif
      enddo

      call gop(ua,w1,'+  ',mxy)


      return
      end


      subroutine interp1(xa,ya,n,x,y)
      integer n
      real xa(n),ya(n)
      
      integer klo,khi
      real h
      klo=1
      khi=n
    1   if ((khi-klo).gt.1) then
           k=(khi+klo)/2
           if (xa(k).gt.x) then
              khi=k
           else
              klo=k
           endif
           goto 1
        endif
      h=xa(khi)-xa(klo)
      if (h.eq.0) then
          y=ya(khi)
         return
      endif
      y=ya(klo)+(x-xa(klo))*((ya(khi)-ya(klo))/h)
      return
      end


c-----------------------------------------------------------------------
      subroutine eddy_visc(ediff,e,s,msij)
c
c     Compute eddy viscosity using dynamic smagorinsky model
c
      include 'SIZE'
      include 'TOTAL'

      real ediff(nx1*ny1*nz1,nelv),s(lx1*ly1*lz1,ldim,ldim)
      integer e

      common /dynsmg/ sij (lx1*ly1*lz1,ldim,ldim)
     $              , mij (lx1*ly1*lz1,3*ldim-3)
     $              , lij (lx1*ly1*lz1,3*ldim-3)
     $              , dg2 (lx1*ly1*lz1,lelv)
     $              , num (lx1*ly1*lz1,lelv)
     $              , den (lx1*ly1*lz1,lelv)
     $              , snrm(lx1*ly1*lz1,lelv)
      real sij,mij,lij,dg2,num,den,snrm,numy,deny,yy
      real msij(lx1*ly1*lz1,lelv)

      parameter(lxyz=lx1*ly1*lz1)
      common /xzmp0/ ur (lxyz) , us (lxyz) , ut (lxyz)
      real           vr (lxyz) , vs (lxyz) , vt (lxyz)
     $     ,         wr (lxyz) , ws (lxyz) , wt (lxyz)
      common /xzmp1/ w1(lx1*lelv),w2(lx1*lelv)

      !! NOTE CAREFUL USE OF EQUIVALENCE HERE !!
      equivalence (vr,lij(1,1)),(vs,lij(1,2)),(vt,lij(1,3))
     $          , (wr,lij(1,4)),(ws,lij(1,5)),(wt,lij(1,6))

      common /sgsflt/ fh(lx1*lx1),fht(lx1*lx1),diag(lx1)

      integer nt
      save    nt
      data    nt / -9 /

      ntot = nx1*ny1*nz1

      if (nt.lt.0) call
     $   set_ds_filt(fh,fht,nt,diag,nx1)! dyn. Smagorinsky filter

c      call comp_gije(sij,vx(1,1,1,e),vy(1,1,1,e),vz(1,1,1,e),e)
c      call comp_sije(sij)
      call copy(sij,s,lx1*ly1*lz1*ldim*ldim)
      call mag_tensor_e(snrm(1,e),sij)
      call cmult(snrm(1,e),2.0,ntot)
      call copy(msij,snrm,lx1*ly1*lz1*lelv)
      call set_grid_spacing(dg2)
      call comp_mij   (mij,sij,dg2,ur,us,fh,fht,nt,e)
      call comp_lij   (lij,vx,vy,vz,ur,us,ut,fh,fht,e)

c     Compute numerator (ur) & denominator (us) for Lilly contraction

      n = nx1*ny1*nz1
      do i=1,n
         ur(i) = mij(i,1)*lij(i,1)+mij(i,2)*lij(i,2)+mij(i,3)*lij(i,3)
     $      + 2*(mij(i,4)*lij(i,4)+mij(i,5)*lij(i,5)+mij(i,6)*lij(i,6))
         us(i) = mij(i,1)*mij(i,1)+mij(i,2)*mij(i,2)+mij(i,3)*mij(i,3)
     $      + 2*(mij(i,4)*mij(i,4)+mij(i,5)*mij(i,5)+mij(i,6)*mij(i,6))
      enddo

c     smoothing numerator and denominator in time
      call copy (vr,ur,nx1*nx1*nx1)
      call copy (vs,us,nx1*nx1*nx1)

      beta1 = 0.0                   ! Temporal averaging coefficients
      if (istep.gt.1) beta1 = 0.9   ! Retain 90 percent of past
      beta2 = 1. - beta1

      do i=1,n
         num (i,e) = beta1*num(i,e) + beta2*vr(i)
         den (i,e) = beta1*den(i,e) + beta2*vs(i)
      enddo


      return
      end

      subroutine eddy_visc_01(ediff,uni,w1,igs_x)
c
c     Compute eddy viscosity using dynamic smagorinsky model
c
      include 'SIZE'
      include 'TOTAL'

      real ediff(nx1*ny1*nz1,nelv),uni(lx1*ly1*lz1,nelv)
      real w1(lx1,ly1,lz1,nelv)
      integer igs_x

      common /dynsmg/ sij (lx1*ly1*lz1,ldim,ldim)
     $              , mij (lx1*ly1*lz1,3*ldim-3)
     $              , lij (lx1*ly1*lz1,3*ldim-3)
     $              , dg2 (lx1*ly1*lz1,lelv)
     $              , num (lx1*ly1*lz1,lelv)
     $              , den (lx1*ly1*lz1,lelv)
     $              , snrm(lx1*ly1*lz1,lelv)
      real sij,mij,lij,dg2,num,den,snrm

      integer ntot

      ntot = lx1*ly1*lz1*lelv


      call dsavg(num)   ! average across element boundaries
      call dsavg(den)

      call planar_avg(w1,num,igs_x) !x averaging
      call copy(num,w1,ntot)
      call planar_avg(w1,den,igs_x) !x averaging
      call copy(den,w1,ntot)


      do i=1,lx1*ly1*lz1*lelv
         cdyn = 0
         if (den(i,1).gt.0) cdyn = 0.5*num(i,1)/den(i,1)
         cdyn = cdyn*uni(i,1)
c         cdyn = max(cdyn,0.)
         ediff(i,1) = param(2)+max(cdyn*dg2(i,1)*snrm(i,1),0.d0)
      enddo

      return
      end


c-----------------------------------------------------------------------
      subroutine set_ds_filt(fh,fht,nt,diag,nx) ! setup test filter

      INCLUDE 'SIZE'

      real fh(nx*nx),fht(nx*nx),diag(nx)

c Construct transfer function
      call rone(diag,nx)

      diag(nx-0) = 0.01
      diag(nx-1) = 0.10
      diag(nx-2) = 0.50
      diag(nx-3) = 0.90
      diag(nx-4) = 0.99
      nt = nx - 2

c      diag(nx-0) = 0.05
c      diag(nx-1) = 0.50
c      diag(nx-2) = 0.95
c      nt = nx - 1

      call build_1d_filt(fh,fht,diag,nx,nid)

      return
      end
c-----------------------------------------------------------------------
      subroutine set_grid_spacing(dg2)
c
c     Compute D^2, the grid spacing used in the DS sgs model.
c
      include 'SIZE'
      include 'TOTAL'


      real dg2(nx1,ny1,nz1,nelv)

      integer e,eg,ex,ey,ez

      gamma = 1.
      gamma = gamma/ndim

      n = nx1*ny1*nz1*nelv
      call rone(dg2,n)
      return          ! Comment this line for a non-trivial Delta defn

      do e=1,nelv

         do k=1,nz1
           km = max(1  ,k-1)
           kp = min(nz1,k+1)

           do j=1,ny1
             jm = max(1  ,j-1)
             jp = min(ny1,j+1)

             do i=1,nx1
               im = max(1  ,i-1)
               ip = min(nx1,i+1)

               di = (xm1(ip,j,k,e)-xm1(im,j,k,e))**2
     $            + (ym1(ip,j,k,e)-ym1(im,j,k,e))**2
     $            + (zm1(ip,j,k,e)-zm1(im,j,k,e))**2

               dj = (xm1(i,jp,k,e)-xm1(i,jm,k,e))**2
     $            + (ym1(i,jp,k,e)-ym1(i,jm,k,e))**2
     $            + (zm1(i,jp,k,e)-zm1(i,jm,k,e))**2

               dk = (xm1(i,j,kp,e)-xm1(i,j,km,e))**2
     $            + (ym1(i,j,kp,e)-ym1(i,j,km,e))**2
     $            + (zm1(i,j,kp,e)-zm1(i,j,km,e))**2

               di = di/(ip-im)
               dj = dj/(jp-jm)
               dk = dk/(kp-km)
               dg2(i,j,k,e) = (di*dj*dk)**gamma

             enddo
           enddo
         enddo
      enddo

      call dsavg(dg2)  ! average neighboring elements

      return
      end

c-----------------------------------------------------------------------
      subroutine comp_lij(lij,u,v,w,fu,fv,fw,fh,fht,e)
c
c     Compute Lij for dynamic Smagorinsky model:
c                    _   _      _______
c          L_ij  :=  u_i u_j  - u_i u_j
c
      include 'SIZE'
c
      integer e
c
      real lij(lx1*ly1*lz1,3*ldim-3)
      real u  (lx1*ly1*lz1,lelv)
      real v  (lx1*ly1*lz1,lelv)
      real w  (lx1*ly1*lz1,lelv)
      real fu (1) , fv (1) , fw (1)
     $   , fh (1) , fht(1)

      call tens3d1(fu,u(1,e),fh,fht,nx1,nx1)  ! fh x fh x fh x u
      call tens3d1(fv,v(1,e),fh,fht,nx1,nx1)
      call tens3d1(fw,w(1,e),fh,fht,nx1,nx1)

      n = nx1*ny1*nz1
      do i=1,n
         lij(i,1) = fu(i)*fu(i)
         lij(i,2) = fv(i)*fv(i)
         lij(i,3) = fw(i)*fw(i)
         lij(i,4) = fu(i)*fv(i)
         lij(i,5) = fv(i)*fw(i)
         lij(i,6) = fw(i)*fu(i)
      enddo

      call col3   (fu,u(1,e),u(1,e),n)    !  _______
      call tens3d1(fv,fu,fh,fht,nx1,nx1)  !  u_1 u_1
      call sub2   (lij(1,1),fv,n)

      call col3   (fu,v(1,e),v(1,e),n)    !  _______
      call tens3d1(fv,fu,fh,fht,nx1,nx1)  !  u_2 u_2
      call sub2   (lij(1,2),fv,n)

      call col3   (fu,w(1,e),w(1,e),n)    !  _______
      call tens3d1(fv,fu,fh,fht,nx1,nx1)  !  u_3 u_3
      call sub2   (lij(1,3),fv,n)

      call col3   (fu,u(1,e),v(1,e),n)    !  _______
      call tens3d1(fv,fu,fh,fht,nx1,nx1)  !  u_1 u_2
      call sub2   (lij(1,4),fv,n)

      call col3   (fu,v(1,e),w(1,e),n)    !  _______
      call tens3d1(fv,fu,fh,fht,nx1,nx1)  !  u_2 u_3
      call sub2   (lij(1,5),fv,n)

      call col3   (fu,w(1,e),u(1,e),n)    !  _______
      call tens3d1(fv,fu,fh,fht,nx1,nx1)  !  u_3 u_1
      call sub2   (lij(1,6),fv,n)

      return
      end
c-----------------------------------------------------------------------
      subroutine comp_mij(mij,sij,dg2,fs,fi,fh,fht,nt,e)
c
c     Compute Mij for dynamic Smagorinsky model:
c
c                     2 _  ____     _______
c          M_ij  :=  a  S  S_ij  -  S  S_ij
c
      include 'SIZE'
c
      integer e
c
      real mij(lx1*ly1*lz1,3*ldim-3)
      real dg2(lx1*ly1*lz1,lelv)
      real fs (1) , fi (1) , fh (1) , fht(1)

      real magS(lx1*ly1*lz1)
      real sij (lx1*ly1*lz1*ldim*ldim)

      integer imap(6)
      data imap / 0,4,8,1,5,2 /

      n = nx1*ny1*nz1

      call mag_tensor_e(magS,sij)
      call cmult(magS,2.0,n)

c     Filter S
      call tens3d1(fs,magS,fh,fht,nx1,nx1)  ! fh x fh x fh x |S|

c     a2 is the test- to grid-filter ratio, squared

      a2 = nx1-1       ! nx1-1 is number of spaces in grid
      a2 = a2 /(nt-1)  ! nt-1 is number of spaces in filtered grid

      do k=1,6
         jj = n*imap(k) + 1
         call col3   (fi,magS,sij(jj),n)
         call tens3d1(mij(1,k),fi,fh,fht,nx1,nx1)
     $        ! fh x fh x fh x (|S|S_ij)
         call tens3d1(fi,sij(jj),fh,fht,nx1,nx1)  ! fh x fh x fh x S_ij
         do i=1,n
            mij(i,k) = (a2**2 * fs(i)*fi(i) - mij(i,k))*dg2(i,e)
         enddo
      enddo

      return
      end

      subroutine spanwise_copy(u,wo1)
c     This copies a 2d y-z array into a 3d array
      include 'SIZE'
      include 'GEOM'
      include 'ZPER'
      include 'PARALLEL'
      include 'WZ'


      real u(ly1,lz1,lely,lelz)
      real wo1(lx1,ly1,lz1,lelv)
      integer e,eg,ex,ey,ez


      nxz=ly1*lz1*lely*lelz
      nxyz=lx1*lz1*ly1*lelv
      call rzero(wo1,nxyz)

      do e=1,nelt
         eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
          do k=1,nz1
            do j=1,ny1
              do i=1,nx1
                wo1(i,j,k,e) = u(j,k,ey,ez)
              enddo
            enddo
          enddo
      enddo

      return
      end
