c- Spatially evolving turbidity currents in periodic channels
c- Inflow: Synthetic eddy method (Jarrin 2006) 
c- Simulation parameters -----------------------------------------------------------
#define RITAU uparam(1)                         /* Ri_tau */
#define UTARGET uparam(2)                       /* u_target for top PML, positive */ 
#define BC_FLAG_TEMP uparam(3)                  /*0-> Depositional grad(T) dot n=0, 1-> Bypass mode: (1/Pe)*grad(T) dot n = -|Vs*T| dot n  2-> Parker erosion: (1/Pe)*grad(T) dot n = |Vs*Es| dot n */
#define time_inflow uparam(4)                   /* Duration of inflow flow */   

#define RE_TAU (1/param(2))                     /* Re_tau */
#define PACKING_FR 0.6

c- Increased viscosity outflow parameters ----------------------------------
#define VISCFAC 5.0
#define B_OUTLET 30.0                      /*Lenght of the bottom outlet. Only used if greater than 0*/
#define ZBUFF (ZLEN-50)
#define YBUFF (YLEN-4.)

c- Exner equation parameters -----------------------------------------------
#define THRESHOLD 0.001                        /*concentration integration threshold */
#define EPS_EXNER 0.010                        /*epsilon for numerical diffusion in Exner equation*/
#define STD_EXNER_QX 3.5                       /*Gaussian filter standard deviation for div q, as a fraction of the elements size*/
#define STD_EXNER_QZ 3.5                       /*Gaussian filter standard deviation for div q, as a fraction of the elements size*/
#define MV_STEP 10                             /*Mesh eigenvalues will be updated every MV_STEP steps*/
#define IN_ZL 10.0                             /*Inlet zone for Exner equation*/
#define OUT_ZL 40.0                            /*Outlet zone for Exner equation*/

c- I/O parameters -----------------------------------------------------------
#define restart_inflow uparam(11)                 /* whether to read inflow2d.ini (2d) for restasting */
#define restart_bed uparam(12)                    /* whether to read bedform.ini for restasting */
#define restart_means abs(uparam(13))/uparam(13)  /* whether to read means.ini for means restasting (>0)*/
#define iostep_2d_avg_time  abs(uparam(13))       /* output frequency for spanwise-time-averaged statistics */
#define mean_time_start abs(uparam(14))           /* start time for means accumulation */
#define iostep_2d_notime uparam(15)               /* output frequency for spanwise-averaged statistics*/
#define iostep_bed abs(uparam(16))                /* output frequency for bedform file, if uparam(16) lt 0, bedform calculations are skipped*/

c - mesh and buffer zones dimensions
#define PI (4.*atan(1.))
#define YLEN uparam(8)
#define ZLEN (uparam(9)*PI)
#define XLEN (8.0*PI/3.0)
#define NUMBER_ELEMENTS_X lelx
#define NUMBER_ELEMENTS_Y lely
#define NUMBER_ELEMENTS_Z lelz


#define nelyint 18         /*number of elements in the higher resolution zone*/
#define hint 6             /*height of heigher resolution zone*/

c - Iflow dimensions
#define nelxin lelx              /*number of elements of inflow array */
#define nelyin 9

#define xlen_inflow (8.0*PI/3.0) /* width of inflow domain*/
#define hf 2.0                   /*height of inflow domain*/

c - Sediment properties
#define def_RE_P  (/0.7829/)            /*Particle Reynolds numbers*/
#define def_Vs  (/0.0/)        /*Settling velocities*/
#define def_alpha  (/1.0/)        /*alpha*/
#define def_gamma  (/1.0/)           /*Inlet volume fractions*/
#define Cv 8.0e-2                        /*Volume mean concentration*/


c - flags    -----------------------------------------------------------
#define IF_FAN lelx .ne. nelxin           /*Whether the simulation corresponds to a fan */
#define IF_BED uparam(16).gt.0.0          /*Whether bedform calculations are done (uparam(16) greater than 0) */
#define IF_SHCR_VAR .TRUE.                /*Whether the critical Shields number depends on the bed angle */
#define IF_ALL_BED .TRUE.                 /*Whether all the bedform stats are saved or only the heights */
#define IF_GEO_REST .FALSE.              /*Whether geometry will be restored after loading the IC*/
#define IF_MVMESH .FALSE.                  /*Whether the mesh at the bottom will be deformed by the bedform.*/
#define IF_DIVQ .TRUE.                    /*Whether to include sediment flux (-div q) in Exner equation.*/    
#define IF_EROS .TRUE.                    /*Whether to include sediment entrainment (-E_s) in Exner equation.*/    
#define IF_DEPO .TRUE.                    /*Whether to include sediment deposition (C_b) in Exner equation.*/    
#define IF_HIS .FALSE.                     /*Whether to save history points*/
#define IF_SMAG .TRUE.                     /*Whether eddy diffusivity is used*/
#define inflow_flag .FALSE.                /*Whether to inflow will be finite*/
#define ODong_flag .FALSE.                  /*Whether to use Dong BC at the outlet. If not, a PML will be used*/
#define IF_ICSEM   .FALSE.                  /*Whether copy inlet in the domain for IC*/


      subroutine uservp (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      include 'ZPER'  ! for nelx,nely,nelz

c     TURBULENT OUTFLOW
c     Sets low Re number in range [zout;lenz]
      real zout,zdiff, dumr
      real xdiff, xout, xlen
      real tanz, tany, tmul, buffRe
      integer ex,ey,ez, ie

      common /cdsmag/ ediff(lx1,ly1,lz1,lelv)
      common /pml/ ewcalc, if_pml, z_front, zp_front, smul

       
      zout = ZBUFF                             
      zdiff=ZLEN-zout


      ie = gllel(eg)



      if(ifield.eq.1)then                          ! momentum equation
         utrans= param(1)
         udiff = param(2)

        if (z.ge.zout)then
            udiff =((param(2)*VISCFAC-param(2))/zdiff)
     $            *(z-zout) + param(2)
        endif
      else                      ! temperature eqn
        utrans= param(7)
        udiff = param(8)
        if (z.ge.zout) then
          udiff =((param(8)*VISCFAC - param(8))/zdiff)
     $           *(z-zout) + param(8)
        endif
      endif

      buffRe = 2000
      if (IF_SMAG .and. ifield.eq.1) then
         udiff = udiff + ediff(ix,iy,iz,ie)

         if (udiff.le.0.0) then
              udiff = 1.0/buffRe !thie should never be needed, but just in case
         endif

      endif !IF_SMAG


      if (if_pml .eq. 2) then !dong bc at top bc. Increase visc near the bc
        dumr = YLEN - 2.0
        tany = (1. + tanh((y - dumr)/0.5))/2.0
        if (tany .gt. 1e-4) then
           udiff = udiff + udiff * tany *10.0
        endif
      endif


      return
      end
c-----------------------------------------------------------------------
      subroutine userf  (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      include 'ZPER'  ! for nelx,nely,nelz


      real*8 egrav(3)
      real conc
C     HYDROSTATIC PRESSURE VARIABLES
      common /TBAR/ tempbar(ly1,lely)

      integer ex,ey,ez

c     BUFFER ZONE VARIABLES
      real*8 sigma2(3),sigmam1(3),sigmam2(3),beta  !changed sigma to sigma2
     $        ,umean1(3),umean2(3),yy,zz,m,vzout,zz2, zpml, zh1, theta1
      real dumr, beta2, tanz, tany, a1, a2, ydum
      
      common /pml/ ewcalc, if_pml, z_front, zp_front, smul
      common /outflow_pl/ vzout_pl(lx1,ly1,lelx,lely)

      call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)

      conc = temp
      do ips=1,npscal
         conc = conc +ps(ips) 
      enddo

c     MESH VARIABLES 
      egrav(1) = 0.0                         !x: Spanwise direction
      egrav(2) = -1.0*RITAU                  !y: Wall-normal direction
      egrav(3) = 1.0                         !z: Streamwise direction


      ffx = conc*egrav(1)
      ffz = conc*egrav(3)

      if (inflow_flag .or. B_OUTLET .gt. 0.0) then
         ffy = conc*egrav(2)
      else
        ffy = (conc - tempbar(iy,ey))*egrav(2) !substract hydrostatic pressure
      endif

c     ############################################################


c     ############################################################
      if (if_pml.eq.1)then
c     Buffer zones
        sigmam1(1) = 0.0                          !<-----------------CHANGE!
        sigmam1(2) = 10.0                          !<-----------------CHANGE!
        sigmam1(3) = 0.0                          !<-----------------CHANGE!

        sigmam2(1) = 0.0                          !<-----------------CHANGE!
        sigmam2(2) = 0.0                          !<-----------------CHANGE!
        sigmam2(3) = 0.0                          !<-----------------CHANGE!

        beta = 2.0                                !<-----------------CHANGE!

        umean1(1) = 0.0                           !<-----------------CHANGE! 
        umean1(2) = -UTARGET 
        umean1(3) = 0.0                           !<-----------------CHANGE! 
        
        umean2(1) = 0.0                           !<-----------------CHANGE! 
        umean2(2) = 0.0                           !<-----------------CHANGE! 
        umean2(3) = 0.0                           !<-----------------CHANGE! 

        m=(YLEN-YBUFF)/
     &   (ZLEN
     &    -ZBUFF)
        zz = (y-YBUFF)/m 
     & + ZBUFF
        yy = m * (z-ZBUFF)
     & + YBUFF

c     ###############
c     Top buffer zone
        sigma2(1) = 0.0
        sigma2(2) = 0.0
        sigma2(3) = 0.0
        if (y.ge.YBUFF.and.z.le.zz) then
          sigma2(1) = sigmam1(1)*((y - YBUFF)/
     &      (YLEN-YBUFF))**(beta)
          sigma2(2) = sigmam1(2)*((y - YBUFF)/
     &       (YLEN-YBUFF))**(beta)
          sigma2(3) = sigmam1(3)*((y - YBUFF)/
     &       (YLEN-YBUFF))**(beta)

          ffx = ffx - sigma2(1) * (ux - umean1(1))
          ffy = ffy - sigma2(2) * (uy - umean1(2)) 
          ffz = ffz - sigma2(3) * (uz - umean1(3))
        endif
      endif !if_pml.eq.1
c     ###################

c     Outflow buffer zone
      if(.not. ODong_flag .and. B_OUTLET .le. 0.0) then
          sigma2(1) = 0.0
          sigma2(2) = 0.0
          sigma2(3) = 0.0

          sigmam2(1) = 0.0                          !<-----------------CHANGE!
          sigmam2(2) = 0.0                          !<-----------------CHANGE!
          sigmam2(3) = 10.0                        !<-----------------CHANGE!

          umean2(1) = 0.0                           !<-----------------CHANGE! 
          umean2(2) = 0.0                           !<-----------------CHANGE! 
          umean2(3) = 0.0                           !<-----------------CHANGE!

          beta = 2.0

          zz2=(z-ZBUFF)/
     &      (ZLEN
     &      -ZBUFF)
          m=(YLEN-YBUFF)/
     &   (ZLEN
     &    -ZBUFF)
          yy = m * (z-ZBUFF)
     & + YBUFF

          vzout = vzout_pl(ix,iy,ex,ey)
C           if (z.ge.ZBUFF
C      &      .and.y.lt.yy.and.vzout.lt.0.0) then
          if (z.ge.ZBUFF .and.vzout.lt.0.0) then
            sigma2(1) = sigmam2(1)*(zz2)**(beta)
            sigma2(2) = sigmam2(2)*(zz2)**(beta)
            sigma2(3) = sigmam2(3)*(zz2)**(beta)

            ffx = ffx - sigma2(1) * (ux - umean2(1))
            ffy = ffy - sigma2(2) * (uy - umean2(2))
            ffz = ffz - sigma2(3) * (uz - umean2(3))
          endif
      endif

       if(B_OUTLET .gt. 0.0) then
          sigma2(1) = 0.0
          sigma2(2) = 10.0
          sigma2(3) = 10.0

          umean2(1) = 0.0                           !<-----------------CHANGE! 
          umean2(2) = -0.1                           !<-----------------CHANGE! 
          umean2(3) = 1.0                           !<-----------------CHANGE!

          beta = 2.0   ! tanh shape factor on z
          beta2 = 2.0   ! tanh shape factor on y

          dumr = ZLEN - B_OUTLET + 0.0 !outflow start position

          
          tanz = (1. + tanh((z - (dumr + 10.))/beta))/2.0
          tany = (1. + tanh(-1.*(y - YBUFF)/beta2))/2.0
          
          sigma2(1) = sigma2(1) * tanz * tany
          sigma2(2) = sigma2(2) * tanz * tany
          sigma2(3) = sigma2(3) * tanz * tany

          if (tanz.gt.1e-4) then
            if (uy.gt.0.0) then
              ffy = ffy - sigma2(2) * (uy - umean2(2))
            endif
            if (uz.lt.0.0) then
              ffz = ffz - sigma2(3) * (uz - umean2(3))
            endif
          endif
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine userq  (ix,iy,iz,eg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'

      common /VS_GRADT/ vsgradt(lx1,ly1,lz1,lelt,ldimt)
      integer e,f,eg
      real dumr


      e = gllel(eg)

      do ips=1,ldimt
        if (ifield.eq.ips+1) qvol  = -1.0*vsgradt(ix,iy,iz,e,ips)
      enddo

      source = 0.0

      return
      end

c-----------------------------------------------------------------------

      subroutine userchk
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'  ! for nelx,nely,nelz

c     ############################################################
      integer nelin,nel_slab,nin
      real rlenz,z_inflow,dz_inflow
      real dtimestep

      parameter(nel_slab=nelxin*nelyin)

      integer if_mean_2d
      save if_mean_2d

      integer counter_inflow
      save counter_inflow


      common /inflow_pl/ vxin_pl(lx1,ly1,nel_slab)
     $                  ,vyin_pl(lx1,ly1,nel_slab)
     $                  ,vzin_pl(lx1,ly1,nel_slab)
     $                  ,tin_pl(lx1,ly1,nel_slab)
      save z_inflow
      real theta

c     spanwise-averaged arrays
      real    yavgx(ny1,nz1,lely,lelz)
     $    ,   zavgx(ny1,nz1,lely,lelz)

      common /avgstats/
     &  rumm(lx1,ly1,lz1,lelt,4)
     & , ru2m(lx1,ly1,lz1,lelt,4)
     & , ruvm(lx1,ly1,lz1,lelt,6)
     & , ruxm(lx1,ly1,lz1,lelt,12)
     & , rux2(lx1,ly1,lz1,lelt,12)
     & , ru3m(lx1,ly1,lz1,lelt,4)
     & , rv2u(lx1,ly1,lz1,lelt,6)
     & , rpmm(lx1,ly1,lz1,lelt,4)
     & , summ(lx1,ly1,lz1,lelt,4)
     & , su2m(lx1,ly1,lz1,lelt,4)
     & , suvm(lx1,ly1,lz1,lelt,6)
     & , suxm(lx1,ly1,lz1,lelt,12)
     & , sux2(lx1,ly1,lz1,lelt,12)
     & , su3m(lx1,ly1,lz1,lelt,4)
     & , sv2u(lx1,ly1,lz1,lelt,6)
     & , spmm(lx1,ly1,lz1,lelt,4)
     & , summ_2d(ly1,lz1,lely,lelz,3)
     & , summT_2d(ly1,lz1,lely,lelz,ldimt)
     & , su2m_2d(ly1,lz1,lely,lelz,3)
     & , su2mT_2d(ly1,lz1,lely,lelz,ldimt)
     & , suvm_2d(ly1,lz1,lely,lelz,6)
     & , suxm_2d(ly1,lz1,lely,lelz,12)
     & , sux2_2d(ly1,lz1,lely,lelz,12)
     & , su3m_2d(ly1,lz1,lely,lelz,4)
     & , sv2u_2d(ly1,lz1,lely,lelz,6)
     & , spmm_2d(ly1,lz1,lely,lelz,4)


      common /avgstats_old/
     &  summ_2d_o(ly1,lz1,lely,lelz,4)
     & , su2m_2d_o(ly1,lz1,lely,lelz,4)
     & , suvm_2d_o(ly1,lz1,lely,lelz,6)
     & , suxm_2d_o(ly1,lz1,lely,lelz,12)
     & , sux2_2d_o(ly1,lz1,lely,lelz,12)
     & , su3m_2d_o(lx1,ly1,lely,lelz,4)
     & , sv2u_2d_o(lx1,ly1,lely,lelz,6)
     & , spmm_2d_o(lx1,ly1,lely,lelz,4)
     & ,timem,atimem,timelm,dtimem,t_tot

      integer counter1

      integer if_write_means, if_write_meansnt
      integer counter_mean
      save counter_mean
      data    counter_mean /0/
      integer counter_meansnt
      save counter_meansnt
      data    counter_meansnt /0/
      integer counter_lci
      save counte_lci
      data    counter_lci /0/

      logical ifverbose
      real wo1(lx1,ly1,lz1,lelv)
     &      ,  wo2(lx1,ly1,lz1,lelv)
     &      ,  wo3(lx1,ly1,lz1,lelv)
     &      ,  wo4(lx1,ly1,lz1,lelv)
     &      ,  wo5(lx1,ly1,lz1,lelv)
     &      ,  wo6(lx1,ly1,lz1,lelv)


      real             w1(ly1,lz1,lely,lelz)
     &              ,  w2(ly1,lz1,lely,lelz)
     &              ,  w3(ly1,lz1,lely,lelz)
     &              ,  w4(ly1,lz1,lely,lelz)
     &              ,  wy1(ly1,nely)
     &              ,  wy2(ly1,nely)
      save igs_x, igs_z, igs_y

      integer e,ex,ey,ez,eg

      common /pml/ ewcalc, if_pml, z_front, zp_front, smul
      real yheight(lx1,ly1,lz1,lelv)
      save yheight
      real dumwo(lx1,lz1,lelx,lelz)
      common /utop_read/ v_top1, v_top2

c     2d spanwise-averaged arrays 
      real v2d(ly1,lz1,lely,lelz),w2d(ly1,lz1,lely,lelz),
     &     y2d(ly1,lz1,lely,lelz),z2d(ly1,lz1,lely,lelz),
     &     tt2d(ly1,lz1,lely,lelz)


c     depth-averaged arrays
      real zavgxy(nz1,lelz)


c     Interface position array (intr) and threshold delta
      real intr(nz1,lelz)

c     average in time variables
      integer icalled
      save    icalled
      data    icalled /0/

      real atime,timel
      save atime,timel
      real alpha,beta
      integer n,nt

      integer icnt_time
      save    icnt_time
      data    icnt_time /0/

      integer icnt
      save    icnt
      data    icnt /0/
c
      character*32 istepc,outfile

      character*80 icfile
c
c     Gradient arrays 
      real vxx(lx1,ly1,lz1,lelv),
     $     vxy(lx1,ly1,lz1,lelv),
     $     vxz(lx1,ly1,lz1,lelv),
     $     vyx(lx1,ly1,lz1,lelv),
     $     vyy(lx1,ly1,lz1,lelv),
     $     vyz(lx1,ly1,lz1,lelv),
     $     vzx(lx1,ly1,lz1,lelv),
     $     vzy(lx1,ly1,lz1,lelv),
     $     vzz(lx1,ly1,lz1,lelv),
     $     tx(lx1,ly1,lz1,lelv,npscal+1),
     $     ty(lx1,ly1,lz1,lelv,npscal+1),
     $     tz(lx1,ly1,lz1,lelv,npscal+1)

      real lci(lx1,ly1,lz1,lelv)

c     ############################################################
C       parameter(INTP_NMAX=ly1*lz1*lely*lelz)
      parameter(mz=lz1*lelz*3)
      parameter(myint=ly1*lely*3)

      real ymm(ly1,lz1,lely,lelz)
      save ymm
      real deltaz ,zdum
      save deltaz,zdum
      real  wintr3(myint), wintr2(myint)
      save wintr3,wintr2

c     ############################################################
c     HYDROSTATIC PRESSURE VARIABLES
      common /TBAR/ tempbar(ly1,lely)
      real w1t(ly1,lely),w2t(ly1,lely)
      
      common /VS_GRADT/ vsgradt(lx1,ly1,lz1,lelt,ldimt)
      common /VS_VEC/ vs(3,ldimt)
      
      common /outflow_pl/ vzout_pl(lx1,ly1,lelx,lely)
      real vzout_pldum(lx1,ly1,lelx,lely)

      parameter (llt=lx1*ly1*lz1*lelt)
      common /cmygeom/ xmo(llt),ymo(llt),zmo(llt)

      parameter (n_slab=ly1*nelyin)
      real wslab(n_slab)
      common /inflow_interp/ y_slab(n_slab)

      common /dongVel/ maxvel

      common /v_filter/ vx_f(lx1,ly1,lz1,lelv),vy_f(lx1,ly1,lz1,lelv),
     &                  vz_f(lx1,ly1,lz1,lelv),t_f(lx1,ly1,lz1,lelv)
c      Exner variables
      real wxz1(lx1,lz1,lelx,lelz),wxz2(lx1,lz1,lelx,lelz), !working arrays
     &     wxz3(lx1,lz1,lelx,lelz),
     &     btt(lx1,lz1,lelx,lelz, ldimt),  !bottom concentration
     &     btuy(lx1,lz1,lelx,lelz),  !bottom dvx/dy
     &     btwy(lx1,lz1,lelx,lelz),  !bottom dvz/dy
     &     btvy(lx1,lz1,lelx,lelz),  !bottom dvy/dy
     &     sh_x(lx1,lz1,lelx,lelz),  !Shields number
     &     sh_z(lx1,lz1,lelx,lelz),  !Shields number
     &     sh_cr(lx1,lz1,lelx,lelz),  !Critical Shields number
     &     qbx(lx1,lz1,lelx,lelz),   !Bottom sediment flux
     &     qbz(lx1,lz1,lelx,lelz),  !Bottom sediment flux
     &     int_t(lx1,lz1,lelx,lelz,ldimt),
     &     qbxx(lx1,lz1,lelx,lelz),
     &     qbzz(lx1,lz1,lelx,lelz),
     &     theta_bedx(lx1,lz1,lelx,lelz),
     &     theta_bedz(lx1,lz1,lelx,lelz),
     &     B_eta(lx1,lz1,lelx,lelz),
     &     lap_eta(lx1,lz1,lelx,lelz),
     &     bed_normal(lx1,lz1,lelx,lelz,3),
     &     bed_wk(lx1,lz1,lelx,lelz,3),
     &     sn(3)


      real normdum
      integer nxz

      common /erosion/ E_s(lx1,lz1,lelx,lelz,ldimt)

      common /heights/ eta(lx1,lz1,lelx,lelz),
     &               eta_e(lx1,lz1,lelx,lelz),
     &               eta_d(lx1,lz1,lelx,lelz),
     &               eta_q(lx1,lz1,lelx,lelz)

      common /eta_mvbc/ umeshx(lx1,ly1,lz1,lelv)
     &              , umeshy(lx1,ly1,lz1,lelv)
     &              , umeshz(lx1,ly1,lz1,lelv)
     &              , rhs(lx1,lz1,lelx,lelz)
      real dtprev
      save dtprev

      real zbmm(lx1,lz1,lelx,lelz), xbmm(lx1,lz1,lelx,lelz) !mesh at the bottom
      save xbmm, zbmm

      real time_restart
      save time_restart

      real in_dns(600,15)
      real in_bulk,in_npoints,si_eddies
      save in_bulk,in_npoints,si_eddies
C       integer in_npoints
      real yline(n_slab)
      real in_dns_interp(lx1,ly1,nel_slab,14)
      save in_dns_interp
      integer n_eddies
      save n_eddies
      real yinlet(lx1,ly1,nel_slab),xinlet(lx1,ly1,nel_slab)
      save yinlet,xinlet
      real w_inlet(lx1,ly1,nel_slab)

      real minDum, maxDum
      real dumr, offset
c     ############################################################

c     LES parameters-----------------------------------
      common /cdsmag/ ediff(lx1,ly1,lz1,lelv)
      real sijdum(lx1*ly1*lz1,ldim,ldim)
      save sijdum

      real  lan_msij(lx1,ly1,lz1,lelt)
      real  lan_cs2s(lx1,ly1,lz1,lelt)

c     ############################################################
      real Re_pp(ldimt),V_sp(ldimt),sp_fraction(ldimt),
     & alpha_fraction(ldimt)

      Re_pp = def_RE_P
      V_sp = def_Vs
      sp_fraction = def_gamma
      alpha_fraction = def_alpha
c     ############################################################


      nelx  = NUMBER_ELEMENTS_X
      nely  = NUMBER_ELEMENTS_Y
      nelz  = NUMBER_ELEMENTS_Z
      n=nx1*ny1*nz1*nelv  
      nt=nx1*ny1*nz1*nelt
      m=ny1*nz1*nely*nelz
      nxz=nx1*nz1*nelx*nelz
c     Restore geometry after loading the IC 
      if (istep.eq.0 .and. IF_GEO_REST) then      
       call opcopy(xm1,ym1,zm1,xmo,ymo,zmo)  ! Restore my geometry
       call geom_reset(1)                    ! Force regen. of Jacobians 
      endif


c     ############################################################
      if(nid.eq.0 .and. istep.eq.0) then
        write(*,*)'*************SIMULATION PARAMETERS******************'
        write(*,*)'+Mesh parameters:'
        write(*,*)'xlen = ',XLEN
     &           ,'ylen = ',YLEN,'zlen = ',ZLEN
        write(*,*)'lelx = ',lelx,'lely = ',lely,'lelz = ',lelz,
     &            'N = ',lx1-1
        write(*,*)'+Boundary Conditions:'
        if (BC_FLAG_TEMP.eq.0) then
          write(*,*)'Bottom BC : dc/dn = 0'
        elseif (BC_FLAG_TEMP.eq.1) then
          write(*,*)'Bottom BC : (1/Pe) dc/dn = -|V_s.C_b|'
        else
          write(*,*)'Bottom BC : (1/Pe) dc/dn = -|V_s.E_s|'
        endif
        if (if_pml .eq. 1) then
          write(*,*)'Top BC : Perfectly Matched Layer with u_target = ',
     &    UTARGET
        elseif (if_pml .eq. 0) then
          write(*,*)'Top BC : Fixed inflow velocity u_top = ',
     &   -1.0*UTARGET   
        elseif(if_pml.eq.2) then
          write(*,*)'Top BC : Dong BC'
        endif
        if (B_OUTLET .gt. 0.0) write(*,*)'Outlet type : Bottom outlet'
        write(*,*)'+Input parameters:'
        write(*,*)'Re_tau = ',RE_TAU
        write(*,*)'Ri_tau = ',RITAU
        write(*,*)'Duration of inflow flow = ', time_inflow 
        write(*,*)'Settling velocity(ies) = ', (V_sp(i),i=1,ldimt)
        write(*,*)'+Derived parameters:'         
        write(*,*)'theta 1 (degrees)= ',180*atan(1/RITAU)/PI
        write(*,*)'**********END OF SIMULATION PARAMETERS**************'
      endif

C       if (istep.eq.0) then
C         do i = 1, n
C         if (zm1(i,1,1,1).gt.((ZLEN-B_OUTLET) + 5.0)) then
C             vx(i,1,1,1) = 0.0
C             vy(i,1,1,1) = 0.0
C             vz(i,1,1,1) = 0.0
C             t(i,1,1,1,1) = 0.0
C         endif
C        enddo
C       endif
c
c     ############################################################
c     Settling velocity of sediment (absolute value)
c     COMPUTE VS*GRAD(TEMP) (STORED IN VSGRADT)
c
c     Settling velocity
      vs(1,1) = 0.0
      vs(2,1) = (-1.0)*V_sp(1)
      vs(3,1) = 0.0
      do ips=1,npscal
        vs(1,ips+1)=0.0
        vs(2,ips+1)=(-1.0)*V_sp(ips+1)
        vs(3,ips+1)=0.0
      enddo

c     Compute grad(t)
      call gradm1(tx(1,1,1,1,1),ty(1,1,1,1,1),
     &            tz(1,1,1,1,1),t(1,1,1,1,1))
      do ips=1,npscal
        call gradm1(tx(1,1,1,1,ips+1),ty(1,1,1,1,ips+1),
     &              tz(1,1,1,1,ips+1),t(1,1,1,1,ips+1))
      enddo

c     Compute vs*grad(t)
      do i=1,n
          vsgradt(i,1,1,1,1) =  vs(1,1) * tx(i,1,1,1,1) +
     $                        vs(2,1) * ty(i,1,1,1,1) +
     $                        vs(3,1) * tz(i,1,1,1,1)
        do ips=1,npscal
          vsgradt(i,1,1,1,ips+1) =  vs(1,ips+1) * tx(i,1,1,1,ips+1) +
     $                        vs(2,ips+1) * ty(i,1,1,1,ips+1) +
     $                        vs(3,ips+1) * tz(i,1,1,1,ips+1)
        enddo
      enddo


c     ############################################################
      if (.FALSE.) then

      if (0.25*aint((time-time_restart)/0.25)
     &  .ge.counter_lci*0.25)  then 
          counter_lci = counter_lci +1 
          call lambdaci(lci)
C          ifpo=.true.
          ifpo=.true.
          ifxyo = .false.
          call outpost2(vx,vy,vz,lci,t,1,'lci')
          ifpo=.false.
       endif

      endif

      theta=0.0

      dtimestep = abs(dt)
c     ############################################################
c
c     INTERPOLATE INLET DATA AND SET INFLOW CONDITION USING
C     THE SYNTHETIC EDDY METHOD (Jarrin 2006)
c

      if (istep.eq.0) then
        call yslab(y_slab,ym1,wslab,n_slab,nelyin)

        call inlet_plane(yinlet,ym1,w_inlet, 0.0)
        call inlet_plane(xinlet,xm1,w_inlet, 0.0)
        call yslab(y_slab,ym1,wslab,n_slab,nelyin)

        call read_inflow_sem(in_dns,in_npoints,in_bulk,si_eddies)
        if (nid.eq.0) write(*,*) 'Inflow points=',int(in_npoints),
     &                         ', bulk velocity=',in_bulk , 
     &                         ', k^(3/2)/diss=',si_eddies 
C       call y_line(yline,ym1,w1t,w2t)
         call interp_inflow_sem(in_dns,int(in_npoints)
     &  ,y_slab,in_dns_interp,n_eddies,si_eddies,yinlet)

      endif

      call gen_inflow_sem(vxin_pl,vyin_pl,vzin_pl,tin_pl
     &           ,n_eddies,si_eddies,in_bulk,in_dns_interp,
     &            dtimestep,xinlet,yinlet)
    
      if (istep.eq.0 .and. IF_ICSEM) then
          call set_ic_sem()
      endif

    


c     ############################################################
c     OUTPUT INITIAL CONDITION
      if (istep.eq.0) then
c        call gfldr("200.ini")
        ifxyo = .true.
        call prepost(.true.,'   ' )
        if (.not. IF_MVMESH) ifxyo = .false.
        call print_yz_mesh
        call print_xz_mesh
        time_restart = time
      endif 


c     ############################################################
      if (istep.eq.0) then 
        call x_slice(ymm,ym1,w1,w2)
        call y_slice(zbmm,zm1,wxz1)
        call y_slice(xbmm,xm1,wxz1)
        call rzero(eta,size(eta))
        call rzero(eta_q,size(eta_q))
        call rzero(eta_e,size(eta_e))
        call rzero(eta_d,size(eta_d))
      endif
      if(icalled.eq.0) then
        call rzero(rumm,size(rumm))
        call rzero(ru2m,size(ru2m))
        call rzero(ruvm,size(ruvm))
        call rzero(ruxm,size(ruxm))
        call rzero(rux2,size(rux2))
        call rzero(ru3m,size(rux2))
        call rzero(rv2u,size(rux2))
        call rzero(rpmm,size(rux2))
        call gtpp_gs_setup(igs_x,nelx,nely,  nelz,1) ! x-avx
        call gtpp_gs_setup(igs_z,nelx*nely,1,nelz,3) ! z-avx
        call gtpp_gs_setup(igs_y,nelx,nely,  nelz,2) ! y-avx

        atime = 0.
        timel = time
        icalled = 1
      endif !(icalled.eq.0)

c     ############################################################
c     COMPUTE HYDROSTATIC PRESSURE (AVERAGE OF TEMP(y))
c     FOR REFERENCE ON THIS TERM SEE CANTERO 2009 JGR
      if (.not. inflow_flag .and. B_OUTLET .le. 0.0) then
        call copy(wo3,t(1,1,1,1,1),n)
        do ips=1,npscal
           call add2(wo3,t(1,1,1,1,ips+1),n)
        enddo
        call planar_avg(wo1,wo3,igs_x)
        call planar_avg(wo2,wo1,igs_z)
        call y_line(tempbar,wo2,w1t,w2t)
      endif

      maxvel = glmax(vz, size(vz))

      if (.not. ODong_flag .and. B_OUTLET .le. 0.0) 
     &  call vz_outflow(vzout_pl,vzout_pldum) !save outflow plane


c      ############################################################
c     Compute eddy viscosity using dynamic smagorinsky model
      if(istep.eq.0.and.IF_SMAG)then
         ifuservp  = .true.
         ifexplvis = .true.
         param(30) = 1
      endif

      if(ifuservp.and.IF_SMAG) then
C         if(nid.eq.0) write(*,*)'Calculating eddy viscosity'
          if(istep.eq.0)  call set_grid_spacing()

        do e=1,lelv
           call eddy_visc(ediff,e)
        enddo
C         call eddy_visc_01(ediff,var_eddy_comp,wo1,igs_x)
      call eddy_visc_01(ediff,wo1,igs_x)


      dumr = glmax(ediff,n)
        
      if (nid.eq.0) write(*,*) 'Max eddy viscosity', dumr

      endif


c     ############################################################

      if (param(15).ne.0) then !write control -> numsteps
        if (istep.gt.0 .and. mod(istep,int(iostep_2d_notime)).eq.0) then 
          if_write_meansnt = 1
        else
          if_write_meansnt = 0
        endif
        if (istep.eq.0) if_write_means = 1
      else  !write control -> time
       if (iostep_2d_notime*aint((time-time_restart)/iostep_2d_notime)
     &  .ge.counter_meansnt*iostep_2d_notime)  then 
          if_write_meansnt = 1
          counter_meansnt = counter_meansnt +1 
        else
          if_write_meansnt = 0
       endif
      endif

c     write 2d spanwise-averaged files 
      if(if_write_meansnt) then

          call planar_avg(wo1,vx,igs_x) 
          call x_slice2(wo1,w1)
          if (nid.eq.0) call x_slice3(summ_2d(1,1,1,1,1))

          call planar_avg(wo1,vy,igs_x) 
          call x_slice2(wo1,w1)
          if (nid.eq.0) call x_slice3(summ_2d(1,1,1,1,2))

          call planar_avg(wo1,vz,igs_x) 
          call x_slice2(wo1,w1)
          if (nid.eq.0) call x_slice3(summ_2d(1,1,1,1,3))

          do ips=1,ldimt
            call planar_avg(wo1,t(1,1,1,1,ips),igs_x) 
            call x_slice2(wo1,w1)
            if (nid.eq.0) call x_slice3(summT_2d(1,1,1,1,ips))
          enddo

          call col3(wo2,vx,vx,n)
          call planar_avg(wo1,wo2,igs_x) 
          call x_slice2(wo1,w1)
          if (nid.eq.0) call x_slice3(su2m_2d(1,1,1,1,1))
C           call copy(su2m_2d(1,1,1,1,1),tempbar, size(tempbar))


          call col3(wo2,vy,vy,n)
          call planar_avg(wo1,wo2,igs_x) 
          call x_slice2(wo1,w1)
          if (nid.eq.0) call x_slice3(su2m_2d(1,1,1,1,2))

          call col3(wo2,vz,vz,n)
          call planar_avg(wo1,wo2,igs_x) 
          call x_slice2(wo1,w1)
          if (nid.eq.0) call x_slice3(su2m_2d(1,1,1,1,3))

          do ips=1,ldimt
            call col3(wo2,t(1,1,1,1,ips),t(1,1,1,1,ips),n)
            call planar_avg(wo1,wo2,igs_x) 
            call x_slice2(wo1,w1)
            if (nid.eq.0) call x_slice3(su2mT_2d(1,1,1,1,ips))
          enddo

          call col3(wo2,vx,vy,n)
          call planar_avg(wo1,wo2,igs_x) 
          call x_slice2(wo1,w1)
          if (nid.eq.0) call x_slice3(suvm_2d(1,1,1,1,1))

          call col3(wo2,vx,vz,n)
          call planar_avg(wo1,wo2,igs_x) 
          call x_slice2(wo1,w1)
          if (nid.eq.0) call x_slice3(suvm_2d(1,1,1,1,2))

          call col3(wo2,vx,t(1,1,1,1,1),n)
          call planar_avg(wo1,wo2,igs_x) 
          call x_slice2(wo1,w1)
          if (nid.eq.0) call x_slice3(suvm_2d(1,1,1,1,3))

          call col3(wo2,vy,vz,n)
          call planar_avg(wo1,wo2,igs_x) 
          call x_slice2(wo1,w1)
          if (nid.eq.0) call x_slice3(suvm_2d(1,1,1,1,4))

          call col3(wo2,vy,t(1,1,1,1,1),n)
          call planar_avg(wo1,wo2,igs_x) 
          call x_slice2(wo1,w1)
          if (nid.eq.0) call x_slice3(suvm_2d(1,1,1,1,5))

          call col3(wo2,vz,t(1,1,1,1,1),n)
          call planar_avg(wo1,wo2,igs_x) 
          call x_slice2(wo1,w1)
          if (nid.eq.0) call x_slice3(suvm_2d(1,1,1,1,6))
          call nekgsync()

          if (param(15).ne.0) then !write control -> numsteps
            call output_2d(time,w4,istep)
          else
            call output_2d(time,w4,counter_meansnt)
          endif
      endif


      if(IF_HIS) call hpts()


c     ############################################################
c     Exner equation calculations
c     All this could and should be done only by nid.eq.0, I should fix that eventually, but I highly doubt that this is a performance issue.

c     First check for negative concentrations
      do ips=1,ldimt
        do i=1, n
            if (t(i,1,1,1,ips).lt.0.0) t(i,1,1,1,ips) = 0.0
        enddo
      enddo

c     --------------------------
      if (IF_BED.or.BC_FLAG_TEMP.eq.2) then    !FIX FOR SLOPE BREAK
C         call copy(t_f,t(1,1,1,1,1),n)
C         call gradm1(wo1,wo2,wo3,vx_f)
C         call gradm1(wo4,wo5,wo6,vz_f)
        if (restart_bed.ne.0) call read_bed(eta) !rewrite!!!!!!!!!!!!!
C          if (istep.eq.0) then
C C            call y_slice(eta,ym1,wxz1)
C          endif

        if (IF_MVMESH) then
          call bed_angle(eta,theta_bedx,theta_bedz,lap_eta,
     &               wo1,wo2,wo3,wo4,wxz1,wxz2,xbmm,zbmm) !computes bed angle and lap(eta)

          call copy(vx_f,vx,n)
          call copy(vy_f,vy,n)
          call copy(vz_f,vz,n)
          call stress_normal(btuy,btwy,wxz1,
     &                        theta_bedx,theta_bedz)

        else
          call gradm1(vxx,vxy,vxz,vx)
          call gradm1(vzx,vzy,vzz,vz)

          call y_slice(btuy,vxy,wxz1)  !btuy -> dux/dy at y=0
          call y_slice(btwy,vzy,wxz1)  !btwy -> duz/dy at y=0

        endif !if_mvmsh

        call bed_filter(btuy, zbmm, xbmm,0)
        call bed_filter(btwy, zbmm, xbmm,0)

        call parker_erosion(btuy,btwy)  !Compute Parker erosion model. In a common block because of userbc
        do ips=1,ldimt
          call y_slice(btt(1,1,1,1,ips),t(1,1,1,1,ips),wxz1)      !bottom concentration
        enddo
        do i=1,nxz
          do ips = 1, ldimt
            if(btt(i,1,1,1,ips).lt.(1e-3*sp_fraction(ips))) 
     &      E_s(i,1,1,1,ips) = 0.0
          enddo
        enddo

C         find aproximate front location
        z_front = 0.0
        do i=1,nxz
          do ips = 1, ldimt
            if(btt(i,1,1,1,ips).gt.(1e-3*sp_fraction(ips))) then
              if (zbmm(i,1,1,1) .gt. z_front) z_front = zbmm(i,1,1,1)
            endif
          enddo
        enddo

        if (nid.eq.0) write(*,*)'zfront', z_front

        do ips=1,ldimt
          call temp_threshold(t(1,1,1,1,ips),wo1)
          call col2(wo1,t(1,1,1,1,ips),n)
          call planar_avg(wo2,wo1,igs_y)
          call y_slice(int_t(1,1,1,1,ips),wo2,wxz1)  !integral of concentration in wall-normal direction
        enddo
        call bedform_calcs(btwy,btuy,btt,xbmm,zbmm,wo1,wo2,wo3,wo4,
     &                  igs_x,igs_y,igs_z,
     &                     wxz1,wxz2,wxz3,sh_x,sh_z,sh_cr,qbx,qbz,int_t,
     &               qbxx,qbzz,theta_bedx,theta_bedz,B_eta, lap_eta)

         if (IF_MVMESH)  then
           call eta_mvmesh()
           if (mod(istep,int(MV_STEP)).eq.0) then
            if_mvmine = .true.   !check line 280 of drive1.f, I added this flag
            if (nid.eq.0) write(*,*) 'Updating eigenvalues...........'
           else
            if_mvmine =.false.
           endif
         endif   
         minDum = glmin(E_s,size(E_s))
         maxDum = glmax(E_s,size(E_s))
         if(nid.eq.0) write(*,*) 'Min Es',minDum, 'Max Es',maxDum
         minDum = glmin(btt,size(btt))
         maxDum = glmax(btt,size(btt))
         if(nid.eq.0) write(*,*) 'Min Cb',minDum, 'Max Cb',maxDum
      endif !if_bed

c     ##################################################################
c      Time and spanwise averaging
c     ##################################################################
        if (time.lt.mean_time_start 
     &     .and.restart_means.gt.0)  return

      dtime = time - timel - mean_time_start
      atime = atime + dtime

      if (param(15).ne.0) then !write control -> numsteps
        if (istep.gt.0 .and.
     &   mod(istep,int(iostep_2d_avg_time)).eq.0) then 
          if_write_means = 1
        else
          if_write_means = 0
        endif
        if (istep.eq.0) if_write_means = 1
      else  !write control -> time
       if (iostep_2d_avg_time*aint((time-mean_time_start)/
     &  iostep_2d_avg_time).ge.
     &  counter_mean*iostep_2d_avg_time)  then 
          if_write_means = 1
          counter_mean = counter_mean +1 
        else
          if_write_means = 0
       endif
      endif

c     compute gradients
      call gradm1(vxx,vxy,vxz,vx)
      call gradm1(vyx,vyy,vyz,vy)
      call gradm1(vzx,vzy,vzz,vz)

c     call gradm1(tx,ty,tz,t(1,1,1,1,1)) !this is already computed in the settling velocity part

      if (istep.eq.1 .and. restart_means.lt.0) then
        call input_means(w1)

        do i=1,4
          call spanwise_copy(summ_2d_o(1,1,1,1,i),rumm(1,1,1,1,i))
        enddo
        do i=1,4
          call spanwise_copy(su2m_2d_o(1,1,1,1,i),ru2m(1,1,1,1,i))
        enddo
        do i=1,6
            call spanwise_copy(suvm_2d_o(1,1,1,1,i),ruvm(1,1,1,1,i))
        enddo
        do i=1,12
            call spanwise_copy(suxm_2d_o(1,1,1,1,i),ruxm(1,1,1,1,i))
        enddo
        do i=1,12
            call spanwise_copy(sux2_2d_o(1,1,1,1,i),rux2(1,1,1,1,i))
        enddo
        do i=1,4
            call spanwise_copy(su3m_2d_o(1,1,1,1,i),ru3m(1,1,1,1,i))
        enddo
        do i=1,6
            call spanwise_copy(sv2u_2d_o(1,1,1,1,i),rv2u(1,1,1,1,i))
        enddo
        do i=1,4
            call spanwise_copy(spmm_2d_o(1,1,1,1,i),rpmm(1,1,1,1,i))
        enddo

        atime = atimem

      endif


c     averaging over time
      if (atime.ne.0 .and. dtime.ne.0 .and. istep.ne.0 ) then
        beta      = dtime / atime
        if (uparam(14).lt.0) beta = 1.0   !means will not be accumulated on time. Not the most elegant solution, I know.
        alpha     = 1. - beta

        ifverbose = .false.
c       Compute time-average of u,v,w and t       
        call avg1(rumm(1,1,1,1,1),vx,alpha,beta,n,'uavg',ifverbose)
        call avg1(rumm(1,1,1,1,2),vy,alpha,beta,n,'vavg',ifverbose) 
        call avg1(rumm(1,1,1,1,3),vz,alpha,beta,n,'wavg',ifverbose) 
        call avg1(rumm(1,1,1,1,4),t, alpha,beta,n,'tavg',ifverbose)
c       Compute time-average of u^2,v^2,w^2 and t^2     
        call avg2(ru2m(1,1,1,1,1),vx,alpha,beta,n,'u2mm',ifverbose)
        call avg2(ru2m(1,1,1,1,2),vy,alpha,beta,n,'v2mm',ifverbose) 
        call avg2(ru2m(1,1,1,1,3),vz,alpha,beta,n,'w2mm',ifverbose) 
        call avg2(ru2m(1,1,1,1,4),t ,alpha,beta,n,'t2mm',ifverbose)

c       Compute time-average of cross products
        call avg3(ruvm(1,1,1,1,1),vx,vy,alpha,beta,n,'uvmm',ifverbose)
        call avg3(ruvm(1,1,1,1,2),vx,vz,alpha,beta,n,'uwmm',ifverbose)
        call avg3(ruvm(1,1,1,1,3),vx, t,alpha,beta,n,'utmm',ifverbose)
        call avg3(ruvm(1,1,1,1,4),vy,vz,alpha,beta,n,'vwmm',ifverbose)
        call avg3(ruvm(1,1,1,1,5),vy, t,alpha,beta,n,'vtmm',ifverbose)
        call avg3(ruvm(1,1,1,1,6),vz, t,alpha,beta,n,'wtmm',ifverbose)
c       Compute time-average of gradients     
        call avg1(ruxm(1,1,1,1,1),vxx,alpha,beta,n,'uxmm',ifverbose)
        call avg1(ruxm(1,1,1,1,2),vxy,alpha,beta,n,'uymm',ifverbose)
        call avg1(ruxm(1,1,1,1,3),vxz,alpha,beta,n,'uzmm',ifverbose)

        call avg1(ruxm(1,1,1,1,4),vyx,alpha,beta,n,'vxmm',ifverbose)
        call avg1(ruxm(1,1,1,1,5),vyy,alpha,beta,n,'vymm',ifverbose)
        call avg1(ruxm(1,1,1,1,6),vyz,alpha,beta,n,'vzmm',ifverbose)

        call avg1(ruxm(1,1,1,1,7),vzx,alpha,beta,n,'wxmm',ifverbose)
        call avg1(ruxm(1,1,1,1,8),vzy,alpha,beta,n,'wymm',ifverbose)
        call avg1(ruxm(1,1,1,1,9),vzz,alpha,beta,n,'wzmm',ifverbose)

        call avg1(ruxm(1,1,1,1,10),tx ,alpha,beta,n,'txmm',ifverbose)
        call avg1(ruxm(1,1,1,1,11),ty ,alpha,beta,n,'tymm',ifverbose)
        call avg1(ruxm(1,1,1,1,12),tz ,alpha,beta,n,'tzmm',ifverbose)
c       Compute time-average of squared gradients
        call avg2(rux2(1,1,1,1,1),vxx,alpha,beta,n,'ux2m',ifverbose)
        call avg2(rux2(1,1,1,1,2),vxy,alpha,beta,n,'uy2m',ifverbose)
        call avg2(rux2(1,1,1,1,3),vxz,alpha,beta,n,'uz2m',ifverbose)

        call avg2(rux2(1,1,1,1,4),vyx,alpha,beta,n,'vx2m',ifverbose)
        call avg2(rux2(1,1,1,1,5),vyy,alpha,beta,n,'vy2m',ifverbose)
        call avg2(rux2(1,1,1,1,6),vyz,alpha,beta,n,'vz2m',ifverbose)

        call avg2(rux2(1,1,1,1,7),vzx,alpha,beta,n,'wx2m',ifverbose)
        call avg2(rux2(1,1,1,1,8),vzy,alpha,beta,n,'wy2m',ifverbose)
        call avg2(rux2(1,1,1,1,9),vzz,alpha,beta,n,'wz2m',ifverbose)

        call avg2(rux2(1,1,1,1,10),tx ,alpha,beta,n,'tx2m',ifverbose)
        call avg2(rux2(1,1,1,1,11),ty ,alpha,beta,n,'ty2m',ifverbose)
        call avg2(rux2(1,1,1,1,12),tz ,alpha,beta,n,'tz2m',ifverbose)
c        Compute time average of u^3, v^3, w^3, t^3
        call avg2(wo1,vx ,0.0,1.0,n,'dumm',ifverbose)
        call avg3(ru3m(1,1,1,1,1),wo1,vx, alpha,beta,n,
     &                                            'u3mm',ifverbose)
        call avg2(wo1,vy ,0.0,1.0,n,'dumm',ifverbose)
        call avg3(ru3m(1,1,1,1,2),wo1,vy, alpha,beta,n,
     &                                            'v3mm',ifverbose)
        call avg2(wo1,vz ,0.0,1.0,n,'dumm',ifverbose)
        call avg3(ru3m(1,1,1,1,3),wo1,vz, alpha,beta,n,
     &                                            'w3mm',ifverbose)
        call avg2(wo1,t(1,1,1,1,1) ,0.0,1.0,n,'dumm',ifverbose)
        call avg3(ru3m(1,1,1,1,4),wo1,t, alpha,beta,n,
     &                                            't3mm',ifverbose)
c        Compute uv^2,uw^2, etc
        call avg2(wo1,vx ,0.0,1.0,n,'dumm',ifverbose)
        call avg3(rv2u(1,1,1,1,1),wo1,vy, alpha,beta,n,
     &                                            'vu2m',ifverbose)
        call avg3(rv2u(1,1,1,1,2),wo1,vz, alpha,beta,n,
     &                                            'wu2m',ifverbose)
        call avg2(wo1,vy ,0.0,1.0,n,'dumm',ifverbose)
        call avg3(rv2u(1,1,1,1,3),wo1,vx, alpha,beta,n,
     &                                            'uv2m',ifverbose)
        call avg3(rv2u(1,1,1,1,4),wo1,vz, alpha,beta,n,
     &                                            'wv2m',ifverbose)
        call avg2(wo1,vz ,0.0,1.0,n,'dumm',ifverbose)
        call avg3(rv2u(1,1,1,1,5),wo1,vx, alpha,beta,n,
     &                                            'uw2m',ifverbose)
        call avg3(rv2u(1,1,1,1,6),wo1,vy, alpha,beta,n,
     &                                            'vw2m',ifverbose)
c        Compute p, up, vp, wp
        call avg1(rpmm(1,1,1,1,1),pr,alpha,beta,n,'pavg',ifverbose)
        call avg3(rpmm(1,1,1,1,2),pr,vx, alpha,beta,n,'upmm',ifverbose)
        call avg3(rpmm(1,1,1,1,3),pr,vy, alpha,beta,n,'vpmm',ifverbose)
        call avg3(rpmm(1,1,1,1,4),pr,vz, alpha,beta,n,'wpmm',ifverbose)
      endif ! (atime.ne.0 .and. dtime.ne.0 .and. istep.ne.0 )
      timel = time  - mean_time_start

c     ############################################################
C       if (istep.ne.0 .and. 
C      &    mod(istep,int(iostep_2d_avg_time)).eq.0) then
      if (istep.ne.0 .and. if_write_means.eq.1) then
c     spanwise averaging
        do i =1,12
          call planar_avg(suxm(1,1,1,1,i),ruxm(1,1,1,1,i),igs_x) !x averaging
          call x_slice2(suxm(1,1,1,1,i),w1)     !x_slice2 and 3 take an slice on the yz plane. They are both needed to avoid unnnecessary memory declarations on all procceses
          if (nid.eq.0) call x_slice3(suxm_2d(1,1,1,1,i))
          call planar_avg(sux2(1,1,1,1,i),rux2(1,1,1,1,i),igs_x) !x averaging
          call x_slice2(sux2(1,1,1,1,i),w1)
          if (nid.eq.0) call x_slice3(sux2_2d(1,1,1,1,i))
        enddo
        do i =1,6
          call planar_avg(suvm(1,1,1,1,i),ruvm(1,1,1,1,i),igs_x) !x averaging
          call x_slice2(suvm(1,1,1,1,i),w1)
          if (nid.eq.0)  call x_slice3(suvm_2d(1,1,1,1,i))
          call planar_avg(sv2u(1,1,1,1,i),rv2u(1,1,1,1,i),igs_x) !x averaging
          call x_slice2(sv2u(1,1,1,1,i),w1)
          if (nid.eq.0)   call x_slice3(sv2u_2d(1,1,1,1,i))
        enddo
        do i =1,4
          call planar_avg(summ(1,1,1,1,i),rumm(1,1,1,1,i),igs_x) !x averaging
          call x_slice2(summ(1,1,1,1,i),w1)
          if (nid.eq.0)call x_slice3(summ_2d(1,1,1,1,i))
          call planar_avg(su2m(1,1,1,1,i),ru2m(1,1,1,1,i),igs_x) !x averaging
          call x_slice2(su2m(1,1,1,1,i),w1)
          if (nid.eq.0)call x_slice3(su2m_2d(1,1,1,1,i))
          call planar_avg(su3m(1,1,1,1,i),ru3m(1,1,1,1,i),igs_x) !x averaging
          call x_slice2(su3m(1,1,1,1,i),w1)
          if (nid.eq.0)call x_slice3(su3m_2d(1,1,1,1,i))
          call planar_avg(spmm(1,1,1,1,i),rpmm(1,1,1,1,i),igs_x) !x averaging
          call x_slice2(spmm(1,1,1,1,i),w1)
          if (nid.eq.0)call x_slice3(spmm_2d(1,1,1,1,i))
        enddo
        call nekgsync()
          if (param(15).ne.0) then !write control -> numsteps
            call output_means(atime,timel,dtime,w4,istep)
          else
            call output_means(atime,timel,dtime,w4,counter_mean)
          endif
      endif !(istep.gt.0 .and. mod(istep,int(iostep_2d_avg_time)).eq.0)

c    
      return
      end

c-----------------------------------------------------------------------
      subroutine userbc (ix,iy,iz,iside,ieg)

      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      include 'NEKNEK'

c     ############################################################
c     INFLOW FROM INTERPOLATED EXTERNAL FILE
      parameter(nel_slab = nelxin*nelyin)

      common /pml/ ewcalc, if_pml, z_front, zp_front, smul
      common /dongVel/ maxvel
      common /utop_read/ v_top1, v_top2

      real ewfac
      integer e,mixy, itmul
      real theta1,chr,shr,zh1,z_real, x_tan, xlen,dumm,tdumm,tmul,tmut
      real dumr, offset
      real hlim
      integer ex,ey,ez


c     VS*GRAD(TEMP) BC VARIABLES
      real sn(3)
      common /VS_VEC/ vs(3,ldimt)

      common /erosion/ E_s(lx1,lz1,lelx,lelz,ldimt)

      common /eta_mvbc/ umeshx(lx1,ly1,lz1,lelv)
     &              , umeshy(lx1,ly1,lz1,lelv)
     &              , umeshz(lx1,ly1,lz1,lelv)
     &              , rhs(lx1,lz1,lelx,lelz)

      common /inflow_pl/ vxin_pl(lx1,ly1,nel_slab)
     $                  ,vyin_pl(lx1,ly1,nel_slab)
     $                  ,vzin_pl(lx1,ly1,nel_slab)
     $                  ,tin_pl(lx1,ly1,nel_slab)

c     ############################################################
      real Re_pp(ldimt),V_sp(ldimt),sp_fraction(ldimt),
     & alpha_fraction(ldimt)
      Re_pp = def_RE_P
      V_sp = def_Vs
      sp_fraction = def_gamma
      alpha_fraction = def_alpha
c     ############################################################


      e = gllel(ieg)

      call get_exyz(ex,ey,ez,ieg,lelx,lely,lelz)

      ux   = 0.
      uy   = 0.
      uz   = 0.
      temp = 0.
      do ips=1,npscal
         ps(ips) = 0.
      enddo
      if (if_pml.eq.0) then
        ewfac = -1.0*UTARGET              
      endif

      tmul=1.0
      tmut = 1.0
      hlim = hf
      offset = 0.0

      if (time.gt.time_inflow) then
        tmul= 1.0-(time-time_inflow)
        tmut = tmul
        hlim = hlim - hf*(time-time_inflow)
      endif 
      if (time.gt.time_inflow+1.0) then
        tmul= 0.0
        tmut = 0.0
        hlim = 0.0
      endif 


c     ############################################################
c     STABILIZED OUTFLOW Dong et all JCP
      if (if_pml.eq. 2 .and. cbu.eq.'o  ' .and. iside .eq. 3) then !top BC
         U0 = -0.2                 ! characteristic velocity
         delta = 0.1               ! small positive constant
         pa = dongOutflow(ix,iy,iz,e,iside,U0,delta)
      endif

      if (ODong_flag .and. cbu.eq.'o  ' .and. iside .eq. 6) then !outlet BC
         U0 = 10.0                 ! characteristic velocity
         delta = 0.1               ! small positive constant
         pa = dongOutflow(ix,iy,iz,e,iside,U0,delta)
      endif


c     ############################################################
c     INFLOW FROM SEM
      if (ifield .eq. 1) then               ! velocity
          if(ieg.le.nel_slab.and.iside.eq.5 .and. y.le.hlim) then
            ux  = tmul*vxin_pl(ix,iy,ieg)
            uy  = tmul*vyin_pl(ix,iy,ieg)
            uz  = tmul*vzin_pl(ix,iy,ieg)
          endif
        else    !temperature
          if (ieg.le.nel_slab.and.iside.eq.5 .and. y.le.hlim) then  
            do ips=1, ldimt
              if(ifield.eq.ips+1) then
                  temp  = tmut*tin_pl(ix,iy,ieg)*
     &                     sp_fraction(ips)
              endif
            enddo
          endif
      endif

c     ############################################################
c     TOP TEMP BC 

      if (if_pml.eq.0) then    ! pml on
        
        zstart = 0                    !<----------------------CHANGE
        zstart1 = zstart + 1.         !<----------------------CHANGE
        zendbr = zh1 + 0
        zendbr1 =zendbr +10
        zend = ZLEN
        zend1 = zend - 1.             !<----------------------CHANGE

        z_real =(AINT(z*100.0)/100.0)

        if (ifield .eq. 1 .and. iside.eq.3) then     ! velocity
              ux = 0.0
              uz = 0.0
c           This coflow is only for the top wall of the domain
              if (z_real.ge.zstart.and.z_real.le.zstart1) then
                uy= ((z-zstart-1.)**8 - 1.)*ewfac
              else
                uy= (-1)*ewfac
              endif
         endif 
      endif

c     ############################################################
c     ############################################################
c     BOTTOM TEMP BC 
      if ( BC_FLAG_TEMP.eq.1) then
        call getSnormal(sn,ix,iy,iz,iside,e)
c     Compute hc for Newton cooling BC, bypass mode BC
c     (1/Pe)*grad(T) dot n = (Vs*T) dot n
        do ips=1, ldimt
          if(ifield.eq.(ips+1).and.iside.eq.1) then
         hc = (-1.0)*(vs(1,ips)*sn(1) + vs(2,ips)*sn(2) + 
     &             vs(3,ips)*sn(3))
          endif
        enddo
      endif 
      if (BC_FLAG_TEMP.eq.2) then
        call getSnormal(sn,ix,iy,iz,iside,e)
c     Compute flux for flux BC, Erosion mode BC
c     (1/Pe)*grad(T) dot n = -|Vs*E_s| dot n
        flux=0.0
      if (.true.) then!(z .lt. ZLEN-2*(ZLEN-ZBUFF) ) then  !things get messy near the increased viscosity outlet
        do ips=1, ldimt
          if(ifield.eq.(ips+1).and.iside.eq.1) then
C             flux = (-1.0)*V_sp(ips)*abs(E_s(ix,iz,ex,ez,ips)*sn(1) +
C      &        E_s(ix,iz,ex,ez,ips)*sn(2) +
C      &        E_s(ix,iz,ex,ez,ips)*sn(3))/Cv
              flux = -1.0*V_sp(ips)*abs(E_s(ix,iz,ex,ez,ips))*sn(2)/Cv
          endif
        enddo
        endif
      endif
c     #########################################################
c     MOVING MESH
c     Bottom velocity BC
      if (cbc(iside,e,1).eq.'mv ') then
          ux = umeshx(ix,iy,iz,e)
          uy = umeshy(ix,iy,iz,e)
          uz = umeshz(ix,iy,iz,e)
      endif

      return
      end
c-----------------------------------------------------------------------
      subroutine useric (ix,iy,iz,ieg)
      include 'SIZE'
      include 'TOTAL'
      include 'NEKUSE'
      ux = 0.0
      uy = 0.0
      uz = 0.0
      temp = 0.0
C       IF (IFIELD.eq.3)               ! ---------- Scalar 1
C      &    temp = 1.11 
C       do ips=1,npscal
C          ps(ips) = 2.22
C       enddo



      return
      end
c-----------------------------------------------------------------------
      subroutine usrdat
      include 'SIZE'
      include 'TOTAL'
      
      integer n,nelytot,mmnely
      real hfh,hfint,amp,delyi,rrleny,rrlenyint,y,z, sp
      real theta1, theta2, A1, A2, zh1, zh2, anint
      real hf1, hf2
      real deltz1, deltz0
      integer nz_break

      common /pml/ ewcalc, if_pml, z_front, zp_front, smul

      if (UTARGET .eq. 0.0)then
        if_pml=2
      elseif (UTARGET .gt. 0.0) then
        if_pml=1
      elseif (UTARGET .lt. 0.0) then
        if_pml=0
      endif

      theta1 = atan(1/RITAU)
      A1 = B_OUTLET / RITAU

      n=8*nelt
c
      nelytot = NUMBER_ELEMENTS_Y

      delyi =hf/nelyin
      rrleny = nelytot*delyi 
      rrlenyint = nelyint*delyi
      hfh=hf/2.0
      hfint = rrlenyint
      amp=ASINH(((hint-hf)/hint)*SINH(-3.25))/((hf/rrlenyint-1.0)*3.25)
      sp=1.5


c     vertical grid spacing      
      do i=1,n
        yc(i,1)  = rrleny * yc(i,1) 
        y=yc(i,1)

        if ((AINT(y*100.0)/100.0).le.hfh) then
          yc(i,1) = (-1)*(1-SINH(sp*y)/SINH(sp))+1
        elseif ((AINT(y*100.0)/100.0).le.hf) then
          yc(i,1) = (1)*(1 - SINH(sp*(2-y))/SINH(sp))+1
        elseif ((AINT(y*100.0)/100.0).le.hfint) then
          y = y / rrlenyint
          yc(i,1)= (hint*SINH(3.25*amp*(hf/rrlenyint-y))/SINH(-3.25))+2
        elseif ((AINT(y*100.0)/100.0).gt.hfint) then
              yc(i,1)=(y-hfint)*(YLEN-hint)/(rrleny-hfint)+hint
C             y=(y-hfint)/(rrleny-hfint)
C             yc(i,1)=y*(YLEN-hfint)+hfint
        endif
        xc(i,1) =  XLEN * xc(i,1)
        zc(i,1) = ZLEN * zc(i,1)
      enddo

      if (B_OUTLET .gt. 0.0) then
      if(nid.eq.0) write(*,*) 'Deforming mesh for bottom outlet.....'
      do i=1,n
        y=yc(i,1)
        z=zc(i,1)
          if ((AINT(z*100.0)/100.0) .gt. (ZLEN-B_OUTLET) ) then
            A2 = (z - (ZLEN-B_OUTLET)) / B_OUTLET
            A2 = A2 * (1.0- y / YLEN)
            yc(i,1) = y + A1 * A2
          endif
      enddo
      endif


      return
      end
      subroutine usrdat2
      include 'SIZE'
      include 'TOTAL'
      parameter (llt=lx1*ly1*lz1*lelt)
      common /cmygeom/ xmo(llt),ymo(llt),zmo(llt)


      param(59) = 1 

      if (UTARGET.lt.0.)then  !change top BC from O to v
          ifc=3 !top face, if it was generated by genbox
          do iel=1,nelt
             if (cbc(ifc,iel,1) .eq. 'O  ') cbc(ifc,iel,1) = 'v  '
          enddo
      endif

      if (UTARGET.eq.0.)then  !change top  BC from O to o  DONG
          ifc=3 !top face, if it was generated by genbox
          do iel=1,nelt
             if (cbc(ifc,iel,1) .eq. 'O  ') cbc(ifc,iel,1) = 'o  '
          enddo
      endif


      if (BC_FLAG_TEMP.eq.1) then !change bottom temp BC from I to c
          ifc=1 !bottom face, if it was generated by genbox
          do iel=1,nelt
            do ips=2,ldimt+1
             if (cbc(ifc,iel,ips) .eq. 'I  ') cbc(ifc,iel,ips) = 'c  '
            enddo
          enddo
      endif
      if (BC_FLAG_TEMP.eq.2) then !change bottom temp BC from I to f
          ifc=1 !bottom face, if it was generated by genbox
          do iel=1,nelt
            do ips=2,ldimt+1
             if (cbc(ifc,iel,ips) .eq. 'I  ') cbc(ifc,iel,ips) = 'f  '
            enddo
          enddo
      endif


      if (IF_MVMESH) then  !change bottom BC from W to mv
          ifc=1 !bottom face, if it was generated by genbox
          do iel=1,nelt
             if (cbc(ifc,iel,1) .eq. 'W  ') cbc(ifc,iel,1) = 'mv '
          enddo
          ifxyo     = .true.
          ifmvbd    = .true.  ! moving boundary
          ifusermv  = .true.  ! define our own mesh velocity
      endif

      if (ODong_flag)then  !change outlet BC from O to o  DONG
          ifc=6 !right face, if it was generated by genbox
          do iel=1,nelt
             if (cbc(ifc,iel,1) .eq. 'O  ') cbc(ifc,iel,1) = 'o  '
          enddo
      endif


      if (B_OUTLET .gt. 0.0)then  !change outlet BC from O to w
          ifc=6 !right face, if it was generated by genbox
          do iel=1,nelt
             if (cbc(ifc,iel,1) .eq. 'O  ') cbc(ifc,iel,1) = 'SYM'
             if (cbc(ifc,iel,2) .eq. 'O  ') cbc(ifc,iel,2) = 'I  '
          enddo
      endif

      if (B_OUTLET .gt. 0.0)then  !change outlet BC from O to w
          ifc=1 !bottom face, if it was generated by genbox
          do iel=1,nelt
            if (zm1(1,1,1,iel).gt.(ZLEN-B_OUTLET))then   
                 if (cbc(ifc,iel,1) .eq. 'W  ') then
                    cbc(ifc,iel,1) = 'O  '  
                    cbc(ifc,iel,2) = 'O  '
                 endif
            endif
          enddo
      endif


      call opcopy(xmo,ymo,zmo,xm1,ym1,zm1)  ! Preserve my geometry
c
      return
      end
      
c-----------------------------------------------------------------------
      subroutine usrdat3
      include 'SIZE'
      include 'TOTAL'
c
      parameter (llt=lx1*ly1*lz1*lelt)
      common /cmygeom/ xmo(llt),ymo(llt),zmo(llt)

      call opcopy(xm1,ym1,zm1,xmo,ymo,zmo)  ! Restore my geometry
      call geom_reset(1)                    ! Force regen. of Jacobians 
      call prinit

      return
      end



c-----------------------------------------------------------------------

      subroutine x_slice (ua,u,w1,w2)
c
c     Extract a x slice of quantity u() - assumes global tens.prod.
c
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
c
      real ua(ny1,nz1,nely,nelz),u(nx1,ny1,nz1,nelt),
     $     w1(ny1,nz1,nely,nelz),w2(ny1,nz1,nely,nelz)
      integer e,eg,ex,ey,ez
      real dy2
c
      myz = nely*nelz*ny1*nz1
      call rzero(ua,myz)
c
      do e=1,nelt
c
         eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)

         i = 1
         if (ex.eq.1) then
            do k=1,nz1
            do j=1,ny1
               ua(j,k,ey,ez) = u(i,j,k,e)
            enddo
            enddo
         endif
      enddo

      call gop(ua,w2,'+  ',myz)

      return
      end

      subroutine x_slice2 (u,w1)
c
c     Extract a x slice of quantity u() - assumes global tens.prod.
c     It doesn't return the result. 
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
c
      real u(nx1,ny1,nz1,nelt),
     $     w1(ny1,nz1,nely,nelz)
      integer nst,ist
      integer e,eg,ex,ey,ez
      real dy2
C       real ua(ny1,nz1,nely,nelz)
      common /xslice2/
     &   ua(ly1,lz1,lely,lelz)
c
      myz = nely*nelz*ny1*nz1
      call rzero(ua,myz)
c
      do e=1,nelt
c
         eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)

         i = 1
         if (ex.eq.1) then
            do k=1,nz1
            do j=1,ny1
               ua(j,k,ey,ez) = u(i,j,k,e)
            enddo
            enddo
         endif
      enddo

      call gop(ua,w1,'+  ',myz)

      return
      end

      subroutine x_slice3 (ua2)
c
c     Extract a x slice of quantity u() - assumes global tens.prod.
c     It must be called RIGHT AFTER x_slice2
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
c
      real ua2(ny1,nz1,nely,nelz)
      integer e,eg,ex,ey,ez
      real dy2
      common /xslice2/
     &   ua(ly1,lz1,lely,lelz)

c
      myz = nely*nelz*ny1*nz1
      call rzero(ua2,myz)

      call copy(ua2,ua,myz)
      return
      end
c---------------------------------------------------------------------      
      subroutine y_line (ua,u,w1,w2)
c
c     Extract a y line of quantity u() - assumes global tens.prod.
c
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
c
      real ua(ny1,nely),u(nx1,ny1,nz1,nelv)
     $    ,w1(ny1,nely),w2(ny1,nely)
      integer e,eg,ex,ey,ez
      real dy2
c
      my = nely*ny1
      call rzero(ua,my)
c
      do e=1,nelt
c
         eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
         i = 1
         k = 1
         if (ex.eq.1 .and. ez.eq.1) then
            do j=1,ny1
               ua(j,ey) = u(i,j,k,e)
            enddo
         endif
      enddo
      call gop(ua,w2,'+  ',my)

      return
      end
c--------------------------------------------------------------------- 
      subroutine yslab (ua,u,w1,nslab,nely_in)
c
c     Extract a y line of quantity u() - assumes global tens.prod.
c
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
c
      real ua(nslab),u(nx1,ny1,nz1,nelv)
     $    ,w1(nslab)
      integer e,eg,ex,ey,ez
      real dy2
c
C       my = nely*ny1
      call rzero(ua,nslab)
c
      do e=1,nelt
c
         eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
         i = 1
         k = 1
         if (ex.eq.1 .and. ez.eq.1.and. ey.le.nely_in) then
            do j=1,ny1
               ua(j+ey*ny1-ny1) = u(i,j,k,e)-u(1,1,1,1)
            enddo
         endif
      enddo
      call gop(ua,w1,'+  ',nslab)

      return
      end     
    
      subroutine y_slice (ua,u,w1)
c
c     Extract the bottom y slice of quantity u() - assumes global tens.prod.
c
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
c
      real ua(nx1,nz1,nelx,nelz),u(nx1,ny1,nz1,nelt),
     $     w1(nx1,nz1,nelx,nelz)
      integer e,eg,ex,ey,ez, mxz
      real dy2
c
      mxz = nelx*nelz*nx1*nz1
      call rzero(ua,mxz)
      call rzero(w1,mxz)
c
      do e=1,nelt
c
         eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)

         j = 1
         if (ey.eq.1) then
            do k=1,nz1
            do i=1,nx1
               ua(i,k,ex,ez) = u(i,j,k,e)
            enddo
            enddo
         endif
      enddo

      call gop(ua,w1,'+  ',mxz)

      return
      end


c-----------------------------------------------------------------------

       subroutine output_means(atime,timel,dtime,w4,name)

       include 'SIZE'
       include 'TOTAL'
       include 'ZPER'

       real atime,timel,dtime
       character*80 icfile,istepc
       real w4(ly1,lz1,lely,lelz)
       integer name

      common /avgstats/
     &  rumm(lx1,ly1,lz1,lelt,4)
     & , ru2m(lx1,ly1,lz1,lelt,4)
     & , ruvm(lx1,ly1,lz1,lelt,6)
     & , ruxm(lx1,ly1,lz1,lelt,12)
     & , rux2(lx1,ly1,lz1,lelt,12)
     & , ru3m(lx1,ly1,lz1,lelt,4)
     & , rv2u(lx1,ly1,lz1,lelt,6)
     & , rpmm(lx1,ly1,lz1,lelt,4)
     & , summ(lx1,ly1,lz1,lelt,4)
     & , su2m(lx1,ly1,lz1,lelt,4)
     & , suvm(lx1,ly1,lz1,lelt,6)
     & , suxm(lx1,ly1,lz1,lelt,12)
     & , sux2(lx1,ly1,lz1,lelt,12)
     & , su3m(lx1,ly1,lz1,lelt,4)
     & , sv2u(lx1,ly1,lz1,lelt,6)
     & , spmm(lx1,ly1,lz1,lelt,4)
     & , summ_2d(ly1,lz1,lely,lelz,3)
     & , summT_2d(ly1,lz1,lely,lelz,ldimt)
     & , su2m_2d(ly1,lz1,lely,lelz,3)
     & , su2m_2dT(ly1,lz1,lely,lelz,ldimt)
     & , suvm_2d(ly1,lz1,lely,lelz,6)
     & , suxm_2d(ly1,lz1,lely,lelz,12)
     & , sux2_2d(ly1,lz1,lely,lelz,12)
     & , su3m_2d(ly1,lz1,lely,lelz,4)
     & , sv2u_2d(ly1,lz1,lely,lelz,6)
     & , spmm_2d(ly1,lz1,lely,lelz,4)


       m=ny1*nz1*lely*lelz
       if(nid.eq.0) then
          write(*,*)'*********Writing statistics.......*********'
          write(istepc,'(i32)') name
          istepc=adjustl(istepc)
          icfile=trim(path)//trim('means.'//trim(istepc))
          open(unit=58,file=icfile,access='stream',form='unformatted')
          write(58) (time-mean_time_start),atime,timel,dtime
          write(58) int(nx1),int(lelx),int(lely),int(lelz)
          do i=1,4
            call copy(w4,summ_2d(1,1,1,1,i),m)
            write(58) w4
          enddo
          do i=1,4
            call copy(w4,su2m_2d(1,1,1,1,i),m)
            write(58) w4
         enddo
          do i=1,6
            call copy(w4,suvm_2d(1,1,1,1,i),m)
            write(58) w4
          enddo
          do i=1,12
            call copy(w4,suxm_2d(1,1,1,1,i),m)
            write(58) w4
          enddo
          do i=1,12
            call copy(w4,sux2_2d(1,1,1,1,i),m)
            write(58) w4
          enddo
          do i=1,4
            call copy(w4,su3m_2d(1,1,1,1,i),m)
            write(58) w4
         enddo
         do i=1,6
            call copy(w4,sv2u_2d(1,1,1,1,i),m)
            write(58) w4
         enddo
         do i=1,4
            call copy(w4,spmm_2d(1,1,1,1,i),m)
            write(58) w4
         enddo
          close(58)
       endif
       return
       end


      subroutine input_means(w4)
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real w4(ly1,lz1,lely,lelz)
      integer dumm
      real dumr

      common /avgstats_old/
     &  summ_2d_o(ly1,lz1,lely,lelz,4)
     & , su2m_2d_o(ly1,lz1,lely,lelz,4)
     & , suvm_2d_o(ly1,lz1,lely,lelz,6)
     & , suxm_2d_o(ly1,lz1,lely,lelz,12)
     & , sux2_2d_o(ly1,lz1,lely,lelz,12)
     & , su3m_2d_o(lx1,ly1,lely,lelz,4)
     & , sv2u_2d_o(lx1,ly1,lely,lelz,6)
     & , spmm_2d_o(lx1,ly1,lely,lelz,4)
     & ,timem,atimem,timelm,dtimem,t_tot

      m=ly1*lz1*lely*lelz

      call rzero(summ_2d_o,size(summ_2d_o))
      call rzero(su2m_2d_o,size(su2m_2d_o))
      call rzero(suvm_2d_o,size(suvm_2d_o))
      call rzero(suxm_2d_o,size(suxm_2d_o))
      call rzero(sux2_2d_o,size(sux2_2d_o))
      call rzero(su3m_2d_o,size(su3m_2d_o))
      call rzero(sv2u_2d_o,size(sv2u_2d_o))
      call rzero(spmm_2d_o,size(spmm_2d_o))

      if (nid.eq.0) then
         write(*,*)'*********Reading means file: means.ini....*********'
         open(unit=58,file=trim(path)//'means.ini',access='stream',
     &     form='unformatted')
         read(58) timem,atimem,timelm,dtimem
         read(58) dumm,dumm,dumm,dumm
         do i=1,4
          read(58) w4
          call copy(summ_2d_o(1,1,1,1,i),w4,m)
         enddo
         do i=1,4
          read(58) w4
          call copy(su2m_2d_o(1,1,1,1,i),w4,m)
         enddo
         do i=1,6
          read(58) w4
          call copy(suvm_2d_o(1,1,1,1,i),w4,m)
         enddo
         do i=1,12
          read(58) w4
          call copy(suxm_2d_o(1,1,1,1,i),w4,m)
         enddo
         do i=1,12
          read(58) w4
          call copy(sux2_2d_o(1,1,1,1,i),w4,m)
         enddo
         do i=1,4
            read(58) w4
            call copy(su3m_2d_o(1,1,1,1,i),w4,m)
         enddo
         do i=1,6
            read(58) w4
            call copy(sv2u_2d_o(1,1,1,1,i),w4,m)
         enddo
         do i=1,4
            read(58) w4
            call copy(spmm_2d_o(1,1,1,1,i),w4,m)
         enddo
         close(58)
         write(*,*)'Done reading from disk'
       endif
      do i=1,4
          call gop(summ_2d_o(1,1,1,1,i),w4,'+  ',m)
      enddo
      do i=1,4
          call gop(su2m_2d_o(1,1,1,1,i),w4,'+  ',m)
      enddo
      do i=1,6
          call gop(suvm_2d_o(1,1,1,1,i),w4,'+  ',m)
      enddo
      do i=1,12
          call gop(suxm_2d_o(1,1,1,1,i),w4,'+  ',m)
      enddo
      do i=1,12
          call gop(sux2_2d_o(1,1,1,1,i),w4,'+  ',m)
      enddo
      do i=1,4
          call gop(su3m_2d_o(1,1,1,1,i),w4,'+  ',m)
      enddo
      do i=1,6
          call gop(sv2u_2d_o(1,1,1,1,i),w4,'+  ',m)
      enddo
      do i=1,4
          call gop(spmm_2d_o(1,1,1,1,i),w4,'+  ',m)
      enddo
      call gop(atimem,dumr,'+  ',1)
      return
      end

      subroutine print_yz_mesh

      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'


      real ymm(ly1,lz1,lely,lelz),zmm(ly1,lz1,lely,lelz)

c     xmm --> yz slice; ymm --> xz slice; zmm --> xy slice  

      real w1(ly1,lz1,lely,lelz),w2(ly1,lz1,lely,lelz)


      call x_slice(ymm,ym1,w1,w2)
      call x_slice(zmm,zm1,w1,w2)

      if(nid.eq.0) then
          write(*,*)'*********Writing y-z plane mesh.......*********'
          write(istepc,'(i32)') istep
          open(unit=58,file='yzmesh.dat',
     &       access='stream',form='unformatted')
          write(58)ly1,lz1,lely,lelz
          write(58)ymm,zmm
          close(58)
      endif
      return
      end
c-----------------------------------------------------------------------

      subroutine print_xz_mesh

      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'


      real zmm(lx1,lz1,lelx,lelz),xmm(lx1,lz1,lelx,lelz)

c     xmm --> yz slice; ymm --> xz slice; zmm --> xy slice  

      real w1(lx1,lz1,lelx,lelz)


      call y_slice(zmm,zm1,w1)
      call y_slice(xmm,xm1,w1)

      if(nid.eq.0) then
          write(*,*)'*********Writing x-z plane mesh.......*********'
          write(istepc,'(i32)') istep
          open(unit=58,file='xzmesh.dat',
     &       access='stream',form='unformatted')
          write(58)lx1,lz1,lelx,lelz
          write(58)xmm,zmm
          close(58)
      endif
      return
      end

c-----------------------------------------------------------------------

      subroutine output_2d(timel,w4,name)

       include 'SIZE'
       include 'TOTAL'
       include 'ZPER'

       real timel
       real w4(ly1,lz1,lely,lelz)
       integer name
       character*80 icfile,istepc
      common /avgstats/
     &  rumm(lx1,ly1,lz1,lelt,4)
     & , ru2m(lx1,ly1,lz1,lelt,4)
     & , ruvm(lx1,ly1,lz1,lelt,6)
     & , ruxm(lx1,ly1,lz1,lelt,12)
     & , rux2(lx1,ly1,lz1,lelt,12)
     & , ru3m(lx1,ly1,lz1,lelt,4)
     & , rv2u(lx1,ly1,lz1,lelt,6)
     & , rpmm(lx1,ly1,lz1,lelt,4)
     & , summ(lx1,ly1,lz1,lelt,4)
     & , su2m(lx1,ly1,lz1,lelt,4)
     & , suvm(lx1,ly1,lz1,lelt,6)
     & , suxm(lx1,ly1,lz1,lelt,12)
     & , sux2(lx1,ly1,lz1,lelt,12)
     & , su3m(lx1,ly1,lz1,lelt,4)
     & , sv2u(lx1,ly1,lz1,lelt,6)
     & , spmm(lx1,ly1,lz1,lelt,4)
     & , summ_2d(ly1,lz1,lely,lelz,3)
     & , summT_2d(ly1,lz1,lely,lelz,ldimt)
     & , su2m_2d(ly1,lz1,lely,lelz,3)
     & , su2mT_2d(ly1,lz1,lely,lelz,ldimt)
     & , suvm_2d(ly1,lz1,lely,lelz,6)
     & , suxm_2d(ly1,lz1,lely,lelz,12)
     & , sux2_2d(ly1,lz1,lely,lelz,12)
     & , su3m_2d(ly1,lz1,lely,lelz,4)
     & , sv2u_2d(ly1,lz1,lely,lelz,6)
     & , spmm_2d(ly1,lz1,lely,lelz,4)


       m=ny1*nz1*lely*lelz
       if(nid.eq.0) then
          write(*,*)'******Writing spanwise-averaged file....*******'
          write(istepc,'(i32)') (name-1)
          istepc=adjustl(istepc)
          icfile=trim(path)//trim('2dmeans.'//trim(istepc))
          open(unit=58,file=icfile,access='stream',form='unformatted')
          write(58) time
          write(58) int(nx1),int(lelx),int(lely),int(lelz),int(ldimt)
          do i=1,3
            call copy(w4,summ_2d(1,1,1,1,i),m)
            write(58) w4
          enddo
          do i=1,ldimt
            call copy(w4,summT_2d(1,1,1,1,i),m)
            write(58) w4
          enddo
          do i=1,3
            call copy(w4,su2m_2d(1,1,1,1,i),m)
            write(58) w4
          enddo
          do i=1,ldimt
            call copy(w4,su2mT_2d(1,1,1,1,i),m)
            write(58) w4
          enddo
          do i=1,6
            call copy(w4,suvm_2d(1,1,1,1,i),m)
            write(58) w4
          enddo
          close(58)
       endif
       return
       end

      function dongOutflow(ix,iy,iz,iel,iside,u0,delta)

      include 'SIZE'
      include 'SOLN'
      include 'GEOM'

      real sn(3)

      ux = vx(ix,iy,iz,iel)
      uy = vy(ix,iy,iz,iel)
      uz = vz(ix,iy,iz,iel)

      call getSnormal(sn,ix,iy,iz,iside,iel)
      vn = ux*sn(1) + uy*sn(2) + uz*sn(3) 
      S0 = 0.5*(1.0 - tanh(vn/u0/delta))

      dongOutflow = -0.5*(ux*ux+uy*uy+uz*uz)*S0

      return
      end
C-----------------------------------------------------------------------
      subroutine vz_outflow(vzout,w)

      include 'SIZE'
      include 'SOLN'
      include 'GEOM'
      include 'ZPER'
      include 'PARALLEL'
      include 'WZ'

      real vzout(lx1,ly1,lelx,lely),w(lx1,ly1,lelx,lely)
      integer e,eg,ex,ey,ez, m

      m=lx1*ly1*lelx*lely
      call rzero(vzout,m)
      call rzero(w,m)
      do e=1,nelv
        eg = lglel(e)
        call get_exyz(ex,ey,ez,eg,lelx,lely,lelz)
        if (ez.eq.lelz) then
          do j=1,ny1
            do i=1,nx1  
              w(i,j,ex,ey)= vz(i,j,lz1,e)
            enddo
          enddo
        endif
      enddo
      call gop(w,vzout,'+  ',m)

      return 
      end

      subroutine shields(sh_x,sh_z,sh_cr,btuy,btwy,th_x,th_z,repd,cvd)
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real btuy(lx1,lz1,lelx,lelz),btwy(lx1,lz1,lelx,lelz)
      real sh_x(lx1,lz1,lelx,lelz),sh_z(lx1,lz1,lelx,lelz),
     &     sh_cr(lx1,lz1,lelx,lelz) 
      real th_x(lx1,lz1,lelx,lelz),th_z(lx1,lz1,lelx,lelz)
      real repd,cvd
      real dum,sh_cr0,gamma,beta,tan_cr, diamd
      integer n,i
      n=lx1*lz1*lelx*lelz
      call rzero(sh_x,n)
      call rzero(sh_z,n)
      call rzero(sh_cr,n)

      write(*,*) 'FIX SHIELDS FUNCTION'

      if (V_SETTLING.ne.0.0) then
        diamd=DIAM
      else
        dum=sin(atan(1.0/RITAU))*cvd
        diamd=(dum/((RE_TAU/repd)**2))**(1.0/3.0)
        if (nid.eq.0 .and. istep.eq.0) write(*,*)'Rep=',repd,'d=',diamd
      endif

      do i=1,n
        sh_x(i,1,1,1)=(diamd**2*RE_TAU/repd**2)*btuy(i,1,1,1)
        sh_z(i,1,1,1)=(diamd**2*RE_TAU/repd**2)*btwy(i,1,1,1)
      enddo

      sh_cr0=(0.22*repd**(-0.6)+0.06*exp(-17.77*repd**(-0.6)))*0.5
      
      if(IF_SHCR_VAR) then
      tan_cr=tan(PI/6.0)
        do i=1,n
          gamma=atan2(btwy(i,1,1,1),btuy(i,1,1,1))
          beta=th_z(i,1,1,1)*cos(gamma)+th_x(i,1,1,1)*sin(gamma)
          sh_cr(i,1,1,1)=sh_cr0*abs(cos(beta)*(1+(tan(beta)/tan_cr)))
        enddo
      else
        do i=1,n
          sh_cr(i,1,1,1)=sh_cr0
        enddo
      endif

      return
      end

      subroutine sediment_flux(sh_x,sh_z,sh_cr,qbx,qbz,repd)
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real sh_x(lx1,lz1,lelx,lelz),sh_z(lx1,lz1,lelx,lelz),
     &     sh_cr(lx1,lz1,lelx,lelz)  
      real qbx(lx1,lz1,lelx,lelz),qbz(lx1,lz1,lelx,lelz)
      real w1(lx1,lz1,lelx,lelz) 
      real repd
      real dum, dumx, dumz, dumrp
      integer n,i

      n=lx1*lz1*lelx*lelz

      call rzero(w1,n)
      call rzero(qbx,n)
      call rzero(qbz,n)

      do i=1,n
        dum=(sh_x(i,1,1,1)**2+sh_z(i,1,1,1)**2)**0.5
        if (dum.ge.sh_cr(i,1,1,1)) then
        dumx=sh_x(i,1,1,1)/dum
        dumz=sh_z(i,1,1,1)/dum
        qbx(i,1,1,1)=(repd/RE_TAU)*4.93*dumx*(dum-sh_cr(i,1,1,1))**1.6 !Wong & Parker MPM
        qbz(i,1,1,1)=(repd/RE_TAU)*4.93*dumz*(dum-sh_cr(i,1,1,1))**1.6
        endif
      enddo 

C       call gop(qbx,w1,'+  ',n)
C       call rzero(w1,n)
C       call gop(qbz,w1,'+  ',n)
      return
      end     


      subroutine parker_erosion(btuy,btwy)
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real btuy(lx1,lz1,lelx,lelz),btwy(lx1,lz1,lelx,lelz)
      real dum,zp,A,repd,cvd, ushear, factor, A1, A2
      integer n,i

      common /erosion/ E_s(lx1,lz1,lelx,lelz,ldimt)

c     ############################################################
      real Re_pp(ldimt),V_sp(ldimt),sp_fraction(ldimt),
     & alpha_fraction(ldimt)
      Re_pp = def_RE_P
      V_sp = def_Vs
      sp_fraction = def_gamma
      alpha_fraction = def_alpha
c     ############################################################

c     Garcia-Parker erosion model from Garcia, M. and Parker, G. (1993). 
C     "Experiments on the Entrainment of the Sediment into Suspension by a Dense
C     Bottom Current". J. Geophys. Res. 

      n=lx1*lz1*lelx*lelz


      call rzero(E_s,n*ldimt)

      A=1.3E-7
      factor = 1.0      
      do ips=1,ldimt
        if (Re_pp(ips).le.2.36) then
            A1 = 0.586
            A2 = 1.0
        else
            A1 = 1.23
            A2 = 0.6
        endif

        do i=1,n
          ushear = (btuy(i,1,1,1)**2+btwy(i,1,1,1)**2)**0.5
          ushear = (ushear/RE_TAU)**0.5
C           zp = Re_pp(ips)**0.6*ushear/V_sp(ips)*factor
          zp = A1*(ushear/V_sp(ips))*Re_pp(ips)**A2
          E_s(i,1,1,1,ips)=alpha_fraction(ips)*
     &                     (A*zp**5)/(1.0+10.0*A*zp**5)
        enddo
      enddo
C       call gop(E_s,w1,'+  ',n)
      return
      end

      subroutine bottom_copy(u,wo1)
c     This copies a 2d x-z array at the bottom of a 3d v-mesh, to allow the use of gradm1
      include 'SIZE'
      include 'GEOM'
      include 'ZPER'
      include 'PARALLEL'
      include 'WZ'


      real u(lx1,lz1,lelx,lelz)
      real wo1(lx1,ly1,lz1,lelv)
      integer e,eg,ex,ey,ez


      nxz=lx1*lz1*lelx*lelz
      nxyz=lx1*lz1*ly1*lelt
      call rzero(wo1,nxyz)

      do e=1,nelt
         eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
          do k=1,nz1
            do j=1,ny1
              do i=1,nx1
                wo1(i,j,k,e) = u(i,k,ex,ez)
              enddo
            enddo
          enddo
      enddo
      return
      end

      subroutine temp_threshold(tem,thr)
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real tem(lx1,ly1,lz1,lelv),thr(lx1,ly1,lz1,lelv)

      call rzero(thr,lx1*ly1*lz1*lelv)
      do i=1,lx1*ly1*lz1*lelv
        if (tem(i,1,1,1).gt.THRESHOLD) then
        thr(i,1,1,1)= 1.0
        endif
      enddo
      return
      end

      subroutine bed_angle(eta,th_x,th_z,lap_e,w1,w2,w3,w4,wxz1,wxz2,
     &  x,z)
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real eta(lx1,lz1,lelx,lelz)
      real th_z(lx1,lz1,lelx,lelz),th_x(lx1,lz1,lelx,lelz),
     &     lap_e(lx1,lz1,lelx,lelz)
      real wxz1(lx1,lz1,lelx,lelz),wxz2(lx1,lz1,lelx,lelz)
      real w1(lx1,ly1,lz1,lelv),w2(lx1,ly1,lz1,lelv),
     &     w3(lx1,ly1,lz1,lelv),w4(lx1,ly1,lz1,lelv)
      real x(lx1,lz1,lelx,lelz),z(lx1,lz1,lelx,lelz)
      real wxz3(lx1,lz1,lelx,lelz)


      integer i,nxz,nt,ex

      nxz=lx1*lz1*lelx*lelz
      nt=lx1*ly1*lz1*lelv

      call bottom_copy(eta,w4)
      call gradm1(w1,w2,w3,w4)

      call y_slice(th_x,w1,wxz1)        ! tan(theta_x)
      call y_slice(th_z,w3,wxz1)        ! tan(theta_z)

      call bed_filter(th_x,z,x,0)
      call bed_filter(th_z,z,x,0)

      call bottom_copy(th_z,w4)
      call gradm1(w1,w2,w3,w4)   !d2eta/dzz
      call y_slice(lap_e,w3,wxz1)

      call bottom_copy(th_x,w4)
      call gradm1(w1,w2,w3,w4)   !d2eta/dxx
      call y_slice(wxz3,w1,wxz1)
      call add2(lap_e,wxz3,nxz)      


      do i =1,nxz
        th_x(i,1,1,1)=atan(th_x(i,1,1,1))
        th_z(i,1,1,1)=atan(th_z(i,1,1,1))
      enddo

      call bed_filter(lap_e,z,x,0)
      return
      end

      subroutine B_eta_s(B,th_x,th_z)
c      Proporcionality constant between concentration and sediment height
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real B(lx1,lz1,lelx,lelz),
     &     th_x(lx1,lz1,lelx,lelz),th_z(lx1,lz1,lelx,lelz)
      real cvd
      integer n,i

      n=lx1*lz1*lelx*lelz
      cvd=Cv

      do i=1,n
        B(i,1,1,1)=dcos(th_x(i,1,1,1))*dcos(th_z(i,1,1,1))*cvd
      enddo
      return
      end

      subroutine q_integral_s(q_int,qbz,qbx,w1,w2,igs_x,igs_z)

      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real q_int
      real qbx(lx1,lz1,lelx,lelz),qbz(lx1,lz1,lelx,lelz)
      real q_thr(lx1,lz1,lelx,lelz)
      real w1(lx1,ly1,lz1,lelv),w2(lx1,ly1,lz1,lelv)
      integer igs_z,igs_x
      real q_mod,wght,dum, thres
      integer e,eg,ex,ey,ez,i

      q_int=0.0
      wght=0.0
      thres=0.000001
      nxz=lx1*lz1*lelx*lelz
      call rzero(q_thr,nxz)

      do i=1,nxz
        q_mod=(qbx(i,1,1,1)**2+qbz(i,1,1,1)**2)**0.5
        if (q_mod.ge.thres) q_thr(i,1,1,1)=q_mod 
      enddo
      call bottom_copy(q_thr,w1)
      call planar_avg(w2,w1,igs_z)
      call rzero(w1,size(w1))
      call planar_avg(w1,w2,igs_x)
      q_int=w1(1,1,1,1)

      
      return
      end

      subroutine read_bed(wxz)
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real wxz(lx1,lz1,lelx,lelz)
      real rdum
      integer idum, type, nxz

      common /heights/ eta(lx1,lz1,lelx,lelz),
     &               eta_e(lx1,lz1,lelx,lelz),
     &               eta_d(lx1,lz1,lelx,lelz),
     &               eta_q(lx1,lz1,lelx,lelz)

      nxz=lx1*lz1*lelx*lelz
      call rzero(eta,nxz)
      call rzero(eta_q,nxz)
      call rzero(eta_q2,nxz)
      call rzero(eta_q3,nxz)
      call rzero(eta_cb,nxz)
      call rzero(eta_qcb,nxz)
      call rzero(eta_es,nxz)


      if (nid.eq.0) then
          write(*,*)'###### Reading bedform file for restart ####'
          open(unit=58,file='bedform.ini',access='stream',
     &       form='unformatted')
          read(58) idum,idum,idum,idum
          read(58) type
          write(*,*) 'File contents type:', type
          read(58) rdum
          read(58) w2, w2, w2 !Es int_t btt
          read(58) eta_q
          read(58) w2, w2
          if (type .eq. 1 .or. type.eq.-1) read(58) w2, w2, w2, w2, w2
          if (type .eq. -1) read(58) eta_q2, w2, w2, w2, w2, w2
          if (type .eq. -1) read(58) eta_q3, w2, w2, w2, w2, w2
          read(58) eta
          if (type .eq. 1) read(58) w2, w2, w2, w2, w2
          read(58) eta_escb
          if (type .eq. 1) read(58) w2, w2
          read(58) eta_qcb
          if (type .eq. 1) read(58) w2, w2, w2, w2, w2
          read(58) eta_es
          read(58) eta_cb
          if (type .eq. 1) read(58) w2, w2
          close(58)
          write(*,*)'FILE: bedform.ini'
          write(*,*)'###### Reading bedform file for restart done ###'
        endif
      call rzero(wxz,nxz)
      call gop(eta,wxz,'+  ',nxz)
      call rzero(wxz,nxz)
      call gop(eta_q,wxz,'+  ',nxz)
      call rzero(wxz,nxz)
      call gop(eta_q2,wxz,'+  ',nxz)
      call rzero(wxz,nxz)
      call gop(eta_q3,wxz,'+  ',nxz)
      call rzero(wxz,nxz)
      call gop(eta_cb,wxz,'+  ',nxz)
      call rzero(wxz,nxz)
      call gop(eta_escb,wxz,'+  ',nxz)
      call rzero(wxz,nxz)
      call gop(eta_qcb,wxz,'+  ',nxz)
      call rzero(wxz,nxz)
      call gop(eta_es,wxz,'+  ',nxz)
      return
      end


      subroutine bed_filter(h, z, x,type)
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'


      real h(lx1,lz1,lelx,lelz)
      real z(lx1,lz1,lelx,lelz),x(lx1,lz1,lelx,lelz)
C       real w1(lx1,lz1,lelx,lelz)
      integer type
      real x_s(5),z_s(5),y_s(2)
      real xl,xm,xp,xr,zl,zm,zp,zr,z0,x0
      real dumm,xlen
      integer i,j,ex,ez
      integer per_x, per_z
      !type=1 replace lx-1,lx1,1,2
      !type=0 replace lx1,1
      per_x=1
      if (IF_FAN) per_x=0


      if (type.eq.1) then
        zl=z(1,lz1-2,1,1)-z(1,lz1,1,1)
        zm=z(1,lz1-1,1,1)-z(1,lz1,1,1)
        z0=0.0
        zp=z(1,2,1,1)
        zr=z(1,3,1,1)

        xl=x(lx1-2,1,1,1)-x(lx1,1,1,1)
        xm=x(lx1-1,1,1,1)-x(lx1,1,1,1)
        x0=0.0
        xp=x(2,1,1,1)
        xr=x(3,1,1,1)
      else
        zl=z(1,lz1-2,1,1)-z(1,lz1,1,1)
        z0=0.0
        zr=z(1,2,1,1)

        xl=x(lx1-1,1,1,1)-x(lx1,1,1,1)
        x0=0.0
        xr=x(2,1,1,1)
      endif  

      do ez=1,lelz-1
        do ex=1,lelx
C           first on z
          do i=1,lz1         !could be done up to lx1-1
            if (type.eq.1) then
              y_s(1)=h(i,lz1-2,ex,ez  )
              y_s(2)=h(i,3,    ex,ez+1)
            else
              y_s(1)=h(i,lz1-1,ex,ez  )
              y_s(2)=h(i,2,    ex,ez+1)
            endif
            dumm=y_s(1)*(zr-z0)+y_s(2)*(z0-zl)
            h(i,lz1,ex,ez)=dumm/(zr-zl)
            h(i,1,ex,ez+1)=dumm/(zr-zl)
            if (type.eq.1) then
              dumm=y_s(1)*(zr-zm)+y_s(2)*(zm-zl)
              h(i,lz1-1,ex,ez)=dumm/(zr-zl)
              dumm=y_s(1)*(zr-zp)+y_s(2)*(zp-zl)
              h(i,2,ex,ez+1)=dumm/(zr-zl)
            endif
          enddo
        enddo
      enddo

      do ez=1,lelz
        do ex=1,lelx-1
C           now x
          do j=1,lx1         !could be done up to lx1-1
            if (type.eq.1) then
              y_s(1)=h(lz1-2,j,ex,ez  )
              y_s(2)=h(3,j,    ex+1,ez)
            else
              y_s(1)=h(lz1-1,j,ex,ez  )
              y_s(2)=h(2,    j,ex+1,ez)
            endif
            dumm=y_s(1)*(xr-x0)+y_s(2)*(x0-xl)
            h(lx1,j,ex,ez)=dumm/(xr-xl)
            h(1,j,ex+1,ez)=dumm/(xr-xl)
            if (type.eq.1) then
              dumm=y_s(1)*(xr-xm)+y_s(2)*(xm-xl)
              h(lx1-1,j,ex,ez)=dumm/(xr-xl)
              dumm=y_s(1)*(xr-xp)+y_s(2)*(xp-xl)
              h(2,j,ex+1,ez)=dumm/(xr-xl)
            endif
          enddo
        enddo
      enddo
     
      if (per_x.eq.1) then
        do ez=1,lelz
          do j=1,lx1         !could be done up to lx1-1
            if (type.eq.1) then
              y_s(1)=h(lz1-2,j,lelx,ez  )
              y_s(2)=h(3,j,    1,ez)
            else
              y_s(1)=h(lz1-1,j,lelx,ez  )
              y_s(2)=h(2,    j,1,ez)
            endif
            dumm=y_s(1)*(xr-x0)+y_s(2)*(x0-xl)
            h(lz1,j,lelx,ez)=dumm/(xr-xl)
            h(1,j,1,ez)=dumm/(xr-xl)
            if (type.eq.1) then
              dumm=y_s(1)*(xr-xm)+y_s(2)*(xm-xl)
              h(lz1-1,j,lelx,ez)=dumm/(xr-xl)
              dumm=y_s(1)*(xr-xp)+y_s(2)*(xp-xl)
              h(2,j,1,ez)=dumm/(xr-xl)
            endif
          enddo
        enddo
      endif

      return
      end
      


      subroutine bedform_calcs(btwy,btuy,btt,xbmm,zbmm,wo1,wo2,wo3,wo4,
     &                        igs_x,igs_y,igs_z,
     &                     wxz1,wxz2,wxz3,sh_x,sh_z,sh_cr,qbx,qbz,int_t,
     &               qbxx,qbzz,theta_bedx,theta_bedz,B_eta, lap_eta)

      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real btwy(lx1,lz1,lelx,lelz),btuy(lx1,lz1,lelx,lelz),
     &     btt(lx1,lz1,lelx,lelz,ldimt),
     &     zbmm(lx1,lz1,lelx,lelz),xbmm(lx1,lz1,lelx,lelz)

      real wo1(lx1,ly1,lz1,lelv)
     &      ,  wo2(lx1,ly1,lz1,lelv)
     &      ,  wo3(lx1,ly1,lz1,lelv)
     &      ,  wo4(lx1,ly1,lz1,lelv)     

      integer igs_x, igs_y, igs_z

      common /heights/ eta(lx1,lz1,lelx,lelz),
     &               eta_e(lx1,lz1,lelx,lelz),
     &               eta_d(lx1,lz1,lelx,lelz),
     &               eta_q(lx1,lz1,lelx,lelz)


      common /erosion/ E_s(lx1,lz1,lelx,lelz,ldimt)
      common /ab2/ femm(lx1,lz1,lelx,lelz),
     &    fem(lx1,lz1,lelx,lelz), base_eta1(lx1,lz1,lelx,lelz),
     &    femm_e(lx1,lz1,lelx,lelz), fem_e(lx1,lz1,lelx,lelz), 
     &    femm_d(lx1,lz1,lelx,lelz), fem_d(lx1,lz1,lelx,lelz), 
     &    femm_q(lx1,lz1,lelx,lelz), fem_q(lx1,lz1,lelx,lelz),
     &    base_eta2(lx1,lz1,lelx,lelz)
      common /ab2_2/ dtmm, dtm, izb1, ezb1, izb2, ezb2


      common /eta_mvbc/ umeshx(lx1,ly1,lz1,lelv)
     &              , umeshy(lx1,ly1,lz1,lelv)
     &              , umeshz(lx1,ly1,lz1,lelv)
     &              , rhs(lx1,lz1,lelx,lelz)

      real wxz1(lx1,lz1,lelx,lelz),wxz2(lx1,lz1,lelx,lelz), 
     &     wxz3(lx1,lz1,lelx,lelz),!working arrays
     &     sh_x(lx1,lz1,lelx,lelz),  !Shields number
     &     sh_z(lx1,lz1,lelx,lelz),  !Shields number
     &     sh_cr(lx1,lz1,lelx,lelz),  !Critical Shields number
     &     qbx(lx1,lz1,lelx,lelz),   !Bottom sediment flux
     &     qbz(lx1,lz1,lelx,lelz),  !Bottom sediment flux
     &     int_t(lx1,lz1,lelx,lelz,ldimt),
     &     qbxx(lx1,lz1,lelx,lelz),
     &     qbzz(lx1,lz1,lelx,lelz),
     &     theta_bedx(lx1,lz1,lelx,lelz),
     &     theta_bedz(lx1,lz1,lelx,lelz),
     &     B_eta(lx1,lz1,lelx,lelz),
     &     lap_eta(lx1,lz1,lelx,lelz)
     

      real q_integral, dtimestep,cvd,repd(3),eps(3),zbu(2),rhsm_in,dumm
      integer e,ex,ez,ey,eg
      real vol_in
      save vol_in

      parameter (lx1tp=2*lx1+1)
      real kernelx_q(lx1,lx1tp), kernelz_q(lx1,lx1tp)
      save kernelx_q,kernelz_q
      integer mask_gf(lx1,lx1tp,2)
      save mask_gf

      character*32 istepc,outfile
      character*80 icfile
      integer nxz,i, if_write, mvs,j,k,n
      integer counter_bed
      save counter_bed
      real time_restart
      save time_restart

c     ############################################################
      real Re_pp(ldimt),V_sp(ldimt),sp_fraction(ldimt),
     & alpha_fraction(ldimt)
      Re_pp = def_RE_P
      V_sp = def_Vs
      sp_fraction = def_gamma
      alpha_fraction = def_alpha
c     ############################################################


      dtimestep = abs(dt)
      nxz=lx1*lz1*lelx*lelz
      n=lx1*ly1*lz1*lelv

      if (V_SETTLING.ne.0.0) then
        cvd=Cv
        repd(1)=RE_P
        mvs=1
      else
        cvd=0.005
        repd(1)=0.3
        repd(2)=1.8
        repd(3)=3.0
        mvs=3
      endif

      if (istep.eq.0) then
      call rzero(rhs,size(rhs))
        zbu(1) = IN_ZL
        zbu(2) = OUT_ZL
      do i=1,nxz
       base_eta1(i,1,1,1)=1.0
       base_eta2(i,1,1,1)=1.0
       if (zbmm(i,1,1,1).le.zbu(1)) then 
        base_eta1(i,1,1,1)=zbmm(i,1,1,1)/zbu(1)
        base_eta1(i,1,1,1)=base_eta1(i,1,1,1)**2.0
       endif
       if (zbmm(i,1,1,1).gt.(ZLEN-zbu(2))) then
        base_eta2(i,1,1,1)=(-1.0/zbu(2))*(zbmm(i,1,1,1)-ZLEN
     &                   +zbu(2))+1.0
        base_eta2(i,1,1,1)=base_eta2(i,1,1,1)**2.0
       endif
      enddo
      vol_in=0.0
      dumm=0.0
      do e=1,nelv
       eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
          do k=1,nz1
            do j=1,ly1
                do i=1,nx1
                  if (zbmm(i,k,ex,ez).gt.IN_ZL .and. 
     &                zbmm(i,k,ex,ez) .lt. (IN_ZL*1.5)) then
                    vol_in=vol_in+bm1(i,j,k,e)
                  endif
                enddo
              enddo
           enddo
      enddo
      call gop(vol_in,dumm,'+  ',1)

      do ez=1,lelz
       do i=1,lz1
        izb2 = i
        ezb2 = ez
        if (zbmm(1,i,1,ez).gt.(ZLEN-zbu(2))) exit 
       enddo
      enddo
      do ez=1,lelz
       do i=1,lz1
        izb1 = i
        ezb1 = ez
        if (zbmm(1,i,1,ez).gt.(zbu(1))) exit 
       enddo
      enddo

      endif !istep.eq.0

      if (istep.eq.0) counter_bed=0
      if (istep.eq.0) time_restart=time
      if_write=0
      if (nid.eq.0) then
      if (param(15).ne.0) then !writeControl = numStep
        write(istepc,'(i32)') istep
        istepc=adjustl(istepc)
        icfile=trim(path)//trim('bed.'//trim(istepc))
        if (mod(istep,int(iostep_bed)).eq.0) then 
          if_write = 1
        else
          if_write = 0
        endif
      else !writeControl = runTime
        write(istepc,'(i32)') counter_bed
        istepc=adjustl(istepc)
        icfile=trim('bed.'//trim(istepc))

       if (iostep_bed*aint((time-time_restart)/iostep_bed)
     &  .ge.counter_bed*iostep_bed)
     &    then 
          if_write = 1
          counter_bed = counter_bed +1 
        else
          if_write = 0
       endif
      endif
      endif
C       do i=1,nxz*ldimt
C         if (btt(i,1,1,1,1).lt.0.0) btt(i,1,1,1,1)=0.0
C       enddo

      q_integral = 0.0

      call bed_angle(eta,theta_bedx,theta_bedz,lap_eta,
     &               wo1,wo2,wo3,wo4,wxz1,wxz2,xbmm,zbmm) !compute bedform angles (in radians!) and eta laplacian.

C       if (istep.eq.0) call set_mean_filter(zbmm, xbmm, WDW_EXNER_RHS,1)
C       if (istep.eq.0) call set_mean_filter(zbmm, xbmm, WDW_EXNER_Q,2)
      if(IF_DIVQ) then
        if (istep.eq.0) call gaussian_filter_setup(zbmm,xbmm,
     &  zbmm(1,lx1,1,1)/STD_EXNER_QZ,xbmm(lx1,1,1,1)/STD_EXNER_QX,
     &  kernelz_q,kernelx_q,mask_gf) 

        call shields(sh_x,sh_z,sh_cr,btuy,btwy,theta_bedx,theta_bedz,
     &                                                     repd(1),cvd)       !compute Shields and Critical Shields number
        call bed_filter(sh_cr, zbmm, xbmm,0)
        call sediment_flux(sh_x,sh_z,sh_cr,qbx,qbz,repd(1)) !compute bottom sediment flux (Wong & Parker MPM)
C     Sediment flux gradient
        call bottom_copy(qbx,wo4)
        call gradm1(wo1,wo2,wo3,wo4)
        call y_slice(qbxx,wo1,wxz1)        ! dqbx/dx
        call bed_filter(qbxx, zbmm, xbmm,0)

        call bottom_copy(qbz,wo4)
        call gradm1(wo1,wo2,wo3,wo4)
        call y_slice(qbzz,wo3,wxz1)        ! dqbz/dz
        call bed_filter(qbzz, zbmm, xbmm,0)

C       call q_integral_s(q_integral,qbz,qbx,wo1,wo2,igs_x,igs_z)
        call add3(wxz1,qbxx,qbzz,nxz)      ! div dot q
        call gaussian_filter(wxz1,kernelz_q, kernelx_q,mask_gf)   !wxz1 -> div dot q
      else
        call rzero(wxz1,nxz) !wxz1 -> div dot q
      endif

      if(IF_DEPO) then 
        call B_eta_s(B_eta,theta_bedx,theta_bedz)   !Proportionality constant between concentration and sediment height
      else
        call rzero(B_eta,nxz)
      endif


      if (if_write.eq.1) then        
          open(unit=71,file=icfile,access='stream',form='unformatted')
          write(71) int(lx1),int(lelx),int(lely),int(lelz),int(ldimt)
          write(71) time
          write(71) int_t
          write(71) btt
          write(71) E_s
          write(71) btwy
          write(71) btuy
          close(71)
      endif

      return
      end

      subroutine my_base_meshv(basev)
      include 'SIZE'
      include 'TOTAL'
      real basev(lx1,ly1,lz1,lelv)
      integer n,i
      
      n = nx1*ny1*nz1*nelv
      call rzero(basev ,n)  ! basev  = 0
      do i=1,n
         y=ym1(i,1,1,1)
         if (y.lt.hint) then
          basev(i,1,1,1)=1.0
         else 
          basev(i,1,1,1) = -1.0*(y-hint)/(YLEN-hint)+1.0
         endif
      enddo

      return
      end

      subroutine eta_mvmesh()

      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'
      parameter (lt=lx1*ly1*lz1*lelv)

      common /cmeshv/ basev(lt)   

      common /eta_mvbc/ umeshx(lx1,ly1,lz1,lelv)
     &              , umeshy(lx1,ly1,lz1,lelv)
     &              , umeshz(lx1,ly1,lz1,lelv)
     &              , rhs(lx1,lz1,lelx,lelz)

      integer i, nxz, n,j,k
      integer e,eg,ex,ey,ez

      nxz=lx1*lz1*lelx*lelz
      n = nx1*ny1*nz1*nelv

      if (istep.eq.0) call my_base_meshv(basev)

      call rzero(umeshy,n)
      call bottom_copy(rhs,umeshy)

      do i=1,n
        umeshy(i,1,1,1)=umeshy(i,1,1,1)*basev(i)
        wx(i,1,1,1)=0.0
        wy(i,1,1,1)=umeshy(i,1,1,1)
        wz(i,1,1,1)=0.0
        umeshx(i,1,1,1) = wx(i,1,1,1)
        umeshz(i,1,1,1) = wz(i,1,1,1)
      enddo

C         ifpo=.false.
C         ifto=.false.
C       if (mod(istep,10).eq.0) 
C      &  call outpost2(wy,umeshy,wx,pr,t,0,'tes')

C C         ifpo=.true.
C         ifto=.true.


      return
      end
      subroutine stress_normal(btuy,btwy,wxz1,
     &                        thx,thz)

      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'


      real btuy(lx1,lz1,lelx,lelz),btwy(lx1,lz1,lelx,lelz)
      real wxz1(lx1,lz1,lelx,lelz)
      real thx(lx1,lz1,lelx,lelz),thz(lx1,lz1,lelx,lelz)

      common /v_filter/ vx_f(lx1,ly1,lz1,lelv),vy_f(lx1,ly1,lz1,lelv),
     &                  vz_f(lx1,ly1,lz1,lelv),t_f(lx1,ly1,lz1,lelv)

      integer nxz,e,eg,ex,ey,ez,i,j,k
      real sn(3),normdum,dum
      real vxx(lx1,ly1,lz1,lelv),
     $     vxy(lx1,ly1,lz1,lelv),
     $     vxz(lx1,ly1,lz1,lelv),
     $     vzx(lx1,ly1,lz1,lelv),
     $     vzy(lx1,ly1,lz1,lelv),
     $     vzz(lx1,ly1,lz1,lelv)

      nxz=lx1*lz1*lelx*lelz
      call rzero(btuy,nxz)
      call rzero(btwy,nxz)

      do e=1,nelv
           eg = lglel(e)
           call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
            do k=1,nz1
              do j=1,ly1
                  do i=1,nx1
                   vx_f(i,j,k,e)=vx_f(i,j,k,e)*cos(thx(i,k,ex,ez))-
     &                           vy_f(i,j,k,e)*sin(thx(i,k,ex,ez))
                   vz_f(i,j,k,e)=vz_f(i,j,k,e)*cos(thz(i,k,ex,ez))-
     &                           vy_f(i,j,k,e)*sin(thz(i,k,ex,ez))
                  enddo
                enddo
             enddo
      enddo

c     compute gradients
      call gradm1(vxx,vxy,vxz,vx_f)
      call gradm1(vzx,vzy,vzz,vz_f)

      do e=1,nelv
           eg = lglel(e)
           call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)
           if (ey.eq.1) then
            j=1
              do k=1,nz1
                  do i=1,nx1
                   sn(1)=sin(thx(i,k,ex,ez))*cos(thz(i,k,ex,ez))
                   sn(2)=cos(thx(i,k,ex,ez))*cos(thz(i,k,ex,ez))
                   sn(3)=cos(thx(i,k,ex,ez))*sin(thz(i,k,ex,ez))
                   normdum=(sn(1)**2+sn(2)**2+sn(3)**2)**0.5
                   sn(1)=sn(1)/normdum
                   sn(2)=sn(2)/normdum
                   sn(3)=sn(3)/normdum
                   btuy(i,k,ex,ez)= vxx(i,j,k,e)*sn(1)+
     &                  vxy(i,j,k,e)*sn(2)+vxz(i,j,k,e)*sn(3)
                   btwy(i,k,ex,ez)= vzx(i,j,k,e)*sn(1)+
     &                  vzy(i,j,k,e)*sn(2)+vzz(i,j,k,e)*sn(3)
                  enddo
                enddo
           endif
          enddo
      call rzero(wxz1,size(wxz1))
      call gop(btuy,wxz1,'+  ',nxz)
      call rzero(wxz1,size(wxz1))
      call gop(btwy,wxz1,'+  ',nxz)
      return 
      end


      subroutine A_Bashforth_2(q,femm,fem,dtmm,dtm)

      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real q(lx1,lz1,lelx,lelz),
     &     femm(lx1,lz1,lelx,lelz),
     &     fem(lx1,lz1,lelx,lelz)

     
      real dtmm, dtm
      integer n,i
      real dummy
      
C       Performs the time integration of quantity q, using a multistep
C       Adams-Basforth 2nd order scheme, with variable step size.
C       y_k=y_(k-1)+h_k*(f_(k-1)+0.5*(h_k/h_(k-1))*(f_(k-1)-f_(k-2))) 
C       femm <-- f_(k-2) ; fem <-- f_(k-1)
C       dtm <-- h_k=t_k-t_(k-1); dtmm <-- h_(k-1)=t_(k-1)-t_(k-2)

      n=lx1*lz1*lelx*lelz

      do i=1,n
       dummy=fem(i,1,1,1)+0.5*(dtm/dtmm)*(fem(i,1,1,1)-femm(i,1,1,1))
       dummy=dummy*dtm
       q(i,1,1,1)=q(i,1,1,1)+dummy
      enddo

      return
      end
      
c ---------------------------------------------------      


      subroutine gaussian_filter_setup(z,x,std_z,std_x,kernelz,
     & kernelx,mask_gf)

      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real z(lx1,lz1,lelx,lelz),x(lx1,lz1,lelx,lelz)
      real std_x,std_z

      parameter (lx1tp=2*lx1+1)
      real kernelx(lx1,lx1tp),
     & kernelz(lx1,lx1tp)
      integer mask_gf(lx1,lx1tp,2)
     

      real delx(lx1),delz(lx1), deltx(lx1,2*lx1+1), deltz(lx1,2*lx1+1)
      real ksx,ksz,dumm, del_x, del_z
      integer i,j,k,nxz
      integer ip, el
      nxz=lx1*lz1*lelx*lelz

      do i =1,lx1-1
        delx(i)=x(i+1,1,1,1)-x(i,1,1,1)
      enddo
      delx(lx1)=0.0
      do i =1,lz1-1
        delz(i)=z(1,i+1,1,1)-z(1,i,1,1)
      enddo

      if (nid.eq.0) then 
        write(*,*) 'Gaussian filter setup..................'
        write(*,*) 'Element size in x:',x(lx1,1,1,1), 'sigma_x:',std_x
        write(*,*) 'Element size in z:',z(1,lx1,1,1), 'sigma_z:',std_z
      endif

      do i=1,lx1
        deltx(i,lx1+1)=0.0
        deltz(i,lx1+1)=0.0
        mask_gf(i,lx1+1,1)=i
        mask_gf(i,lx1+1,2)=0

        del_x=0.0
        del_z=0.0
        do k=lx1+2,lx1tp
         ip=i+k-lx1-1
         el=0
         if (ip.gt.lx1) then
           ip=ip-lx1
           el=1
         endif
         del_x=del_x+delx(ip-1)
         deltx(i,k)=del_x
         del_z=del_z+delz(ip-1)
         deltz(i,k)=del_z
         mask_gf(i,k,1)=ip
         mask_gf(i,k,2)=el
        enddo
        del_x=0.0
        del_z=0.0
        do k=lx1,1,-1
          ip=i+k-lx1-1
          el=0
          if (ip.lt.1) then
           ip=ip+lx1
           el=-1
          endif
          del_x=del_x-delx(ip)
          deltx(i,k)=del_x
          del_z=del_z-delz(ip)
          deltz(i,k)=del_z
          mask_gf(i,k,1)=ip
          mask_gf(i,k,2)=el
        enddo
        ksx=0.0
        ksz=0.0
        do k=1,lx1tp
         dumm=-1.0*(deltx(i,k)**2)/(2.0*std_x**2)
         kernelx(i,k)=exp(dumm)
         if (mask_gf(i,k,1).eq.lx1) kernelx(i,k)=0.0
         ksx=ksx+kernelx(i,k)
         dumm=-1.0*(deltz(i,k)**2)/(2.0*std_z**2)
         kernelz(i,k)=exp(dumm)
         if (mask_gf(i,k,1).eq.lx1) kernelz(i,k)=0.0
         ksz=ksz+kernelz(i,k)
        enddo
        do k=1,lx1tp
          kernelx(i,k)=kernelx(i,k)/ksx
          kernelz(i,k)=kernelz(i,k)/ksz
        enddo
      enddo

      return
      end


      subroutine gaussian_filter(q,kernelz, kernelx,mask_gf)

      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'
C       Beware with edge boundaries, node lx1 = 0!!

      real q(lx1,lz1,lelx,lelz)
      parameter (lx1tp=2*lx1+1)
      real kernelx(lx1,lx1tp), kernelz(lx1,lx1tp)
      integer mask_gf(lx1,lx1tp,2)

      integer i,j,k,ex,ez,nxz, im,em
      real wq(lx1,lz1,lelx,lelz)
      real dumm1,dumm2
      nxz=lx1*lz1*lelx*lelz

      call rzero(wq,nxz)
C       first x
      do ez=1,lelz
        do ex=1,lelx
          do j=1,lz1
            do i=1,lx1
              dumm1=q(i,j,ex,ez)
              do k=1,lx1tp
               im=mask_gf(i,k,1)
               em=mask_gf(i,k,2)
               if (ex.eq.lelx .and. em.ge.1) then
                if (IF_FAN) then
                  cycle !I'm ignoring some bad edge behavior here, I'll fix it some day
                else
                  wq(im,j,em,ez)=wq(im,j,em,ez)+dumm1*kernelx(i,k)
                 endif
                elseif (ex.eq.1 .and. em.lt.0) then
                 if (IF_FAN) then
                   cycle
                 else
                   wq(im,j,lelx+1+em,ez)=wq(im,j,lelx+1+em,ez)  !if em=-1, ex=lelx
     &                                   +dumm1*kernelx(i,k)
                 endif
                else
                  wq(im,j,ex+em,ez)=wq(im,j,ex+em,ez)+dumm1*kernelx(i,k)
               endif
              enddo
            enddo
          enddo
        enddo
      enddo

C       now z
      call rzero(q,nxz)

      do ez=1,lelz
        do ex=1,lelx
          do j=1,lz1
            do i=1,lx1
              dumm1=wq(i,j,ex,ez)
              do k=1,lx1tp
               im=mask_gf(j,k,1)
               em=mask_gf(j,k,2)
               if (ez.eq.lelz .and. em.ge.1) then
                  cycle
               elseif (ez.eq.1 .and. em.lt.0) then
                  cycle
               else
                  q(i,im,ex,ez+em)=q(i,im,ex,ez+em)+dumm1*kernelz(j,k)
               endif
              enddo
            enddo
          enddo
        enddo
      enddo

      return
      end

      subroutine read_inflow_sem(in_dns,inpoints,in_bulk,si_eddies)
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'
C       include 'PARALLEL'

      real in_dns(600,15)
C       integer inpoints
      real in_bulk,inpoints,si_eddies
      integer i,j 
      real dum(600,15)
      real rdum

      if(nid.eq.0) then
        write(6,*) 'Reading inflow data.....'
        open(53,file=trim(path)//'inflow.dat',status='old')
        read(53,*) inpoints
        read(53,*) in_bulk
        read(53,*) si_eddies
c     y, u_m, v_m, w_m, t_m, a11, a21, a22, a31, a32, a33, a41, a42, a43, a44 
        do i=1,int(inpoints)
          read(53,*) (in_dns(i,j),j=1,15)
        enddo
        close(53)
      endif
      call rzero(dum,600*15)
      call gop(in_dns,dum,'+  ',600*15)
      rdum=0.0
      call gop(inpoints,rdum,'+  ',1)
C       call bcast(npoints,isize)
      rdum=0.0
      call gop(in_bulk,rdum,'+  ',1)
      rdum=0.0
      call gop(si_eddies,rdum,'+  ',1)

      return
      end


      subroutine interp_inflow_sem(in_dns,npoints,yline,in_dns_interp,
     &  n_eddies,si_eddies,yinlet)
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      parameter(ny=nelyin*lx1)
      parameter(nel_slab = nelxin*nelyin)
      parameter(nelin = nelxin*nelyin*lx1*ly1)

      real in_dns(600,15)
      real yline(ny)
      integer npoints,n_eddies
      real in_dns_interp(lx1,ly1,nel_slab,14)
      real si_eddies
      real yinlet(lx1,ly1,nel_slab)

    
      real w1t(ly1,lely),w2t(ly1,lely)
      real y_inflow(npoints),dum(npoints)
      real wintr3(npoints), wintr2(npoints)
      real dum2(ny,14)
      real dumr, offset
      integer i,j,iel,k

      do i=1,npoints
        y_inflow(i)=in_dns(i,1)!+offset
      enddo
      
      if (.TRUE.) then
        do j=1,14
          do i=1,npoints
           dum(i)=in_dns(i,j+1)
          enddo
          do iel=1,nel_slab
            do k=1,ly1
              do i=1,lx1
            call interp1(y_inflow,dum,npoints,yinlet(i,k,iel),!-offset,
     &        in_dns_interp(i,k,iel,j))
              enddo
            enddo
          enddo
        enddo
      endif

      dumr=0.0
      do i=2,ny
        if (yline(i)-yline(i-1).gt.dumr) dumr=yline(i)-yline(i-1)
      enddo
C       si_eddies=dumr/0.5                    !<--------------------Change
      si_eddies = max(si_eddies, dumr)
      dumr=(xlen_inflow+2.0*si_eddies)*
     &      (hf+2.0*si_eddies)*2.0*si_eddies
      n_eddies=min(int(dumr/(si_eddies**3)),5000)

      if (nid.eq.0) write(*,*)'Eddy size=',si_eddies,
     &                ', number of eddies= ',n_eddies

      return
      end

      subroutine gen_inflow_sem(vxin_pl,vyin_pl,vzin_pl,tin_pl
     &           ,n_eddies,si_eddies,in_bulk,in_dns_interp,
     &           dtimestep,xinlet,yinlet)

      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      parameter(nel_slab = nelxin*nelyin)
      parameter(nelin = nelxin*nelyin*lx1*ly1)
      integer n_eddies
      real si_eddies,in_bulk,dtimestep

      real in_dns_interp(lx1,ly1,nel_slab,14)

      real vxin_pl(lx1,ly1,nel_slab)
     $    ,vyin_pl(lx1,ly1,nel_slab)
     $    ,vzin_pl(lx1,ly1,nel_slab)
     $    ,tin_pl(lx1,ly1,nel_slab)
     $    ,xinlet(lx1,ly1,nel_slab)
     $    ,yinlet(lx1,ly1,nel_slab)

      real perx(lx1,ly1,nel_slab) !it's not needed to be an array, but let's leave it like that for now
     $    ,pery(lx1,ly1,nel_slab)
     $    ,perz(lx1,ly1,nel_slab)
     $    ,pert(lx1,ly1,nel_slab)

      integer proc(2)

      real Vb(3)
      real rdum,fx,fy,fz,fac,fs


      real in_eds(5000,7)
      save in_eds
      real dum1(5000,7)
      real dum2(lx1,ly1,nel_slab)

      integer icalld
      save icalld
      data icalld  /0/

      integer i,j,k, iy, ix, iel, idum
      real offset, dumr

      offset = 0.0
      
      idum=int(n_eddies/np)
      if (nid.lt.np-1)then
        proc(1)=nid*idum+1
        proc(2)=nid*idum+idum
      elseif (nid.eq.np-1) then
        proc(1)=nid*idum+1
        proc(2)=n_eddies
      else
        proc(1)=-1
        proc(2)=-1
      endif

      Vb(1)=xlen_inflow+2.0*si_eddies
      Vb(2)=hf+2.0*si_eddies
      Vb(3)=2.0*si_eddies


      fac=(Vb(1)*Vb(2)*Vb(3)*si_eddies**(-3.0))**0.5

      if (istep.eq.0) then
      if ( nid.eq.0) then !eddies placement
        do i=1,n_eddies
          call RANDOM_NUMBER(rdum)
          in_eds(i,1)=Vb(1)*rdum
          call RANDOM_NUMBER(rdum)
          in_eds(i,2)=Vb(2)*rdum !+ offset
          call RANDOM_NUMBER(rdum)
          in_eds(i,3)=Vb(3)*rdum-si_eddies
          do j=1,4
            call RANDOM_NUMBER(rdum)
            in_eds(i,j+3)=int((10*rdum)/5)*2-1
          enddo
        enddo
       endif
      call rzero(dum1,5000*7)
      call gop(in_eds,dum1,'+  ',5000*7)
      endif

      if(istep.gt.0) then
      if (nid.eq.0) then
      do i=1,n_eddies  
        in_eds(i,3)=in_eds(i,3)+in_bulk*dtimestep !advect eddies
        if (in_eds(i,3).gt.si_eddies) then !if they get out of the box, regenerate them on the other side
          in_eds(i,3)=-si_eddies
          call RANDOM_NUMBER(rdum)
          in_eds(i,1)=Vb(1)*rdum
          call RANDOM_NUMBER(rdum)
          in_eds(i,2)=Vb(2)*rdum !+ offset
          do j=1,4
            call RANDOM_NUMBER(rdum)
            in_eds(i,j+3)=int((10*rdum)/5)*2-1
          enddo
        endif
      enddo
      else
        call rzero(in_eds,5000*7)
      endif
      call rzero(dum1,5000*7)
      call gop(in_eds,dum1,'+  ',5000*7)
      endif


      call rzero(perx,nelin)
      call rzero(pery,nelin)
      call rzero(perz,nelin)
      call rzero(pert,nelin)


      do iel=1,nel_slab !generate perturbations
        do iy=1,ly1
          do ix=1,lx1
C             idum=iy*(int(iel/nelxin)+1)
            if (proc(1).gt.0)then
             do k=proc(1),proc(2)
                fx=0.0
                fy=0.0
                fz=0.0
                rdum=(xinlet(ix,iy,iel)-in_eds(k,1))/si_eddies
                if (abs(rdum).lt.1) fx=1.5**0.5*(1.0-abs(rdum))
                rdum=(yinlet(ix,iy,iel)-in_eds(k,2))/si_eddies
                if (abs(rdum).lt.1) fy=1.5**0.5*(1.0-abs(rdum))
                rdum=(0.0-in_eds(k,3))/si_eddies
                if (abs(rdum).lt.1) fz=1.5**0.5*(1.0-abs(rdum))
                fs=fac*fx*fy*fz

                perx(ix,iy,iel)=perx(ix,iy,iel)+fs*in_eds(k,4)
                pery(ix,iy,iel)=pery(ix,iy,iel)+fs*in_eds(k,5)
                perz(ix,iy,iel)=perz(ix,iy,iel)+fs*in_eds(k,6)
                pert(ix,iy,iel)=pert(ix,iy,iel)+fs*in_eds(k,7)
             enddo
           endif
          enddo
        enddo
      enddo

      call rzero(dum2,nelin)
      call gop(perx,dum2,'+  ',nelin)
      call rzero(dum2,nelin)
      call gop(pery,dum2,'+  ',nelin)
      call rzero(dum2,nelin)
      call gop(perz,dum2,'+  ',nelin)
      call rzero(dum2,nelin)
      call gop(pert,dum2,'+  ',nelin)


      do iel=1,nel_slab !multiply by Reynolds stress tensor cholesky decomposition and add to means.
        do iy=1,ly1
          do ix=1,lx1
             rdum=perx(ix,iy,iel)*in_dns_interp(ix,iy,iel,5)
             rdum=rdum*(1.0/n_eddies**0.5) 
             vxin_pl(ix,iy,iel)=in_dns_interp(ix,iy,iel,1)+rdum

             rdum=perx(ix,iy,iel)*in_dns_interp(ix,iy,iel,6)+
     &            pery(ix,iy,iel)*in_dns_interp(ix,iy,iel,7)
             rdum=rdum*(1.0/n_eddies**0.5) 
             vyin_pl(ix,iy,iel)=in_dns_interp(ix,iy,iel,2)+rdum

             rdum=perx(ix,iy,iel)*in_dns_interp(ix,iy,iel,8)+
     &            pery(ix,iy,iel)*in_dns_interp(ix,iy,iel,9)+
     &            perz(ix,iy,iel)*in_dns_interp(ix,iy,iel,10)
             rdum=rdum*(1.0/n_eddies**0.5) 
             vzin_pl(ix,iy,iel)=in_dns_interp(ix,iy,iel,3)+rdum

             rdum=perx(ix,iy,iel)*in_dns_interp(ix,iy,iel,11)+
     &            pery(ix,iy,iel)*in_dns_interp(ix,iy,iel,12)+
     &            perz(ix,iy,iel)*in_dns_interp(ix,iy,iel,13)+
     &            pert(ix,iy,iel)*in_dns_interp(ix,iy,iel,14)
             rdum=rdum*(1.0/n_eddies**0.5) 
             tin_pl(ix,iy,iel)=in_dns_interp(ix,iy,iel,4)+rdum
          enddo
        enddo
      enddo


      return
      end

      subroutine inlet_plane(ua,u,w1, offset)
      include 'SIZE'
      include 'GEOM'
      include 'PARALLEL'
      include 'WZ'
      include 'ZPER'
      parameter(nel_slab=nelxin*nelyin)

      real ua(nx1,ny1,nel_slab),u(nx1,ny1,nz1,nelt),w1(nx1,ny1,nel_slab)
      real offset

      integer e,eg,ex,ey,ez, mxy ,elm

      mxy=nx1*ny1*nel_slab
      call rzero(ua,mxy)
      call rzero(w1,mxy)

      do e=1,nelt
c
         eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,nelx,nely,nelz)

         k = 1
         if (ey.le.nelyin .and. ex.le.nelxin .and. ez.eq.1) then
            do j=1,ny1
            do i=1,nx1
              elm=(ey-1)*nelxin+ex
              ua(i,j,elm) = u(i,j,k,e) + offset
            enddo
            enddo
         endif
      enddo

      call gop(ua,w1,'+  ',mxy)


      return
      end


      subroutine interp1(xa,ya,n,x,y)
      integer n
      real xa(n),ya(n)
      
      integer klo,khi
      real h
      klo=1
      khi=n
    1   if ((khi-klo).gt.1) then
           k=(khi+klo)/2
           if (xa(k).gt.x) then
              khi=k
           else
              klo=k
           endif
           goto 1
        endif
      h=xa(khi)-xa(klo)
      if (h.eq.0) then
          y=ya(khi)
         return
      endif
      y=ya(klo)+(x-xa(klo))*((ya(khi)-ya(klo))/h)
      return
      end

      subroutine spanwise_copy(u,wo1)
c     This copies a 2d y-z array into a 3d array
      include 'SIZE'
      include 'GEOM'
      include 'ZPER'
      include 'PARALLEL'
      include 'WZ'


      real u(ly1,lz1,lely,lelz)
      real wo1(lx1,ly1,lz1,lelv)
      integer e,eg,ex,ey,ez


      nxz=ly1*lz1*lely*lelz
      nxyz=lx1*lz1*ly1*lelv
      call rzero(wo1,nxyz)

      do e=1,nelt
         eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,lelx,lely,lelz)
          do k=1,lz1
            do j=1,ly1
              do i=1,lx1
                wo1(i,j,k,e) = u(j,k,ey,ez)
              enddo
            enddo
          enddo
      enddo

      return
      end


      subroutine set_ic_sem()
c     This sets the IC as using inlet data
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'  ! for nelx,nely,nelz

      integer e,eg,ex,ey,ez, idum
      real ydum, xdum, zdum, yp, cc, kk
      real kx, ky, alpha, beta, eps, dum
      
      parameter(nel_slab=nelxin*nelyin)
      common /inflow_pl/ vxin_pl(lx1,ly1,nel_slab)
     $                  ,vyin_pl(lx1,ly1,nel_slab)
     $                  ,vzin_pl(lx1,ly1,nel_slab)
     $                  ,tin_pl(lx1,ly1,nel_slab)



      eps = 1e-1
      kx  = 23
      kz  = 13

      alpha = kx * 2*PI/ZLEN
      beta  = kz * 2*PI/XLEN

      do e=1,nelt
         eg = lglel(e)
         call get_exyz(ex,ey,ez,eg,lelx,lely,lelz)
          do k=1,lz1
            do j=1,ly1
              do i=1,lx1
                ydum = ym1(i,j,k,e)
                zdum = zm1(i,j,k,e)
                xdum = xm1(i,j,k,e)
                idum = (ey-1)*nelxin + ex
                if (ydum .le. hf) then
                  vx(i,j,k,e) =-eps*alpha*cos(alpha*zdum)*sin(beta*xdum)
                  vy(i,j,k,e) = eps  * sin(alpha*zdum)*sin(beta*xdum)
                  vz(i,j,k,e) = vzin_pl(i,j,idum) 
     &                + eps*beta  * sin(alpha*zdum)*cos(beta*xdum) 
                  t(i,j,k,e,1) = tin_pl(i,j,idum)
                endif !(ydum .le. hf)
              enddo
            enddo
          enddo
      enddo


      return
      end

      subroutine lambdaci(lci)
c
c     Generate Lambda-ci vortex
c
      include 'SIZE'
      include 'TOTAL'

      real*8 lci(lx1,ly1,lz1,lelv)
      real*8 udx(lx1,ly1,lz1,nelv),udy(lx1,ly1,lz1,nelv),
     $       udz(lx1,ly1,lz1,nelv),vdx(lx1,ly1,lz1,nelv),
     $       vdy(lx1,ly1,lz1,nelv),vdz(lx1,ly1,lz1,nelv),
     $       wdx(lx1,ly1,lz1,nelv),wdy(lx1,ly1,lz1,nelv),
     $       wdz(lx1,ly1,lz1,nelv)

      parameter (lxyz=lx1*ly1*lz1)
      real*8 gije(lxyz,ldim,ldim),a(ldim,ldim)
      real*8 wr(3),wi(3)
      real*8 work(4*3),aux
      integer iaux,imax

      nxyz = nx1*ny1*nz1
      n    = nxyz*nelv

      wght = 0.5
      ncut = 1
C       call filter_s0(vx,wght,ncut,'vx')
C       call filter_s0(vy,wght,ncut,'vy')
C       call filter_s0(vz,wght,ncut,'vz')

      do ie=1,nelv
         ! Compute velocity gradient tensor
         call comp_gije(gije,vx(1,1,1,ie),vy(1,1,1,ie),vz(1,1,1,ie),ie)
         do l=1,nxyz
            udx(l,1,1,ie)=gije(l,1,1)
            udy(l,1,1,ie)=gije(l,1,2)
            udz(l,1,1,ie)=gije(l,1,3)

            vdx(l,1,1,ie)=gije(l,2,1)
            vdy(l,1,1,ie)=gije(l,2,2)
            vdz(l,1,1,ie)=gije(l,2,3)

            wdx(l,1,1,ie)=gije(l,3,1)
            wdy(l,1,1,ie)=gije(l,3,2)
            wdz(l,1,1,ie)=gije(l,3,3)
         enddo
      enddo

c     Smooth derivatives
      call smooth_fld(udx,1)
      call smooth_fld(udy,2)
      call smooth_fld(udz,3)

      call smooth_fld(vdx,1)
      call smooth_fld(vdy,2)
      call smooth_fld(vdz,3)

      call smooth_fld(wdx,1)
      call smooth_fld(wdy,2)
      call smooth_fld(wdz,3)

c     Compute lci
      do ie=1,nelv
         do l=1,nxyz
            a(1,1)=udx(l,1,1,ie)
            a(1,2)=udy(l,1,1,ie)
            a(1,3)=udz(l,1,1,ie)

            a(2,1)=vdx(l,1,1,ie)
            a(2,2)=vdy(l,1,1,ie)
            a(2,3)=vdz(l,1,1,ie)

            a(3,1)=wdx(l,1,1,ie)
            a(3,2)=wdy(l,1,1,ie)
            a(3,3)=wdz(l,1,1,ie)

            call dgeev('N','N',3,a,3
     $                 ,wr,wi,a,3,a,3,work,4*3,iaux)
            imax=idamax(3,wi,1)
            lci(l,1,1,ie) = abs(wi(imax))            
         enddo
      enddo

      ! smooth field
      wght = 0.5 
      ncut = 1
      call filter_s0(lci,wght,ncut,'vortx') 

      return
      end

      subroutine smooth_fld(u,ddir)

      include 'SIZE'
      include 'TOTAL'

      real*8 u(lx1,ly1,lz1,nelv),udum(lx1,ly1,lz1,nelv)
      integer i,j,k,im,jm,km,ie,ddir

      nxyz = nx1*ny1*nz1
      n    = nxyz*nelv
      call copy(udum,u,n)

      if (ddir.eq.1) then
c       x derivative
        do ie=1,nelv
         do k=1,nz1
         do j=1,ny1
         do i=1,nx1          
            if (i.eq.1) then
              im = i+1
              udum(i,j,k,ie) = u(im,j,k,ie)
            elseif (i.eq.nx1) then
              im = i-1
              udum(i,j,k,ie) = u(im,j,k,ie)
            endif
         enddo
         enddo
         enddo
        enddo
      elseif (ddir.eq.2) then
c       y derivative
        do ie=1,nelv
         do k=1,nz1
         do j=1,ny1
         do i=1,nx1          
            if (j.eq.1) then
              jm = j+1
              udum(i,j,k,ie) = u(i,jm,k,ie)
            elseif (j.eq.ny1) then
              jm = j-1
              udum(i,j,k,ie) = u(i,jm,k,ie)
            endif
         enddo
         enddo
         enddo
        enddo
      elseif (ddir.eq.3) then
c       z derivative
        do ie=1,nelv
         do k=1,nz1
         do j=1,ny1
         do i=1,nx1          
            if (k.eq.1) then
              km = k+1
              udum(i,j,k,ie) = u(i,j,km,ie)
            elseif (k.eq.nz1) then
              km = k-1
              udum(i,j,k,ie) = u(i,j,km,ie)
            endif
         enddo
         enddo
         enddo
        enddo

      endif     

      call copy(u,udum,n)
      call dsavg(u)

      return
      end


c-----------------------------------------------------------------------
      subroutine eddy_visc(ediff,e)
c
c     Compute eddy viscosity using dynamic smagorinsky model
c
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'


      real ediff(nx1*ny1*nz1,nelv),s(lx1*ly1*lz1,ldim,ldim)
      integer e

      common /dynsmg/ sij (lx1*ly1*lz1,ldim,ldim)
     $              , mij (lx1*ly1*lz1,3*ldim-3)
     $              , lij (lx1*ly1*lz1,3*ldim-3)
     $              , dg2 (lx1*ly1*lz1,lelv)
     $              , num (lx1*ly1*lz1,lelv)
     $              , den (lx1*ly1*lz1,lelv)
     $              , snrm(lx1*ly1*lz1,lelv)
C      $              , numy(ly1*lely),deny(ly1*lely),yy(ly1*lely)
      real sij,mij,lij,dg2,num,den,snrm
C       real msij(lx1*ly1*lz1,lelv)

      parameter(lxyz=lx1*ly1*lz1)
      common /xzmp0/ ur (lxyz) , us (lxyz) , ut (lxyz)
      real           vr (lxyz) , vs (lxyz) , vt (lxyz)
     $     ,         wr (lxyz) , ws (lxyz) , wt (lxyz)
      common /xzmp1/ w1(lx1*lelv),w2(lx1*lelv)

      !! NOTE CAREFUL USE OF EQUIVALENCE HERE !!
      equivalence (vr,lij(1,1)),(vs,lij(1,2)),(vt,lij(1,3))
     $          , (wr,lij(1,4)),(ws,lij(1,5)),(wt,lij(1,6))

      common /sgsflt/ fh(lx1*lx1),fht(lx1*lx1),diag(lx1)

      integer nt
      save    nt
      data    nt / -9 /

      ntot = nx1*ny1*nz1

      if (nt.lt.0) then 
        call set_ds_filt(fh,fht,nt,diag,nx1)! dyn. Smagorinsky filter
      endif


      call comp_gije(sij,vx(1,1,1,e),vy(1,1,1,e),vz(1,1,1,e),e)
      call comp_sije(sij)

      call mag_tensor_e(snrm(1,e),sij)
      call cmult(snrm(1,e),2.0,ntot)

C       call copy(msij,snrm,lx1*ly1*lz1*lelv)
    
      call comp_mij   (mij,sij,dg2,ur,us,fh,fht,nt,e)

      call comp_lij   (lij,vx,vy,vz,ur,us,ut,fh,fht,e)

c     Compute numerator (ur) & denominator (us) for Lilly contraction

      n = nx1*ny1*nz1
      do i=1,n
         ur(i) = mij(i,1)*lij(i,1)+mij(i,2)*lij(i,2)+mij(i,3)*lij(i,3)
     $      + 2*(mij(i,4)*lij(i,4)+mij(i,5)*lij(i,5)+mij(i,6)*lij(i,6))
         us(i) = mij(i,1)*mij(i,1)+mij(i,2)*mij(i,2)+mij(i,3)*mij(i,3)
     $      + 2*(mij(i,4)*mij(i,4)+mij(i,5)*mij(i,5)+mij(i,6)*mij(i,6))
      enddo

c     smoothing numerator and denominator in time
      call copy (vr,ur,nx1*nx1*nx1)
      call copy (vs,us,nx1*nx1*nx1)

      beta1 = 0.0                   ! Temporal averaging coefficients
      if (istep.gt.1) beta1 = 0.9   ! Retain 90 percent of past
      beta2 = 1. - beta1

      do i=1,n
         num (i,e) = beta1*num(i,e) + beta2*vr(i)
         den (i,e) = beta1*den(i,e) + beta2*vs(i)
      enddo


      return
      end

C       subroutine eddy_visc_01(ediff,uni,w1,igs_x)
      subroutine eddy_visc_01(ediff,w1,igs_x)

c
c     Compute eddy viscosity using dynamic smagorinsky model
c
      include 'SIZE'
      include 'TOTAL'
      include 'ZPER'

      real ediff(nx1*ny1*nz1,nelv)!,uni(lx1*ly1*lz1,nelv)
      real w1(lx1,ly1,lz1,nelv)
      integer igs_x

      common /dynsmg/ sij (lx1*ly1*lz1,ldim,ldim)
     $              , mij (lx1*ly1*lz1,3*ldim-3)
     $              , lij (lx1*ly1*lz1,3*ldim-3)
     $              , dg2 (lx1*ly1*lz1,lelv)
     $              , num (lx1*ly1*lz1,lelv)
     $              , den (lx1*ly1*lz1,lelv)
     $              , snrm(lx1*ly1*lz1,lelv)
      real sij,mij,lij,dg2,num,den,snrm

      integer ntot

      ntot = lx1*ly1*lz1*lelv


      call dsavg(num)   ! average across element boundaries
      call dsavg(den)

      call planar_avg(w1,num,igs_x) !x averaging
      call copy(num,w1,ntot)
      call planar_avg(w1,den,igs_x) !x averaging
      call copy(den,w1,ntot)

      do i=1,lx1*ly1*lz1*lelv
         cdyn = 0
C          if (den(i,1).gt.0) cdyn = 0.5*num(i,1)/den(i,1) !this is Cs**2'
         cdyn = 0.5*num(i,1)/den(i,1)
          ediff(i,1) = max(cdyn*dg2(i,1)*snrm(i,1),0.d0)
c         ediff(i,1) = cdyn*dg2(i,1)*snrm(i,1)

      enddo


      call copy(w1, dg2,ntot)

      return
      end


c-----------------------------------------------------------------------
      subroutine set_ds_filt(fh,fht,nt,diag,nx) ! setup test filter

      INCLUDE 'SIZE'

      real fh(nx*nx),fht(nx*nx),diag(nx)

c Construct transfer function
      call rone(diag,nx)

      diag(nx-0) = 0.01
      diag(nx-1) = 0.10
      diag(nx-2) = 0.50
      diag(nx-3) = 0.90
      diag(nx-4) = 0.99
      nt = nx - 2

c      diag(nx-0) = 0.05
c      diag(nx-1) = 0.50
c      diag(nx-2) = 0.95
c      nt = nx - 1

      call build_1d_filt(fh,fht,diag,nx,nid)

      return
      end
c-----------------------------------------------------------------------
      subroutine set_grid_spacing()
c
c     Compute D^2, the grid spacing used in the DS sgs model.
c
      include 'SIZE'
      include 'TOTAL'


      common /dynsmg/ sij (lx1*ly1*lz1,ldim,ldim)
     $              , mij (lx1*ly1*lz1,3*ldim-3)
     $              , lij (lx1*ly1*lz1,3*ldim-3)
     $              , dg2 (lx1*ly1*lz1,lelv)
     $              , num (lx1*ly1*lz1,lelv)
     $              , den (lx1*ly1*lz1,lelv)
     $              , snrm(lx1*ly1*lz1,lelv)
      real sij,mij,lij,dg2,num,den,snrm

      real dxmax, dymax, dzmax, rdum
      real damping, yplus
      real dist(nx1,ny1,nz1,nelv)


      integer e,eg,ex,ey,ez
      integer im, ip

      gamma = 1.
      gamma = gamma/ndim

      n = nx1*ny1*nz1*nelv
      call rone(dg2,n)


      dxmax = 0.0
      dymax = 0.0
      dzmax = 0.0
      call cheap_dist(dist,1,'W  ')


      do e=1,nelv
C          in the gll mesh the largest gridspace ins at the middle of the element
        im = int(nx1/2) +0
        ip = int(nx1/2) + 1
        dxmax = xm1(ip,1,1,e) - xm1(im,1,1,e) 
        dymax = ym1(1,ip,1,e) - ym1(1,im,1,e) 
        dzmax = zm1(1,1,ip,e) - zm1(1,1,im,e) 

C         do i=1,nx1-2
C             rdum = xm1(ip,1,1,e) - xm1(im,1,1,e) 


C         enddo
        do k=1,nx1*ny1*nz1
C           do j=1,ny1
C             do i=1,nx1
              yplus = dist(k,1,1,e)*RE_TAU
              damping = 1.0 - exp(-1.0*yplus/26.0)
              dg2(k,e) = damping * (dxmax*dymax*dzmax)**gamma
              dg2(k,e) =  dg2(k,e)**2
C             enddo
C           enddo
        enddo
      enddo


      call dsavg(dg2)  ! average neighboring elements

      return
      end

c-----------------------------------------------------------------------
      subroutine comp_lij(lij,u,v,w,fu,fv,fw,fh,fht,e)
c
c     Compute Lij for dynamic Smagorinsky model:
c                    _   _      _______
c          L_ij  :=  u_i u_j  - u_i u_j
c
      include 'SIZE'
c
      integer e
c
      real lij(lx1*ly1*lz1,3*ldim-3)
      real u  (lx1*ly1*lz1,lelv)
      real v  (lx1*ly1*lz1,lelv)
      real w  (lx1*ly1*lz1,lelv)
      real fu (1) , fv (1) , fw (1)
     $   , fh (1) , fht(1)

      call tens3d1(fu,u(1,e),fh,fht,nx1,nx1)  ! fh x fh x fh x u
      call tens3d1(fv,v(1,e),fh,fht,nx1,nx1)
      call tens3d1(fw,w(1,e),fh,fht,nx1,nx1)

      n = nx1*ny1*nz1
      do i=1,n
         lij(i,1) = fu(i)*fu(i)
         lij(i,2) = fv(i)*fv(i)
         lij(i,3) = fw(i)*fw(i)
         lij(i,4) = fu(i)*fv(i)
         lij(i,5) = fv(i)*fw(i)
         lij(i,6) = fw(i)*fu(i)
      enddo

      call col3   (fu,u(1,e),u(1,e),n)    !  _______
      call tens3d1(fv,fu,fh,fht,nx1,nx1)  !  u_1 u_1
      call sub2   (lij(1,1),fv,n)

      call col3   (fu,v(1,e),v(1,e),n)    !  _______
      call tens3d1(fv,fu,fh,fht,nx1,nx1)  !  u_2 u_2
      call sub2   (lij(1,2),fv,n)

      call col3   (fu,w(1,e),w(1,e),n)    !  _______
      call tens3d1(fv,fu,fh,fht,nx1,nx1)  !  u_3 u_3
      call sub2   (lij(1,3),fv,n)

      call col3   (fu,u(1,e),v(1,e),n)    !  _______
      call tens3d1(fv,fu,fh,fht,nx1,nx1)  !  u_1 u_2
      call sub2   (lij(1,4),fv,n)

      call col3   (fu,v(1,e),w(1,e),n)    !  _______
      call tens3d1(fv,fu,fh,fht,nx1,nx1)  !  u_2 u_3
      call sub2   (lij(1,5),fv,n)

      call col3   (fu,w(1,e),u(1,e),n)    !  _______
      call tens3d1(fv,fu,fh,fht,nx1,nx1)  !  u_3 u_1
      call sub2   (lij(1,6),fv,n)

      return
      end
c-----------------------------------------------------------------------
      subroutine comp_mij(mij,sij,dg2,fs,fi,fh,fht,nt,e)
c
c     Compute Mij for dynamic Smagorinsky model:
c
c                     2 _  ____     _______
c          M_ij  :=  a  S  S_ij  -  S  S_ij
c
      include 'SIZE'
c
      integer e
c
      real mij(lx1*ly1*lz1,3*ldim-3)
      real dg2(lx1*ly1*lz1,lelv)
      real fs (1) , fi (1) , fh (1) , fht(1)

      real magS(lx1*ly1*lz1)
      real sij (lx1*ly1*lz1*ldim*ldim)

      integer imap(6)
      data imap / 0,4,8,1,5,2 /

      n = nx1*ny1*nz1

      call mag_tensor_e(magS,sij)
      call cmult(magS,2.0,n)

c     Filter S
      call tens3d1(fs,magS,fh,fht,nx1,nx1)  ! fh x fh x fh x |S|

c     a2 is the test- to grid-filter ratio, squared

      a2 = nx1-1       ! nx1-1 is number of spaces in grid
      a2 = a2 /(nt-1)  ! nt-1 is number of spaces in filtered grid

      do k=1,6
         jj = n*imap(k) + 1
         call col3   (fi,magS,sij(jj),n)
         call tens3d1(mij(1,k),fi,fh,fht,nx1,nx1)
     $        ! fh x fh x fh x (|S|S_ij)
         call tens3d1(fi,sij(jj),fh,fht,nx1,nx1)  ! fh x fh x fh x S_ij
         do i=1,n
            mij(i,k) = (a2**2 * fs(i)*fi(i) - mij(i,k))*dg2(i,e)
         enddo
      enddo

      return
      end

